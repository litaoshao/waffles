<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>GClasses: GClasses Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript">
$(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.3 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">GClasses</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('namespace_g_classes.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<h1>GClasses Namespace Reference</h1>  </div>
</div>
<div class="contents">
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_g_classes_1_1_s_o_m.html">SOM</a></td></tr>
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g3_d_vector.html">G3DVector</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a 3D vector.  <a href="class_g_classes_1_1_g3_d_vector.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g3_d_matrix.html">G3DMatrix</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a 3x3 matrix.  <a href="class_g_classes_1_1_g3_d_matrix.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_camera.html">GCamera</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This camera assumes the canvas is specified in cartesian coordinates. The 3D space is based on a right-handed coordinate system. (So if x goes to the right and y goes up, then z comes out of the screen toward you.)  <a href="class_g_classes_1_1_g_camera.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_billboard.html">GBillboard</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a billboard (a 2-D image in a 3-D world) for use with <a class="el" href="class_g_classes_1_1_g_billboard_world.html" title="This class represents a world of billboards, and provides a rendering engine.">GBillboardWorld</a>. You can set m_repeatX and/or m_repeatY to make the image repeat across the billboard.  <a href="class_g_classes_1_1_g_billboard.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_billboard_world.html">GBillboardWorld</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents a world of billboards, and provides a rendering engine.  <a href="class_g_classes_1_1_g_billboard_world.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_activation_function.html">GActivationFunction</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The base class for activation functions. Typically, this are sigmoid-shaped functions used to "squash" the output of a network node. These are typically used in conjunction with the <a class="el" href="class_g_classes_1_1_g_neural_net.html" title="An artificial neural network.">GNeuralNet</a> class.  <a href="class_g_classes_1_1_g_activation_function.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_activation_logistic.html">GActivationLogistic</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The logistic activation function.  <a href="class_g_classes_1_1_g_activation_logistic.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_activation_arc_tan.html">GActivationArcTan</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The arctan activation function.  <a href="class_g_classes_1_1_g_activation_arc_tan.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_activation_tan_h.html">GActivationTanH</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The hyperbolic tangent activation function.  <a href="class_g_classes_1_1_g_activation_tan_h.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_activation_algebraic.html">GActivationAlgebraic</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The hyperbolic tangent activation function.  <a href="class_g_classes_1_1_g_activation_algebraic.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_activation_identity.html">GActivationIdentity</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Use this function when you do not want to squash the net. For example, using this activation function with a network that has no hidden layers makes a perceptron model. Also, it is common to use this activation function on the output layer for regression problems.  <a href="class_g_classes_1_1_g_activation_identity.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_activation_bend.html">GActivationBend</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This provides an alternative to using <a class="el" href="class_g_classes_1_1_g_activation_identity.html" title="Use this function when you do not want to squash the net. For example, using this activation function...">GActivationIdentity</a> on the output layer for regression problems. It may add more power because it is non-linear, but like the identity function, its co-domain is the same as its domain.  <a href="class_g_classes_1_1_g_activation_bend.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_activation_bi_dir.html">GActivationBiDir</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an output-layer activation function shaped like a sigmoid, but with both a co-domain and domain that spans the continuous values.  <a href="class_g_classes_1_1_g_activation_bi_dir.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_activation_piecewise.html">GActivationPiecewise</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an experimental activation function intended to reduce the required computation involved in inverting neural networks.  <a href="class_g_classes_1_1_g_activation_piecewise.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_activation_gaussian.html">GActivationGaussian</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a simple Gaussian function.  <a href="class_g_classes_1_1_g_activation_gaussian.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_activation_sinc.html">GActivationSinc</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a canonical wavelet.  <a href="class_g_classes_1_1_g_activation_sinc.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_pipe.html">GPipe</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This class wraps the handle of a pipe. It closes the pipe when it is destroyed. This class is useful in conjunction with <a class="el" href="class_g_classes_1_1_g_app.html#ae973a376ac63f7133cd0239bdb7844a4" title="Executes the specified system command. (szCommand should contain the app name as well as args...">GApp::systemExecute</a> for reading from, or writing to, the standard i/o streams of a child process.  <a href="class_g_classes_1_1_g_pipe.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_app.html">GApp</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains some generally useful functions for launching applications.  <a href="class_g_classes_1_1_g_app.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_signal_handler.html">GSignalHandler</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Temporarily handles certain signals. (When this object is destroyed, it puts all the signal handlers back the way they were.) Periodically call "check" to see if a signal has occurred.  <a href="class_g_classes_1_1_g_signal_handler.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_passive_console.html">GPassiveConsole</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides a non-blocking method for reading characters from stdin. (If there are no characters ready in stdin, it immediately returns '\0'.) The constructor sets flags on the console so that it passes characters to the stream immediately (instead of when Enter is pressed), and so that it doesn't echo the keys (if desired), and it makes stdin non-blocking. The destructor puts all those things back the way they were.  <a href="class_g_classes_1_1_g_passive_console.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_arg_reader.html">GArgReader</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses command-line args and provides methods to conveniently process them.  <a href="class_g_classes_1_1_g_arg_reader.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_bayesian_network_node.html">GBayesianNetworkNode</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the base class for all nodes in a Bayesian network. Classes that inherit from this class must implement three pure virtual methods. Note that the <a class="el" href="class_g_classes_1_1_g_univariate_distribution.html" title="This is the base class for univariate distributions.">GUnivariateDistribution</a> class has an IsDiscrete and an IsSupported method, so if your class wraps a <a class="el" href="class_g_classes_1_1_g_univariate_distribution.html" title="This is the base class for univariate distributions.">GUnivariateDistribution</a> then two of them are taken care of for you. In order to implement ComputeLogLikelihood, your class will probably need references to its parent nodes so that it can obtain their values to use as parameters for its distribution. You can implement your network structure however you like. When you have your network set up, you're ready to use MCMC to infer values for the network. To do this, just create a loop that calls Sample on each node in the network, and the whole network should eventually converge to good values. (Also, you need to make <a class="el" href="class_g_classes_1_1_g_bayesian_network_child_iterator.html" title="Iterates through all the children of the specified node in a Bayesian network.">GBayesianNetworkChildIterator</a> work, which I haven't worked out yet.)  <a href="class_g_classes_1_1_g_bayesian_network_node.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_bayesian_network_child_iterator.html">GBayesianNetworkChildIterator</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterates through all the children of the specified node in a Bayesian network.  <a href="class_g_classes_1_1_g_bayesian_network_child_iterator.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_bezier.html">GBezier</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a Bezier curve.  <a href="class_g_classes_1_1_g_bezier.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_nurbs.html">GNurbs</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">NURBS = Non Uniform Rational B-Spline Periodic = closed loop.  <a href="class_g_classes_1_1_g_nurbs.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_big_int.html">GBigInt</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents an integer of arbitrary size, and provides basic arithmetic functionality. Also contains functionality for implementing RSA symmetric-key cryptography.  <a href="class_g_classes_1_1_g_big_int.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_bits.html">GBits</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains various functions for bit analysis.  <a href="class_g_classes_1_1_g_bits.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_bit_table.html">GBitTable</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a table of bits.  <a href="class_g_classes_1_1_g_bit_table.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_blob_incoming.html">GBlobIncoming</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is for deserializing blobs. It takes care of Endianness issues and protects against buffer overruns. This class would be particularly useful for writing a network protocol.  <a href="class_g_classes_1_1_g_blob_incoming.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_blob_outgoing.html">GBlobOutgoing</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is for serializing objects. It is the complement to <a class="el" href="class_g_classes_1_1_g_blob_incoming.html" title="This class is for deserializing blobs. It takes care of Endianness issues and protects against buffer...">GBlobIncoming</a>.  <a href="class_g_classes_1_1_g_blob_outgoing.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_blob_queue.html">GBlobQueue</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a special queue for handling blobs that come in and go out in varying sizes. It is particulary designed for streaming things that must travel or be parsed in packets that may differ in size from how they are sent or transmitted.  <a href="class_g_classes_1_1_g_blob_queue.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_chess_board.html">GChessBoard</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the state of a chess board, and provides some basic functionality for implementing a chess game.  <a href="class_g_classes_1_1_g_chess_board.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_chess_move_iterator.html">GChessMoveIterator</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterates through all the possible moves for the specified color. It iterates through the pieces in a random order. It also iterates through the moves for each piece in a random order, but it will visit each move for the current piece before considering the next piece.  <a href="class_g_classes_1_1_g_chess_move_iterator.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_clusterer.html">GClusterer</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The base class for clustering algorithms. Classes that inherit from this class must implement a method named "cluster" which performs clustering, and a method named "whichCluster" which reports which cluster the specified row is determined to be a member of.  <a href="class_g_classes_1_1_g_clusterer.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_sparse_clusterer.html">GSparseClusterer</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a base class for clustering algorithms that operate on sparse matrices.  <a href="class_g_classes_1_1_g_sparse_clusterer.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_agglomerative_clusterer.html">GAgglomerativeClusterer</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This merges each cluster with its closest neighbor. (The distance between clusters is computed as the distance between the closest members of the clusters times (n^b), where n is the total number of points from both clusters, and b is a balancing factor.  <a href="class_g_classes_1_1_g_agglomerative_clusterer.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_agglomerative_transducer.html">GAgglomerativeTransducer</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a semi-supervised agglomerative clusterer. It can only handle one output, and it must be nominal. All inputs must be continuous. Also, it assumes that all output values are represented in the training set.  <a href="class_g_classes_1_1_g_agglomerative_transducer.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_k_means.html">GKMeans</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">An implementation of the K-means clustering algorithm.  <a href="class_g_classes_1_1_g_k_means.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_fuzzy_k_means.html">GFuzzyKMeans</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A K-means clustering algorithm where every point has partial membership in each cluster. This algorithm is specified in Li, D. and Deogun, J. and Spaulding, W. and Shuart, B., Towards missing data imputation: A study of fuzzy K-means clustering method, In Rough Sets and Current Trends in Computing, Springer, pages 573--579, 2004.  <a href="class_g_classes_1_1_g_fuzzy_k_means.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_k_medoids.html">GKMedoids</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">An implementation of the K-medoids clustering algorithm.  <a href="class_g_classes_1_1_g_k_medoids.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_k_medoids_sparse.html">GKMedoidsSparse</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">An implementation of the K-medoids clustering algorithm for sparse data.  <a href="class_g_classes_1_1_g_k_medoids_sparse.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_k_means_sparse.html">GKMeansSparse</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">An implementation of the K-means clustering algorithm.  <a href="class_g_classes_1_1_g_k_means_sparse.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_graph_cut_transducer.html">GGraphCutTransducer</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A transduction algorithm that uses a max-flow/min-cut graph-cut algorithm to partition the data until each class is in a separate cluster. Unlabeled points are then assigned the label of the cluster in which they fall.  <a href="class_g_classes_1_1_g_graph_cut_transducer.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_crypto.html">GCrypto</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a symmetric-key block-cypher. It utilizes a 2048-byte internal state which is initialized using the passphrase. It uses repeated applications of sha-512 to advance the internal state, and to generate an 1024-byte pad that it xor's with your data to encrypt or decrypt it. Warning: You use this algorithm at your own risk. Many encryption algorithms eventually turn out to be insecure, and to my knowledge, this algorithm has not yet been extensively scrutinized.  <a href="class_g_classes_1_1_g_crypto.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_decision_tree.html">GDecisionTree</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an efficient learning algorithm. It divides on the attributes that reduce entropy the most, or alternatively can make random divisions.  <a href="class_g_classes_1_1_g_decision_tree.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_mean_margins_tree.html">GMeanMarginsTree</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="class_g_classes_1_1_g_mean_margins_tree.html" title="A GMeanMarginsTree is an oblique decision tree specified in Gashler, Michael S. and Giraud-Carrier...">GMeanMarginsTree</a> is an oblique decision tree specified in Gashler, Michael S. and Giraud-Carrier, Christophe and Martinez, Tony. Decision Tree Ensemble: Small Heterogeneous Is Better Than Large Homogeneous. In The Seventh International Conference on Machine Learning and Applications, Pages 900 - 905, ICMLA '08. 2008. It divides features as follows: It finds the mean and principle component of the output vectors. It divides all the vectors into two groups, one that has a positive dot-product with the principle component (after subtracting the mean) and one that has a negative dot-product with the principle component (after subtracting the mean). Next it finds the average input vector for each of the two groups. Then it finds the mean and principle component of those two vectors. The dividing criteria for this node is to subtract the mean and then see whether the dot-product with the principle component is positive or negative.  <a href="class_g_classes_1_1_g_mean_margins_tree.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_random_forest.html">GRandomForest</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_g_classes_1_1_g_diff_line.html">GDiffLine</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a helper struct used by <a class="el" href="class_g_classes_1_1_g_diff.html" title="This class finds the differences between two text files It is case and whitespace sensitive...">GDiff</a>.  <a href="struct_g_classes_1_1_g_diff_line.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_diff.html">GDiff</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This class finds the differences between two text files It is case and whitespace sensitive, but is tolerant of Unix/Windows/Mac line endings. It uses lines as the atomic unit. It accepts matching lines in a greedy manner.  <a href="class_g_classes_1_1_g_diff.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_dir_list.html">GDirList</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This class contains a list of files and a list of folders. The constructor populates these lists with the names of files and folders in the current working directory.  <a href="class_g_classes_1_1_g_dir_list.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_folder_serializer.html">GFolderSerializer</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This turns a file or a folder (and its contents recursively) into a stream of bytes.  <a href="class_g_classes_1_1_g_folder_serializer.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_folder_deserializer.html">GFolderDeserializer</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This class complements <a class="el" href="class_g_classes_1_1_g_folder_serializer.html" title="This turns a file or a folder (and its contents recursively) into a stream of bytes.">GFolderSerializer</a>.  <a href="class_g_classes_1_1_g_folder_deserializer.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_distance_metric.html">GDistanceMetric</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This class enables you to define a distance (or dissimilarity) metric between two vectors. pScaleFactors is an optional parameter (it can be NULL) that lets the calling class scale the significance of each dimension. Distance metrics that do not mix with this concept may simply ignore any scale factors. Typically, classes that use this should be able to assume that the triangle inequality will hold, but do not necessarily enforce the parallelogram law.  <a href="class_g_classes_1_1_g_distance_metric.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_row_distance.html">GRowDistance</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This uses a combination of Euclidean distance for continuous attributes, and Hamming distance for nominal attributes. In particular, for each attribute, it calculates pA[i]-pB[i], squares it and takes the square root of that sum. For nominal attributes pA[i]-pB[i] is 0 if they are the same and 1 if they are different.  <a href="class_g_classes_1_1_g_row_distance.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_row_distance_scaled.html">GRowDistanceScaled</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This uses a combination of Euclidean distance for continuous attributes, and Hamming distance for nominal attributes. This version honors scale factors given by the user. See comments on <a class="el" href="class_g_classes_1_1_g_row_distance.html" title="This uses a combination of Euclidean distance for continuous attributes, and Hamming distance for nom...">GRowDistance</a>.  <a href="class_g_classes_1_1_g_row_distance_scaled.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_l_norm_distance.html">GLNormDistance</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolates between manhattan distance (norm=1), Euclidean distance (norm=2), and Chebyshev distance (norm=infinity). For nominal attributes, Hamming distance is used.  <a href="class_g_classes_1_1_g_l_norm_distance.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_sparse_similarity.html">GSparseSimilarity</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The base class for similarity metrics that operate on sparse vectors.  <a href="class_g_classes_1_1_g_sparse_similarity.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_cosine_similarity.html">GCosineSimilarity</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a similarity metric that computes the cosine of the angle bewtween two sparse vectors.  <a href="class_g_classes_1_1_g_cosine_similarity.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_pearson_correlation.html">GPearsonCorrelation</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a similarity metric that computes the Pearson correlation between two sparse vectors.  <a href="class_g_classes_1_1_g_pearson_correlation.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_distribution.html">GDistribution</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_univariate_distribution.html">GUnivariateDistribution</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the base class for univariate distributions.  <a href="class_g_classes_1_1_g_univariate_distribution.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_categorical_distribution.html">GCategoricalDistribution</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a distribution that specifies a probability for each value in a set of nominal values.  <a href="class_g_classes_1_1_g_categorical_distribution.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_categorical_sampler.html">GCategoricalSampler</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is for efficiently drawing random values from a categorical distribution with a large number of categories.  <a href="class_g_classes_1_1_g_categorical_sampler.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_categorical_sampler_batch.html">GCategoricalSamplerBatch</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_normal_distribution.html">GNormalDistribution</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the Normal (a.k.a. Gaussian) distribution.  <a href="class_g_classes_1_1_g_normal_distribution.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_uniform_distribution.html">GUniformDistribution</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a continuous uniform distribution.  <a href="class_g_classes_1_1_g_uniform_distribution.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_poisson_distribution.html">GPoissonDistribution</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The Poisson distribution.  <a href="class_g_classes_1_1_g_poisson_distribution.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_gamma_distribution.html">GGammaDistribution</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The Gamma distribution.  <a href="class_g_classes_1_1_g_gamma_distribution.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_inverse_gamma_distribution.html">GInverseGammaDistribution</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The inverse Gamma distribution.  <a href="class_g_classes_1_1_g_inverse_gamma_distribution.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_beta_distribution.html">GBetaDistribution</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The Beta distribution.  <a href="class_g_classes_1_1_g_beta_distribution.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_soft_impulse_distribution.html">GSoftImpulseDistribution</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_multivariate_normal_distribution.html">GMultivariateNormalDistribution</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A multivariate Normal distribution. It can compute the likelihood of a specified vector, and can also generate random vectors from the distribution.  <a href="class_g_classes_1_1_g_multivariate_normal_distribution.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_dom_list_iterator.html">GDomListIterator</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This class iterates over the items in a list node.  <a href="class_g_classes_1_1_g_dom_list_iterator.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_dom_node.html">GDomNode</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a single node in a DOM.  <a href="class_g_classes_1_1_g_dom_node.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_dom.html">GDom</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A Document Object Model. This represents a document as a hierarchy of objects. The DOM can be loaded-from or saved-to a file in JSON (JavaScript Object Notation) format. (See <a href="http://json.org.">http://json.org.</a>) In the future, support for XML and/or other formats may be added.  <a href="class_g_classes_1_1_g_dom.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_dynamic_page_session_extension.html">GDynamicPageSessionExtension</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_dynamic_page_session.html">GDynamicPageSession</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_dynamic_page_server.html">GDynamicPageServer</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_weighted_model.html">GWeightedModel</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a helper-class used by <a class="el" href="class_g_classes_1_1_g_bag.html" title="BAG stands for bootstrap aggregator. It represents an ensemble of voting modelers. Each model is trained with a slightly different training set, which is produced by drawing randomly from the original training set with replacement until we have a new training set of the same size. Each model is given equal weight in the vote.">GBag</a>.  <a href="class_g_classes_1_1_g_weighted_model.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_ensemble.html">GEnsemble</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a base-class for ensembles that combine the predictions from multiple weightd models.  <a href="class_g_classes_1_1_g_ensemble.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_bag.html">GBag</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">BAG stands for bootstrap aggregator. It represents an ensemble of voting modelers. Each model is trained with a slightly different training set, which is produced by drawing randomly from the original training set with replacement until we have a new training set of the same size. Each model is given equal weight in the vote.  <a href="class_g_classes_1_1_g_bag.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_bayesian_model_averaging.html">GBayesianModelAveraging</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an ensemble that uses the bagging approach for training, and Bayesian Model Averaging to combine the models. That is, it trains each model with data drawn randomly with replacement from the original training data. It combines the models with weights proporitional to their likelihood as computed using Bayes' law.  <a href="class_g_classes_1_1_g_bayesian_model_averaging.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_bayesian_model_combination.html">GBayesianModelCombination</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_ada_boost.html">GAdaBoost</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_wag.html">GWag</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This model trains several multi-layer perceptrons, then averages their weights together in an intelligent manner.  <a href="class_g_classes_1_1_g_wag.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_bucket.html">GBucket</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">When Train is called, this performs cross-validation on the training set to determine which learner is the best. It then trains that learner with the entire training set.  <a href="class_g_classes_1_1_g_bucket.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_evolutionary_optimizer.html">GEvolutionaryOptimizer</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Uses an evolutionary process to optimize a vector.  <a href="class_g_classes_1_1_g_evolutionary_optimizer.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_g_classes_1_1_path_data.html">PathData</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper struct to hold the results from GFile::ParsePath.  <a href="struct_g_classes_1_1_path_data.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_file.html">GFile</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains some useful routines for manipulating files.  <a href="class_g_classes_1_1_g_file.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_compressor.html">GCompressor</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This implements a simple compression/decompression algorithm.  <a href="class_g_classes_1_1_g_compressor.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_g_classes_1_1_complex_number.html">ComplexNumber</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_fourier.html">GFourier</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Fourier transform.  <a href="class_g_classes_1_1_g_fourier.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>strCmp</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_function.html">GFunction</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents a math function. (It might be used, for example, in a plotting tool.)  <a href="class_g_classes_1_1_g_function.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_function_parser.html">GFunctionParser</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This class parses math equations. (This is useful, for example, for plotting tools.)  <a href="class_g_classes_1_1_g_function_parser.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_graph_cut.html">GGraphCut</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This implements an optimized max-flow/min-cut algorithm described in "An experimental comparison of min-cut/max-flow algorithms for energy minimization in vision" by Boykov, Y. and Kolmogorov, V. This implementation assumes that edges are undirected.  <a href="class_g_classes_1_1_g_graph_cut.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_graph_edge_iterator.html">GGraphEdgeIterator</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterates over the edges that connect to the specified node.  <a href="class_g_classes_1_1_g_graph_edge_iterator.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_floyd_warshall.html">GFloydWarshall</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the shortest-cost path between all pairs of vertices in a graph. Takes O(n^3) time.  <a href="class_g_classes_1_1_g_floyd_warshall.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_dijkstra.html">GDijkstra</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the shortest path from an origin vertex to all other vertices. Implemented with a binary-heap priority-queue. If the graph is sparse on edges, it will run in about O(n log(n)) time. If the graph is dense, it runs in about O(n^2 log(n))  <a href="class_g_classes_1_1_g_dijkstra.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_brandes_betweenness_centrality.html">GBrandesBetweennessCentrality</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the number of times that the shortest-path between every pair of points passes over each edge and vertex.  <a href="class_g_classes_1_1_g_brandes_betweenness_centrality.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_atomic_cycle_finder.html">GAtomicCycleFinder</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This finds all of the atomic cycles (cycles that cannot be divided into two smaller cycles) in a graph.  <a href="class_g_classes_1_1_g_atomic_cycle_finder.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_hash_table_base.html">GHashTableBase</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The base class of hash tables.  <a href="class_g_classes_1_1_g_hash_table_base.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_hash_table_enumerator.html">GHashTableEnumerator</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This class iterates over the values in a hash table.  <a href="class_g_classes_1_1_g_hash_table_enumerator.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_hash_table.html">GHashTable</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements a typical hash table. (It doesn't take ownership of the objects you add, so you must still delete them yourself.)  <a href="class_g_classes_1_1_g_hash_table.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_const_string_hash_table.html">GConstStringHashTable</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Hash table based on keys of constant strings (or at least strings that won't change during the lifetime of the hash table). It's a good idea to use a <a class="el" href="class_g_classes_1_1_g_heap.html" title="Provides a heap in which to put strings or whatever you need to store. If you need to allocate space ...">GHeap</a> in connection with this class.  <a href="class_g_classes_1_1_g_const_string_hash_table.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_const_string_to_index_hash_table.html">GConstStringToIndexHashTable</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Hash table based on keys of constant strings (or at least strings that won't change during the lifetime of the hash table). It's a good idea to use a <a class="el" href="class_g_classes_1_1_g_heap.html" title="Provides a heap in which to put strings or whatever you need to store. If you need to allocate space ...">GHeap</a> in connection with this class.  <a href="class_g_classes_1_1_g_const_string_to_index_hash_table.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_g_classes_1_1_hash_bucket.html">HashBucket</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an internal structure used by <a class="el" href="class_g_classes_1_1_g_hash_table.html" title="Implements a typical hash table. (It doesn&#39;t take ownership of the objects you add...">GHashTable</a>.  <a href="struct_g_classes_1_1_hash_bucket.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_hash_table_node.html">HashTableNode</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Objects used with <a class="el" href="class_g_classes_1_1_g_node_hash_table.html" title="This is a hash table that uses any object which inherits from HashTableNode as the key...">GNodeHashTable</a> should inherit from this class. They must implement two methods (to hash and compare the nodes).  <a href="class_g_classes_1_1_hash_table_node.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_node_hash_table.html">GNodeHashTable</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a hash table that uses any object which inherits from <a class="el" href="class_g_classes_1_1_hash_table_node.html" title="Objects used with GNodeHashTable should inherit from this class. They must implement two methods (to ...">HashTableNode</a> as the key.  <a href="class_g_classes_1_1_g_node_hash_table.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_heap.html">GHeap</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides a heap in which to put strings or whatever you need to store. If you need to allocate space for a lot of small objects, it's much more efficient to use this class than the C++ heap. Plus, you can delete them all by simply deleting the heap. You can't, however, reuse the space for individual objects in this heap.  <a href="class_g_classes_1_1_g_heap.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_hidden_markov_model.html">GHiddenMarkovModel</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_momentum_greedy_search.html">GMomentumGreedySearch</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">At each iteration this algorithm moves in only one dimension. If the situation doesn't improve it tries the opposite direction. If both directions are worse, it decreases the step size for that dimension, otherwise it increases the step size for that dimension.  <a href="class_g_classes_1_1_g_momentum_greedy_search.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_hill_climber.html">GHillClimber</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_annealing.html">GAnnealing</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This algorithm tries the current direction and a slightly perturbed direction at each step. If the perturbed direction resulted in faster improvement, it becomes the new current direction. As long as the current direction yields improvement, it accelerates, otherwise it decelerates.  <a href="class_g_classes_1_1_g_annealing.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_empirical_gradient_descent.html">GEmpiricalGradientDescent</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This algorithm does a gradient descent by feeling a small distance out in each dimension to measure the gradient. For efficiency reasons, it only measures the gradient in one dimension (which it cycles round-robin style) per iteration and uses the remembered gradient in the other dimensions.  <a href="class_g_classes_1_1_g_empirical_gradient_descent.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_sample_climber.html">GSampleClimber</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a variant of empirical gradient descent that tries to estimate the gradient using a minimal number of samples. It is more efficient than empirical gradient descent, but it only works well if the optimization surface is quite locally linear.  <a href="class_g_classes_1_1_g_sample_climber.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_histogram.html">GHistogram</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gathers values and puts them in bins.  <a href="class_g_classes_1_1_g_histogram.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_temp_buf_helper.html">GTempBufHelper</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A helper class used by the GTEMPBUF macro.  <a href="class_g_classes_1_1_g_temp_buf_helper.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_holder.html">Holder</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is very similar to the standard C++ class auto_ptr, except it throws an exception if you try to make a copy of it. This way, it will fail early if you use it in a manner that could result in non-deterministic behavior. (For example, if you create a vector of auto_ptrs, wierd things happen if an oom exception is thrown while resizing the buffer--part of the data will be lost when it reverts back to the original buffer. But if you make a vector of these, it will fail quickly, thus alerting you to the issue.)  <a href="class_g_classes_1_1_holder.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_array_holder.html">ArrayHolder</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Just like <a class="el" href="class_g_classes_1_1_holder.html" title="This class is very similar to the standard C++ class auto_ptr, except it throws an exception if you t...">Holder</a>, except for arrays.  <a href="class_g_classes_1_1_array_holder.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_file_holder.html">FileHolder</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Closes a file when this object goes out of scope.  <a href="class_g_classes_1_1_file_holder.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_vector_of_pointers_holder.html">VectorOfPointersHolder</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes all of the pointers in a vector when this object goes out of scope.  <a href="class_g_classes_1_1_vector_of_pointers_holder.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1smart__ptr__ref__counter.html">smart_ptr_ref_counter</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A helper class used by the <a class="el" href="class_g_classes_1_1smart__ptr.html" title="A reference-counting smart-pointer.">smart_ptr</a> class.  <a href="class_g_classes_1_1smart__ptr__ref__counter.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1smart__ptr.html">smart_ptr</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A reference-counting smart-pointer.  <a href="class_g_classes_1_1smart__ptr.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_overrun_sentinel.html">GOverrunSentinel</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Placing these on the stack can help catch buffer overruns.  <a href="class_g_classes_1_1_g_overrun_sentinel.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_html.html">GHtml</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is for parsing HTML files. It's designed to be very simple. This class might be useful, for example, for building a web-crawler or for extracting readable text from a web page.  <a href="class_g_classes_1_1_g_html.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_http_client.html">GHttpClient</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This class allows you to get files using the HTTP protocol.  <a href="class_g_classes_1_1_g_http_client.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_web_socket_client.html">GWebSocketClient</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_http_server.html">GHttpServer</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This class allows you to implement a simple HTTP daemon.  <a href="class_g_classes_1_1_g_http_server.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_g_classes_1_1str_comp.html">strComp</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_http_param_parser.html">GHttpParamParser</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A class for parsing the name/value pairs that follow the "?" in a URL.  <a href="class_g_classes_1_1_g_http_param_parser.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_http_multipart_parser.html">GHttpMultipartParser</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_image.html">GImage</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents an image.  <a href="class_g_classes_1_1_g_image.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_extended_kalman_filter.html">GExtendedKalmanFilter</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an implementation of the Extended Kalman Filter. This class is used by alternately calling advance and correct.  <a href="class_g_classes_1_1_g_extended_kalman_filter.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_kernel.html">GKernel</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The base class for kernel functions. Classes which implement this must provide an "apply" method that applies the kernel to two vectors. Kernels may be combined together to form a more complex kernel, to which the kernel trick will still apply.  <a href="class_g_classes_1_1_g_kernel.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_kernel_identity.html">GKernelIdentity</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The identity kernel.  <a href="class_g_classes_1_1_g_kernel_identity.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_kernel_polynomial.html">GKernelPolynomial</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A polynomial kernel.  <a href="class_g_classes_1_1_g_kernel_polynomial.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_kernel_gaussian_r_b_f.html">GKernelGaussianRBF</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A Gaussian RBF kernel.  <a href="class_g_classes_1_1_g_kernel_gaussian_r_b_f.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_kernel_translate.html">GKernelTranslate</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A translation kernel.  <a href="class_g_classes_1_1_g_kernel_translate.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_kernel_scale.html">GKernelScale</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A scalar kernel.  <a href="class_g_classes_1_1_g_kernel_scale.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_kernel_add.html">GKernelAdd</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">An addition kernel.  <a href="class_g_classes_1_1_g_kernel_add.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_kernel_multiply.html">GKernelMultiply</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A multiplication kernel.  <a href="class_g_classes_1_1_g_kernel_multiply.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_kernel_pow.html">GKernelPow</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A power kernel.  <a href="class_g_classes_1_1_g_kernel_pow.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_kernel_exp.html">GKernelExp</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The Exponential kernel.  <a href="class_g_classes_1_1_g_kernel_exp.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_kernel_normalize.html">GKernelNormalize</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A Normalizing kernel.  <a href="class_g_classes_1_1_g_kernel_normalize.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_key_pair.html">GKeyPair</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_k_n_n.html">GKNN</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The k-Nearest Neighbor learning algorithm.  <a href="class_g_classes_1_1_g_k_n_n.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_neighbor_transducer.html">GNeighborTransducer</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">An instance-based transduction algorithm.  <a href="class_g_classes_1_1_g_neighbor_transducer.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_instance_table.html">GInstanceTable</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This represents a grid of values. It might be useful as a Q-table with Q-learning.  <a href="class_g_classes_1_1_g_instance_table.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_prediction.html">GPrediction</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is used to represent the predicted distribution made by a supervised learning algorithm. (It is just a shallow wrapper around <a class="el" href="class_g_classes_1_1_g_distribution.html">GDistribution</a>.) It is used in conjunction with calls to <a class="el" href="class_g_classes_1_1_g_supervised_learner.html#ac459ae8751f42b1dd85839ae419ee320" title="Evaluate pIn and compute a prediction for pOut. pOut is expected to point to an array of GPrediction ...">GSupervisedLearner::predictDistribution</a>. The predicted distributions will be either categorical distributions (for nominal values) or Normal distributions (for continuous values).  <a href="class_g_classes_1_1_g_prediction.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_transducer.html">GTransducer</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the base class of supervised learning algorithms (that may or may not have an internal model allowing them to generalize rows that were not available at training time). Note that the literature typically refers to supervised learning algorithms that can't generalize (because they lack an internal hypothesis model) as "Semi-supervised". (You cannot generalize with a semi-supervised algorithm--you have to train again with the new rows.)  <a href="class_g_classes_1_1_g_transducer.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_supervised_learner.html">GSupervisedLearner</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the base class of algorithms that learn with supervision and have an internal hypothesis model that allows them to generalize rows that were not available at training time.  <a href="class_g_classes_1_1_g_supervised_learner.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_incremental_learner.html">GIncrementalLearner</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the base class of supervised learning algorithms that can learn one row at a time.  <a href="class_g_classes_1_1_g_incremental_learner.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_learner_loader.html">GLearnerLoader</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is for loading various learning algorithms from a DOM. When any learning algorithm is saved, it calls baseDomNode, which creates (among other things) a field named "class" which specifies the class name of the algorithm. This class contains methods that will recognize any of the classes in this library and load them. If it doesn't recognize a class, it will either return NULL or throw and exception, depending on the flags you pass to the constructor. Obviously this loader won't recognize any classes that you make. Therefore, you should overload the corresponding method in this class with a new method that will first recognize and load your classes, and then call these methods to handle other types.  <a href="class_g_classes_1_1_g_learner_loader.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_baseline_learner.html">GBaselineLearner</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Always outputs the label mean (for continuous labels) and the most common class (for nominal labels).  <a href="class_g_classes_1_1_g_baseline_learner.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_identity_function.html">GIdentityFunction</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an implementation of the identity function. It might be useful, for example, as the observation function in a <a class="el" href="class_g_classes_1_1_g_recurrent_model.html" title="This class can be used to implement recurrent neural networks, or recurrent forms of other supervised...">GRecurrentModel</a> if you want to create a Jordan network.  <a href="class_g_classes_1_1_g_identity_function.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_linear_regressor.html">GLinearRegressor</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A linear regression model. Let f be a feature vector of real values, and let l be a label vector of real values, then this model estimates l=Bf+e, where B is a matrix of real values, and e is a vector of real values. (In the Wikipedia article on linear regression, B is called "beta", and e is called "epsilon". The approach used by this model to compute beta and epsilon, however, is much more efficient than the approach currently described in that article.)  <a href="class_g_classes_1_1_g_linear_regressor.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_linear_programming.html">GLinearProgramming</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_manifold.html">GManifold</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This class stores static methods that are useful for manifold learning.  <a href="class_g_classes_1_1_g_manifold.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_manifold_learner.html">GManifoldLearner</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the base class of manifold learning (aka non-linear dimensionality reducing) algorithms.  <a href="class_g_classes_1_1_g_manifold_learner.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_manifold_sculpting.html">GManifoldSculpting</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Manifold Sculpting. A non-linear dimensionality reduction algorithm. (See Gashler, Michael S. and Ventura, Dan and Martinez, Tony. Iterative non-linear dimensionality reduction with manifold sculpting. In Advances in Neural Information Processing Systems 20, pages 513–520, MIT Press, Cambridge, MA, 2008.)  <a href="class_g_classes_1_1_g_manifold_sculpting.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_isomap.html">GIsomap</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Isomap is a manifold learning algorithm that uses the Floyd-Warshall algorithm to compute an estimate of the geodesic distance between every pair of points using local neighborhoods, and then uses classic multidimensional scaling to compute a low-dimensional projection.  <a href="class_g_classes_1_1_g_isomap.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_l_l_e.html">GLLE</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Locally Linear Embedding is a manifold learning algorithm that uses sparse matrix techniques to efficiently compute a low-dimensional projection.  <a href="class_g_classes_1_1_g_l_l_e.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_breadth_first_unfolding.html">GBreadthFirstUnfolding</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A manifold learning algorithm that reduces dimensionality in local neighborhoods, and then stitches the reduced local neighborhoods together using the Kabsch algorithm.  <a href="class_g_classes_1_1_g_breadth_first_unfolding.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_neuro_p_c_a.html">GNeuroPCA</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is a generalization of PCA. When the bias is clamped, and the activation function is "identity", it is strictly equivalent to PCA. By default, however, the bias is allowed to drift from the mean, which gives better results. Also, by default, the activation function is "logistic", which enables it to find non-linear components in the data. (<a class="el" href="class_g_classes_1_1_g_unsupervised_back_prop.html" title="A manifold learning algorithm that uses back-propagation to train a neural net model to map from low-...">GUnsupervisedBackProp</a> is a multi-layer generalization of this algorithm.)  <a href="class_g_classes_1_1_g_neuro_p_c_a.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_dynamic_system_state_aligner.html">GDynamicSystemStateAligner</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This uses graph-cut to divide the data into two clusters. It then trains a linear regression model for each cluster to map from inputs to change-in-state. It then aligns the smaller cluster with the larger one such that the linear models are in agreement (as much as possible).  <a href="class_g_classes_1_1_g_dynamic_system_state_aligner.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_image_jitterer.html">GImageJitterer</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an image encoded as a rasterized row of channel values, this class computes a single pixel drawn from the image as if the image had been rotated, translated, and zoomed by a small random amount. (The purpose of this class is to make it possible to train <a class="el" href="class_g_classes_1_1_g_unsupervised_back_prop.html" title="A manifold learning algorithm that uses back-propagation to train a neural net model to map from low-...">GUnsupervisedBackProp</a> to understand these common image-based transformations.)  <a href="class_g_classes_1_1_g_image_jitterer.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_unsupervised_back_prop.html">GUnsupervisedBackProp</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A manifold learning algorithm that uses back-propagation to train a neural net model to map from low-dimensional space to high-dimensional space.  <a href="class_g_classes_1_1_g_unsupervised_back_prop.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_math.html">GMath</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides some useful math functions.  <a href="class_g_classes_1_1_g_math.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_relation.html">GRelation</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds the metadata for a dataset, including which attributes are continuous or nominal, and how many values each nominal attribute supports.  <a href="class_g_classes_1_1_g_relation.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_uniform_relation.html">GUniformRelation</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A relation with a minimal memory footprint that assumes all attributes are continuous, or all of them are nominal and have the same number of possible values.  <a href="class_g_classes_1_1_g_uniform_relation.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_mixed_relation.html">GMixedRelation</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_arff_attribute.html">GArffAttribute</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_arff_relation.html">GArffRelation</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">ARFF = Attribute-Relation File Format. This stores richer information than <a class="el" href="class_g_classes_1_1_g_relation.html" title="Holds the metadata for a dataset, including which attributes are continuous or nominal, and how many values each nominal attribute supports.">GRelation</a>. This includes a name, a name for each attribute, and names for each supported nominal value.  <a href="class_g_classes_1_1_g_arff_relation.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_matrix.html">GMatrix</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a matrix or a database table. Elements can be discrete or continuous. References a <a class="el" href="class_g_classes_1_1_g_relation.html" title="Holds the metadata for a dataset, including which attributes are continuous or nominal, and how many values each nominal attribute supports.">GRelation</a> object, which stores the meta-information about each column.  <a href="class_g_classes_1_1_g_matrix.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_release_data_holder.html">GReleaseDataHolder</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a special holder that guarantees the data set will release all of its data before it is deleted.  <a href="class_g_classes_1_1_g_release_data_holder.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_merge_data_holder.html">GMergeDataHolder</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This class guarantees that the rows in b are merged vertically back into a when this object goes out of scope.  <a href="class_g_classes_1_1_g_merge_data_holder.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_matrix_array.html">GMatrixArray</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents an array of matrices or datasets that all have the same number of columns.  <a href="class_g_classes_1_1_g_matrix_array.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_mixture_of_gaussians.html">GMixtureOfGaussians</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This class uses Expectency Maximization to find the mixture of Gaussians that best approximates the data in a specified real attribute of a data set.  <a href="class_g_classes_1_1_g_mixture_of_gaussians.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_naive_bayes.html">GNaiveBayes</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A naive Bayes classifier.  <a href="class_g_classes_1_1_g_naive_bayes.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_naive_instance.html">GNaiveInstance</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an instance-based learner. Instead of finding the k-nearest neighbors of a feature vector, it finds the k-nearst neighbors in each dimension. That is, it finds n*k neighbors, considering each dimension independently. It then combines the label from all of these neighbors to make a prediction. Finding neighbors in this way makes it more robust to high-dimensional datasets. It tends to perform worse than k-nn in low-dimensional space, and better than k-nn in high-dimensional space. (It may be thought of as a cross between a k-nn instance learner and a Naive Bayes learner. It only supports continuous features and labels (so it is common to wrap it in a Categorize filter which will convert nominal features to a categorical distribution of continuous values).  <a href="class_g_classes_1_1_g_naive_instance.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_neighbor_finder.html">GNeighborFinder</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the k-nearest neighbors of any vector in a dataset.  <a href="class_g_classes_1_1_g_neighbor_finder.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_neighbor_finder_cache_wrapper.html">GNeighborFinderCacheWrapper</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This wraps a neighbor finding algorithm. It caches the queries for neighbors for the purpose of improving runtime performance.  <a href="class_g_classes_1_1_g_neighbor_finder_cache_wrapper.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_neighbor_finder_generalizing.html">GNeighborFinderGeneralizing</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the k-nearest neighbors (in a dataset) of an arbitrary vector (which may or may not be in the dataset).  <a href="class_g_classes_1_1_g_neighbor_finder_generalizing.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_brute_force_neighbor_finder.html">GBruteForceNeighborFinder</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds neighbors by measuring the distance to all points. This one should work properly even if the distance metric does not support the triangle inequality.  <a href="class_g_classes_1_1_g_brute_force_neighbor_finder.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_kd_tree.html">GKdTree</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">An efficient algorithm for finding neighbors.  <a href="class_g_classes_1_1_g_kd_tree.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_shortcut_pruner.html">GShortcutPruner</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This finds the shortcuts in a table of neighbors and replaces them with INVALID_INDEX.  <a href="class_g_classes_1_1_g_shortcut_pruner.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_cycle_cut.html">GCycleCut</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This finds the shortcuts in a table of neighbors and replaces them with INVALID_INDEX.  <a href="class_g_classes_1_1_g_cycle_cut.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_saffron.html">GSaffron</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implementes the SAFFRON intelligent neighbor-finding algorithm published in Gashler, Michael S. and Martinez, Tony. Tangent space guided intelligent neighbor finding. In Proceedings of the IEEE International Joint Conference on Neural Networks IJCNN’11, pages 2617–2624, IEEE Press, 2011. This class intelligently selects neighbors for each point in a dataset, such that the neighbors define a good neighborhood for manifold learning. A relaxation technique is used to ensure that neighbors lie on a consistent tangent-space while remaining close to the point. This makes manifold learning possible with difficult (somtimes even self-intersecting) manifolds.  <a href="class_g_classes_1_1_g_saffron.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_temporal_neighbor_finder.html">GTemporalNeighborFinder</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A neighbor finder that specializes in dynamical systems. It determines neighbors by searching for the shortest path of actions between observations, and computes the distance as the number of time-steps in that path. This algorithm was published in Gashler, Michael S. and Martinez, Tony. Temporal nonlinear dimensionality reduction. In Proceedings of the International Joint Conference on Neural Networks IJCNN’11, pages 1959–1966, IEEE Press, 2011.  <a href="class_g_classes_1_1_g_temporal_neighbor_finder.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_sequence_neighbor_finder.html">GSequenceNeighborFinder</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple neighbor-finder that reports the nearest neighbors in the sequence. (That is, the previous and next rows are the closest neighbors.) The distance is sequential distance to the neighbor (not squared).  <a href="class_g_classes_1_1_g_sequence_neighbor_finder.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_neuron.html">GNeuron</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a single neuron in a neural network.  <a href="class_g_classes_1_1_g_neuron.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_neural_net_layer.html">GNeuralNetLayer</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a layer of neurons in a neural network.  <a href="class_g_classes_1_1_g_neural_net_layer.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_back_prop_weight.html">GBackPropWeight</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">An internal class used by <a class="el" href="class_g_classes_1_1_g_back_prop.html" title="This class performs backpropagation on a neural network. (I made it a separate class because it is on...">GBackProp</a>.  <a href="class_g_classes_1_1_g_back_prop_weight.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_back_prop_neuron.html">GBackPropNeuron</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">An internal class used by <a class="el" href="class_g_classes_1_1_g_back_prop.html" title="This class performs backpropagation on a neural network. (I made it a separate class because it is on...">GBackProp</a>.  <a href="class_g_classes_1_1_g_back_prop_neuron.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_back_prop_layer.html">GBackPropLayer</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">An internal class used by <a class="el" href="class_g_classes_1_1_g_back_prop.html" title="This class performs backpropagation on a neural network. (I made it a separate class because it is on...">GBackProp</a>.  <a href="class_g_classes_1_1_g_back_prop_layer.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_back_prop.html">GBackProp</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This class performs backpropagation on a neural network. (I made it a separate class because it is only needed during training. There is no reason to waste this space after training is complete, or if you choose to use a different technique to train the neural network.)  <a href="class_g_classes_1_1_g_back_prop.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_neural_net.html">GNeuralNet</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">An artificial neural network.  <a href="class_g_classes_1_1_g_neural_net.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_neural_net_inverse_layer.html">GNeuralNetInverseLayer</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A helper class used by <a class="el" href="class_g_classes_1_1_g_neural_net_pseudo_inverse.html" title="Computes the pseudo-inverse of a neural network.">GNeuralNetPseudoInverse</a>.  <a href="class_g_classes_1_1_g_neural_net_inverse_layer.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_neural_net_pseudo_inverse.html">GNeuralNetPseudoInverse</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the pseudo-inverse of a neural network.  <a href="class_g_classes_1_1_g_neural_net_pseudo_inverse.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_target_function.html">GTargetFunction</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The optimizer seeks to find values that minimize this target function.  <a href="class_g_classes_1_1_g_target_function.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_optimizer.html">GOptimizer</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the base class of all search algorithms that can jump to any vector in the search space seek the vector that minimizes error.  <a href="class_g_classes_1_1_g_optimizer.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_parallel_optimizers.html">GParallelOptimizers</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This class simplifies simultaneously solving several optimization problems.  <a href="class_g_classes_1_1_g_parallel_optimizers.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_action_path_state.html">GActionPathState</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_action_path.html">GActionPath</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_action_path_search.html">GActionPathSearch</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the base class of search algorithms that can only perform a discreet set of actions (as opposed to jumping to anywhere in the search space), and seeks to minimize the error of a path of actions.  <a href="class_g_classes_1_1_g_action_path_search.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_particle_swarm.html">GParticleSwarm</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">An optimization algorithm inspired by flocking birds.  <a href="class_g_classes_1_1_g_particle_swarm.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_rubber_ball_swarm.html">GRubberBallSwarm</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an algorithm for finding good starting points within a constrained optimization problem. It works by simulating "rubber balls" which bounce around inside the constrained region. After many iterations, they tend to be spread somewhat uniformly, even with very complex constrained shapes. The balls learn to approximate the shape of the shell, so if the room is wider than it is tall, the balls will learn to bounce sideways more often than vertically.  <a href="class_g_classes_1_1_g_rubber_ball_swarm.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_plot_label_spacer.html">GPlotLabelSpacer</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">If you need to place grid lines or labels at regular intervals (like 1000, 2000, 3000, 4000... or 20, 25, 30, 35... or 0, 2, 4, 6, 8, 10...) this class will help you pick where to place the labels so that there are a reasonable number of them, and they all land on nice label values.  <a href="class_g_classes_1_1_g_plot_label_spacer.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_plot_label_spacer_logarithmic.html">GPlotLabelSpacerLogarithmic</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to <a class="el" href="class_g_classes_1_1_g_plot_label_spacer.html" title="If you need to place grid lines or labels at regular intervals (like 1000, 2000, 3000, 4000... or 20, 25, 30, 35... or 0, 2, 4, 6, 8, 10...) this class will help you pick where to place the labels so that there are a reasonable number of them, and they all land on nice label values.">GPlotLabelSpacer</a>, except for logarithmic grids. To plot in logarithmic space, set your plot window to have a range from log_e(min) to log_e(max). When you actually plot things, plot them at log_e(x), where x is the position of the thing you want to plot.  <a href="class_g_classes_1_1_g_plot_label_spacer_logarithmic.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_plot_window.html">GPlotWindow</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This class makes it easy to plot points and functions on 2D cartesian coordinates.  <a href="class_g_classes_1_1_g_plot_window.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_agent_action_iterator.html">GAgentActionIterator</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterates through all the actions that are valid in the current state. If actions are continuous or very numerous, this should sample valid actions in a random order. The caller may decide that it has sampled enough at any time.  <a href="class_g_classes_1_1_g_agent_action_iterator.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_discrete_action_iterator.html">GDiscreteActionIterator</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a simple and common action iterator that can be used when there is a discrete set of possible actions.  <a href="class_g_classes_1_1_g_discrete_action_iterator.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_policy_learner.html">GPolicyLearner</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the base class for algorithms that learn a policy.  <a href="class_g_classes_1_1_g_policy_learner.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_peach_agent.html">GPeachAgent</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an experimental policy-learning algorithm. It's currently too slow to be practical.  <a href="class_g_classes_1_1_g_peach_agent.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_polynomial.html">GPolynomial</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This regresses a multi-dimensional polynomial to fit the data.  <a href="class_g_classes_1_1_g_polynomial.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_priority_queue_entry.html">GPriorityQueueEntry</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">An internal class used by <a class="el" href="class_g_classes_1_1_g_priority_queue.html" title="An implementation of a double-ended heap-based priority queue. (Note that the multimap STL class can ...">GPriorityQueue</a>. You should not use this class directly.  <a href="class_g_classes_1_1_g_priority_queue_entry.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_priority_queue.html">GPriorityQueue</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">An implementation of a double-ended heap-based priority queue. (Note that the multimap STL class can also be used to implement a double-ended priority queue, but the STL does not currently provide a heap-based double-ended priority queue, which is asymptotically more efficient for insertions.)  <a href="class_g_classes_1_1_g_priority_queue.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_rand.html">GRand</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a 64-bit pseudo-random number generator.  <a href="class_g_classes_1_1_g_rand.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_ray_trace_color.html">GRayTraceColor</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents a color. It's more precise than GColor, but takes up more memory. Note that the ray tracer ignores the alpha channel because the material specifies a unique transmission color.  <a href="class_g_classes_1_1_g_ray_trace_color.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_ray_trace_camera.html">GRayTraceCamera</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the camera for a ray tracing scene.  <a href="class_g_classes_1_1_g_ray_trace_camera.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_ray_trace_scene.html">GRayTraceScene</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a scene that you can ray-trace.  <a href="class_g_classes_1_1_g_ray_trace_scene.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_ray_trace_light.html">GRayTraceLight</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a source of light in a ray-tracing scene.  <a href="class_g_classes_1_1_g_ray_trace_light.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_ray_trace_directional_light.html">GRayTraceDirectionalLight</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents directional light in a ray-tracing scene.  <a href="class_g_classes_1_1_g_ray_trace_directional_light.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_ray_trace_point_light.html">GRayTracePointLight</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a point light in a ray-tracing scene.  <a href="class_g_classes_1_1_g_ray_trace_point_light.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_ray_trace_area_light.html">GRayTraceAreaLight</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a light source with area.  <a href="class_g_classes_1_1_g_ray_trace_area_light.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_ray_trace_material.html">GRayTraceMaterial</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_ray_trace_physical_material.html">GRayTracePhysicalMaterial</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the material of which an object is made in a ray-tracing scene.  <a href="class_g_classes_1_1_g_ray_trace_physical_material.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_ray_trace_image_texture.html">GRayTraceImageTexture</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_ray_trace_bounding_box_base.html">GRayTraceBoundingBoxBase</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A class used for making ray-tracing faster.  <a href="class_g_classes_1_1_g_ray_trace_bounding_box_base.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_ray_trace_bounding_box_interior.html">GRayTraceBoundingBoxInterior</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A class used for making ray-tracing faster.  <a href="class_g_classes_1_1_g_ray_trace_bounding_box_interior.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_ray_trace_bounding_box_leaf.html">GRayTraceBoundingBoxLeaf</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A class used for making ray-tracing faster.  <a href="class_g_classes_1_1_g_ray_trace_bounding_box_leaf.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_ray_trace_tri_mesh.html">GRayTraceTriMesh</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a triangle mesh in a ray-tracing scene.  <a href="class_g_classes_1_1_g_ray_trace_tri_mesh.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_ray_trace_object.html">GRayTraceObject</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">An object in a ray-tracing scene.  <a href="class_g_classes_1_1_g_ray_trace_object.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_ray_trace_sphere.html">GRayTraceSphere</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A sphere in a ray-tracing scene.  <a href="class_g_classes_1_1_g_ray_trace_sphere.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_ray_trace_triangle.html">GRayTraceTriangle</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A single triangle in a ray-tracing scene.  <a href="class_g_classes_1_1_g_ray_trace_triangle.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_tri_mesh_builder.html">GTriMeshBuilder</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g3d_letter_maker.html">G3dLetterMaker</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_collaborative_filter.html">GCollaborativeFilter</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The base class for collaborative filtering recommender systems.  <a href="class_g_classes_1_1_g_collaborative_filter.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_baseline_recommender.html">GBaselineRecommender</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This class always predicts the average rating for each item, no matter to whom it is making the recommendation. The purpose of this algorithm is to serve as a baseline for comparison.  <a href="class_g_classes_1_1_g_baseline_recommender.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_instance_recommender.html">GInstanceRecommender</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This class makes recommendations by finding the nearest-neighbors (as determined by evaluating only overlapping ratings), and assuming that the ratings of these neighbors will be predictive of your ratings.  <a href="class_g_classes_1_1_g_instance_recommender.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_sparse_cluster_recommender.html">GSparseClusterRecommender</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This class clusters the rows according to a sparse similarity metric, then uses the baseline vector in each cluster to make predictions.  <a href="class_g_classes_1_1_g_sparse_cluster_recommender.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_dense_cluster_recommender.html">GDenseClusterRecommender</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This class clusters the rows according to a dense distance metric, then uses the baseline vector in each cluster to make predictions.  <a href="class_g_classes_1_1_g_dense_cluster_recommender.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_matrix_factorization.html">GMatrixFactorization</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This factors the sparse matrix of ratings, M, such that M = PQ^T where each row in P gives the principal preferences for the corresponding user, and each row in Q gives the linear combination of those preferences that map to a rating for an item. (Actually, P and Q also contain an extra column added for a bias.) This class is implemented according to the specification on page 631 in Takacs, G., Pilaszy, I., Nemeth, B., and Tikk, D. Scalable collaborative filtering approaches for large recommender systems. The Journal of Machine Learning Research, 10:623–656, 2009. ISSN 1532-4435., except with the addition of learning-rate decay and a different stopping criteria.  <a href="class_g_classes_1_1_g_matrix_factorization.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_nonlinear_p_c_a.html">GNonlinearPCA</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This class trains a neural network to fit to the ratings. Although the name implies that it is an extension of PCA, I think it is better described as a non-linear generalization of matrix factorization. This algorithm was published in Scholz, M. Kaplan, F. Guy, C. L. Kopka, J. Selbig, J., Non-linear PCA: a missing data approach, In Bioinformatics, Vol. 21, Number 20, pp. 3887-3895, Oxford University Press, 2005.  <a href="class_g_classes_1_1_g_nonlinear_p_c_a.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_bag_of_recommenders.html">GBagOfRecommenders</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This class performs bootstrap aggregation with collaborative filtering algorithms.  <a href="class_g_classes_1_1_g_bag_of_recommenders.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_rect.html">GRect</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a rectangular region with integers.  <a href="class_g_classes_1_1_g_rect.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_float_rect.html">GFloatRect</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a rectangular region with floats.  <a href="class_g_classes_1_1_g_float_rect.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_double_rect.html">GDoubleRect</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a rectangular region with doubles.  <a href="class_g_classes_1_1_g_double_rect.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_region_ajacency_graph.html">GRegionAjacencyGraph</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The base class for region ajacency graphs. These are useful for breaking down an image into patches of similar color.  <a href="class_g_classes_1_1_g_region_ajacency_graph.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g2_d_region_graph.html">G2DRegionGraph</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements a region adjacency graph for 2D images, and lets you merge similar regions to create a hierarchical breakdown of the image.  <a href="class_g_classes_1_1_g2_d_region_graph.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_region_border_iterator.html">GRegionBorderIterator</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterates the border of a 2D region by running around the border and reporting the coordinates of each interior border pixel and the direction to the edge. It goes in a counter-clockwise direction.  <a href="class_g_classes_1_1_g_region_border_iterator.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_region_area_iterator.html">GRegionAreaIterator</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterates over all the pixels in an image that have the same color and are transitively adjacent. In other words, if you were to flood-fill a the specified point, this returns all the pixels that would be changed.  <a href="class_g_classes_1_1_g_region_area_iterator.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_sub_image_finder.html">GSubImageFinder</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This class uses Fourier phase correlation to efficiently find sub-images within a larger image.  <a href="class_g_classes_1_1_g_sub_image_finder.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_sub_image_finder2.html">GSubImageFinder2</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This class uses heuristics to find sub-images within a larger image. It is slower, but more stable than <a class="el" href="class_g_classes_1_1_g_sub_image_finder.html" title="This class uses Fourier phase correlation to efficiently find sub-images within a larger image...">GSubImageFinder</a>.  <a href="class_g_classes_1_1_g_sub_image_finder2.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_q_learner.html">GQLearner</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The base class of a Q-Learner. To use this class, there are four abstract methods you'll need to implement. See also the comment for <a class="el" href="class_g_classes_1_1_g_policy_learner.html" title="This is the base class for algorithms that learn a policy.">GPolicyLearner</a>.  <a href="class_g_classes_1_1_g_q_learner.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_incremental_learner_q_agent.html">GIncrementalLearnerQAgent</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an implementation of <a class="el" href="class_g_classes_1_1_g_q_learner.html" title="The base class of a Q-Learner. To use this class, there are four abstract methods you&#39;ll need to ...">GQLearner</a> that uses an incremental learner for its Q-table and a SoftMax (usually pick the best action, but sometimes randomly pick the action) strategy to balance between exploration vs exploitation. To use this class, you need to supply an incremental learner (see the comment for the constructor for more details) and to implement the GetRewardForLastAction method.  <a href="class_g_classes_1_1_g_incremental_learner_q_agent.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_g_classes_1_1_g_bit_reverser__imp.html">GBitReverser_imp</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Template used for reversing numBits of type T. You shouldn't need this, use the function reverseBits.  <a href="struct_g_classes_1_1_g_bit_reverser__imp.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_g_classes_1_1_g_bit_reverser__imp_3_01_t_00_011_01_4.html">GBitReverser_imp&lt; T, 1 &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Base case of template used for reversing numBits of type T. You shouldn't need this, use the function reverseBits.  <a href="struct_g_classes_1_1_g_bit_reverser__imp_3_01_t_00_011_01_4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_s_d_l.html">GSDL</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A collection of routines that are useful when interfacing with SDL.  <a href="class_g_classes_1_1_g_s_d_l.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_self_organizing_map.html">GSelfOrganizingMap</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">An implementation of a Kohonen self-organizing map.  <a href="class_g_classes_1_1_g_self_organizing_map.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_smtp.html">GSmtp</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">For sending email to an SMTP server.  <a href="class_g_classes_1_1_g_smtp.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_t_c_p_client.html">GTCPClient</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is an abstraction of a TCP client socket connection.  <a href="class_g_classes_1_1_g_t_c_p_client.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_t_c_p_connection.html">GTCPConnection</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is used by <a class="el" href="class_g_classes_1_1_g_t_c_p_server.html" title="This class is an abstraction of a TCP server, which maintains a set of socket connections.">GTCPServer</a> to represent a connection with one of the clients. (If you want to associate some additional objects with each connection, you can inherrit from this class, and overload <a class="el" href="class_g_classes_1_1_g_t_c_p_server.html#a1c6d88f34f86b916ff15e801012acfa4" title="This is called just before a new connection is accepted. It returns a pointer to a new GTCPConnection...">GTCPServer::makeConnection</a> to return your own custom object.)  <a href="class_g_classes_1_1_g_t_c_p_connection.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_t_c_p_server.html">GTCPServer</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is an abstraction of a TCP server, which maintains a set of socket connections.  <a href="class_g_classes_1_1_g_t_c_p_server.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_package_client.html">GPackageClient</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This class abstracts a client that speaks a home-made protocol that guarantees packages will arrive in the same order and size as when they were sent. This protocol is a simple layer on top of TCP.  <a href="class_g_classes_1_1_g_package_client.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_package_server.html">GPackageServer</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This class abstracts a server that speaks a home-made protocol that guarantees packages will arrive in the same order and size as when they were sent. This protocol is a simple layer on top of TCP.  <a href="class_g_classes_1_1_g_package_server.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_sparse_matrix.html">GSparseMatrix</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This class stores a row-compressed sparse matrix. That is, each row consists of a map from a column-index to a value.  <a href="class_g_classes_1_1_g_sparse_matrix.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_spin_lock.html">GSpinLock</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A spin-lock for synchronization purposes.  <a href="class_g_classes_1_1_g_spin_lock.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_spin_lock_holder.html">GSpinLockHolder</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_brute_force_search.html">GBruteForceSearch</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This performs a brute force search with uniform sampling over the unit hypercube with increasing granularity. (Your target function should scale the candidate vectors as necessary to cover the desired space.)  <a href="class_g_classes_1_1_g_brute_force_search.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_random_search.html">GRandomSearch</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">At each iteration, this tries a random vector from the unit hypercube. (Your target function should scale the candidate vectors as necessary to cover the desired space.)  <a href="class_g_classes_1_1_g_random_search.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_probe_search.html">GProbeSearch</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This is somewhat of a multi-dimensional version of binary-search. It greedily probes the best choices first, but then starts trying the opposite choices at the higher divisions so that it can also handle non-monotonic target functions. Each iteration performs a binary (divide-and-conquer) search within the unit hypercube. (Your target function should scale the candidate vectors as necessary to cover the desired space.) Because the high-level divisions are typically less correlated with the quality of the final result than the low-level divisions, it searches through the space of possible "probes" by toggling choices in the order from high level to low level. In low-dimensional space, this algorithm tends to quickly find good solutions, especially if the target function is somewhat smooth. In high-dimensional space, the number of iterations to find a good solution seems to grow exponentially.  <a href="class_g_classes_1_1_g_probe_search.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_stemmer.html">GStemmer</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This class just wraps the Porter Stemmer. It finds the stems of words. Examples: "cats"-&gt;"cat" "dogs"-&gt;"dog" "fries"-&gt;"fri" "fishes"-&gt;"fish" "pies"-&gt;"pi" "lovingly"-&gt;"lovingli" "candy"-&gt;"candi" "babies"-&gt;"babi" "bus"-&gt;"bu" "busses"-&gt;"buss" "women"-&gt;"women" "hasty"-&gt;"hasti" "hastily"-&gt;"hastili" "fly"-&gt;"fly" "kisses"-&gt;"kiss" "goes"-&gt;"goe" "brought"-&gt;"brought" As you can see the stems aren't always real words, but that's okay as long as it produces the same stem for words that have the same etymological roots. Even then it still isn't perfect (notice it got "bus" wrong), but it should still improve analysis somewhat in many cases.  <a href="class_g_classes_1_1_g_stemmer.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_string_chopper.html">GStringChopper</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This class chops a big string at word breaks so you can display it intelligently on multiple lines.  <a href="class_g_classes_1_1_g_string_chopper.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_system_learner.html">GSystemLearner</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the base class for algorithms that learn to model dynamical systems.  <a href="class_g_classes_1_1_g_system_learner.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_recurrent_model.html">GRecurrentModel</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This class can be used to implement recurrent neural networks, or recurrent forms of other supervised models.  <a href="class_g_classes_1_1_g_recurrent_model.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_word_iterator.html">GWordIterator</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This iterates over the words in a block of text.  <a href="class_g_classes_1_1_g_word_iterator.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_word_stats.html">GWordStats</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores statistics about each word in a <a class="el" href="class_g_classes_1_1_g_vocabulary.html" title="This is a helper class which is useful for text-mining. It collects words, stems them, filters them through a list of stop-words, and assigns a discrete number to each word.">GVocabulary</a>.  <a href="class_g_classes_1_1_g_word_stats.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_vocabulary.html">GVocabulary</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a helper class which is useful for text-mining. It collects words, stems them, filters them through a list of stop-words, and assigns a discrete number to each word.  <a href="class_g_classes_1_1_g_vocabulary.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_thread.html">GThread</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper for PThreads on Linux and for some corresponding WIN32 api on Windows.  <a href="class_g_classes_1_1_g_thread.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_time.html">GTime</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides some time-related functions.  <a href="class_g_classes_1_1_g_time.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_tokenizer_map_comparer.html">GTokenizerMapComparer</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a helper-class used by <a class="el" href="class_g_classes_1_1_g_tokenizer.html" title="This is a simple tokenizer that reads a file, one token at-a-time.">GTokenizer</a>.  <a href="class_g_classes_1_1_g_tokenizer_map_comparer.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_char_set.html">GCharSet</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a helper-class used by <a class="el" href="class_g_classes_1_1_g_tokenizer.html" title="This is a simple tokenizer that reads a file, one token at-a-time.">GTokenizer</a>. Use <a class="el" href="class_g_classes_1_1_g_tokenizer.html#a35d6ac294de56c643e50e0db39d946d4" title="Returns a GCharSet. Many of the methods in this class require a GCharSet as a parameter. You get it by calling this method. szChars is an un-ordered set of characters (with no separator between them). The only special character is &#39;-&#39;, which is used to indicate a range of characters if it is not the first character in the string. (So, if you want &#39;-&#39; in your set of characters, it should come first.) For example, the following string includes all letters: &quot;a-zA-Z&quot;, and the following string includes all characters that might appear in a floating-point number: &quot;-.,0-9e&quot;. (There is no way to include &#39;\0&#39; as a character in the set, since that character indicates the end of the string, but that is okay since &#39;\0&#39; should not occur in text files anyway, and this class is designed for parsing text files.)">GTokenizer::charSet</a> to create.  <a href="class_g_classes_1_1_g_char_set.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_tokenizer.html">GTokenizer</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a simple tokenizer that reads a file, one token at-a-time.  <a href="class_g_classes_1_1_g_tokenizer.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_transform.html">GTransform</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the base class of algorithms that transform data without supervision.  <a href="class_g_classes_1_1_g_transform.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_incremental_transform.html">GIncrementalTransform</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the base class of algorithms that can transform data one row at a time without supervision.  <a href="class_g_classes_1_1_g_incremental_transform.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_two_way_incremental_transform.html">GTwoWayIncrementalTransform</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the base class of algorithms that can transform data one row at a time without supervision, and can (un)transform a row back to its original form if necessary.  <a href="class_g_classes_1_1_g_two_way_incremental_transform.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_two_way_transform_chainer.html">GTwoWayTransformChainer</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This wraps two two-way-incremental-transoforms to form a single combination transform.  <a href="class_g_classes_1_1_g_two_way_transform_chainer.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_p_c_a.html">GPCA</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Principal Component Analysis. (Computes the principal components about the mean of the data when you call train. The transformed (reduced-dimensional) data will have a mean about the origin.)  <a href="class_g_classes_1_1_g_p_c_a.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_p_c_a_rotate_only.html">GPCARotateOnly</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Principle Component Analysis without the projection. It only rotates axes to align with the first few principal components.  <a href="class_g_classes_1_1_g_p_c_a_rotate_only.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_noise_generator.html">GNoiseGenerator</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Just generates Gaussian noise.  <a href="class_g_classes_1_1_g_noise_generator.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_pair_product.html">GPairProduct</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates data by computing the product of each pair of attributes. This is useful for augmenting data.  <a href="class_g_classes_1_1_g_pair_product.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_attribute_selector.html">GAttributeSelector</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates subsets of data that contain only the most relevant features for predicting the labels. The train method of this class produces a ranked ordering of the feature attributes by training a single-layer neural network, and deselecting the weakest attribute until all attributes have been deselected. The transform method uses only the highest-ranked attributes.  <a href="class_g_classes_1_1_g_attribute_selector.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_nominal_to_cat.html">GNominalToCat</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This is sort-of the opposite of discretize. It converts each nominal attribute to a categorical distribution by representing each value using the corresponding row of the identity matrix. For example, if a certain nominal attribute has 4 possible values, then a value of 3 would be encoded as the vector 0 0 1 0. When predictions are converted back to nominal values, the mode of the categorical distribution is used as the predicted value. (This is similar to Weka's NominalToBinaryFilter.)  <a href="class_g_classes_1_1_g_nominal_to_cat.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_normalize.html">GNormalize</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This transform scales and shifts continuous values to make them fall within a specified range.  <a href="class_g_classes_1_1_g_normalize.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_discretize.html">GDiscretize</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This transform uses buckets to convert continuous data into discrete data. It is common to use GFilter to combine this with your favorite modeler (which only supports discrete values) to create a modeler that can also support continuous values as well.  <a href="class_g_classes_1_1_g_discretize.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_impute_missing_vals.html">GImputeMissingVals</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_vec.html">GVec</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains some useful functions for operating on vectors.  <a href="class_g_classes_1_1_g_vec.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_vec_buf.html">GVecBuf</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds an array of doubles that can be resized. This class is slightly lighter-weight than the C++ vector class, and it allows access to the buffer in the form of an array of doubles. Basically, it is useful when working with C-style functions that expect parameters in the form of an array of doubles, rather than as a vector of doubles.  <a href="class_g_classes_1_1_g_vec_buf.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_index_vec.html">GIndexVec</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Useful functions for operating on vectors of indexes.  <a href="class_g_classes_1_1_g_index_vec.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_coord_vector_iterator.html">GCoordVectorIterator</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">An iterator for an n-dimensional coordinate vector. For example, suppose you have a 4-dimensional 2x3x2x1 grid, and you want to iterate through its coordinates: (0000, 0010, 0100, 0110, 0200, 0210, 1000, 1010, 1100, 1110, 1200, 1210). This class will iterate over coordinate vectors in this manner. (For 0-dimensional coordinate vectors, it behaves as though the origin is the only valid coordinate.)  <a href="class_g_classes_1_1_g_coord_vector_iterator.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_wave.html">GWave</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Currently only supports PCM wave format.  <a href="class_g_classes_1_1_g_wave.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_wave_iterator.html">GWaveIterator</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This class iterates over the samples in a WAVE file. Regardless of the bits-per-sample, this iterator will convert all samples to doubles with a range from -1 to 1.  <a href="class_g_classes_1_1_g_wave_iterator.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_fourier_wave_processor.html">GFourierWaveProcessor</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an abstract class that processes a wave file in blocks. Specifically, it divides the wave file up into overlapping blocks, converts them into Fourier space, calls the abstract "process" method with each block, converts back from Fourier space, and then interpolates to create the wave output.  <a href="class_g_classes_1_1_g_fourier_wave_processor.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_widget_common.html">GWidgetCommon</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_widget.html">GWidget</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The base class of all GUI widgets.  <a href="class_g_classes_1_1_g_widget.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_widget_atomic.html">GWidgetAtomic</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The base class of all atomic widgets (widgets that are not composed of other widgets).  <a href="class_g_classes_1_1_g_widget_atomic.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_widget_group.html">GWidgetGroup</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The base class of all widgets that are composed of other widgets.  <a href="class_g_classes_1_1_g_widget_group.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_widget_dialog.html">GWidgetDialog</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A form or dialog.  <a href="class_g_classes_1_1_g_widget_dialog.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_widget_text_button.html">GWidgetTextButton</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A button with text on it.  <a href="class_g_classes_1_1_g_widget_text_button.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_widget_text_tab.html">GWidgetTextTab</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a tab (like for tabbed menus, etc.)  <a href="class_g_classes_1_1_g_widget_text_tab.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_widget_image_button.html">GWidgetImageButton</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A button with an image on it. The left half of the image is the unpressed image and the right half is the pressed image.  <a href="class_g_classes_1_1_g_widget_image_button.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_widget_animation.html">GWidgetAnimation</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">An image with multiple frames.  <a href="class_g_classes_1_1_g_widget_animation.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_widget_text_label.html">GWidgetTextLabel</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A text label.  <a href="class_g_classes_1_1_g_widget_text_label.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_widget_image_label.html">GWidgetImageLabel</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_widget_group_box.html">GWidgetGroupBox</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This just draws a rectangular box.  <a href="class_g_classes_1_1_g_widget_group_box.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_widget_v_c_r_button.html">GWidgetVCRButton</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A button with a common icon on it.  <a href="class_g_classes_1_1_g_widget_v_c_r_button.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_widget_progress_bar.html">GWidgetProgressBar</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Automatically determines wether to be horizontal or vertical based on dimensions. Progress ranges from 0 to 1, or from 0 to -1 if you want it to go the other way.  <a href="class_g_classes_1_1_g_widget_progress_bar.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_widget_check_box.html">GWidgetCheckBox</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_widget_bullet_hole.html">GWidgetBulletHole</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The easiest way to do bullets is to use the <a class="el" href="class_g_classes_1_1_g_widget_bullet_group.html" title="This creates a whole group of bullets arranged either horizontally or vertically at regular intervals...">GWidgetBulletGroup</a> class, but if you really want to manage individual bullets yourself, you can use this class to do it.  <a href="class_g_classes_1_1_g_widget_bullet_hole.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_widget_bullet_group.html">GWidgetBulletGroup</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This creates a whole group of bullets arranged either horizontally or vertically at regular intervals.  <a href="class_g_classes_1_1_g_widget_bullet_group.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_widget_slider_tab.html">GWidgetSliderTab</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This widget is not meant to be used by itself. It creates one of the parts of a scroll bar or slider bar.  <a href="class_g_classes_1_1_g_widget_slider_tab.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_widget_horiz_scroll_bar.html">GWidgetHorizScrollBar</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a horizontal scroll bar.  <a href="class_g_classes_1_1_g_widget_horiz_scroll_bar.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_widget_vert_scroll_bar.html">GWidgetVertScrollBar</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a vertical scroll bar.  <a href="class_g_classes_1_1_g_widget_vert_scroll_bar.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_widget_text_box.html">GWidgetTextBox</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a box in which the user can enter text.  <a href="class_g_classes_1_1_g_widget_text_box.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_widget_grid.html">GWidgetGrid</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_widget_file_system_browser.html">GWidgetFileSystemBrowser</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_widget_horiz_slider.html">GWidgetHorizSlider</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_widget_vert_slider.html">GWidgetVertSlider</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_widget_canvas.html">GWidgetCanvas</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A painting canvas.  <a href="class_g_classes_1_1_g_widget_canvas.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_widget_wave.html">GWidgetWave</a></td></tr>
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_g_classes.html#a05e6635da5dd8c2ed9fbca0de1888922">DaemonMainFunc</a> )(void *pArg)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_g_classes.html#a6b3b9015fd3581c392397706fb6a00a3">sighandler_t</a> )(int)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_g_classes.html#a77ee1c95df9d35f82fb68af33a145a3e">EnsembleProgressCallback</a> )(void *pThis, size_t i, size_t n)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_g_classes.html#af7fa238518e08efc8a977ddf1b35fd59">RepValidateCallback</a> )(void *pThis, size_t nRep, size_t nFold, size_t labelDims, double *pFoldResults)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef double(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_g_classes.html#ae2576f1cef5c00b03a80fb750ce2f8ae">MathFunc</a> )(void *pThis, double x)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="class_g_classes_1_1smart__ptr.html">smart_ptr</a>&lt; <a class="el" href="class_g_classes_1_1_g_relation.html">GRelation</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_g_classes.html#a167d05d64ce9a5f21994c18f1834e820">sp_relation</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_g_classes.html#a70c393a5da93ac55bc41134644697609">PointerComparer</a> )(void *pThis, void *pA, void *pB)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef unsigned long long int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_g_classes.html#a17e0716ae01035a6bf7aae9f9bbb8941">uint64</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef unsigned long int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_g_classes.html#a48f05d8e0221375ae6364f6d1a232483">THREAD_HANDLE</a></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_g_classes.html#a85499c08be1fc47b8cc1bd0cac041f0f">GAssertFailed</a> ()</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_g_classes.html#a597f1897f173e6df4569efc03a7ec3c4">to_str</a> (const T &amp;n)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_g_classes.html#aabea6f5d6ea3fac5357ddce762ad7efa">ThrowError</a> (std::string s1)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_g_classes.html#a383091cc75d4ddabd02bec668fc599ff">ThrowError</a> (std::string s1, std::string s2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_g_classes.html#a9e9db4fbb7904149a64abbc9fbacd47a">ThrowError</a> (std::string s1, std::string s2, std::string s3)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_g_classes.html#ae16fa1ce1df6010b61659cf9dc29e46f">ThrowError</a> (std::string s1, std::string s2, std::string s3, std::string s4)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_g_classes.html#a70dbbb956610c72344c05daf254a6681">ThrowError</a> (std::string s1, std::string s2, std::string s3, std::string s4, std::string s5)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_g_classes.html#abe21ad856d6c20a3bd98ea3e39e041d6">ThrowError</a> (std::string s1, std::string s2, std::string s3, std::string s4, std::string s5, std::string s6)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_g_classes.html#ac6d6e1509ef5c53335f42576a01c3a21">ThrowError</a> (std::string s1, std::string s2, std::string s3, std::string s4, std::string s5, std::string s6, std::string s7)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_g_classes.html#acd22e117e9b320c96bbd84ebe0185656">ThrowError</a> (std::string s1, std::string s2, std::string s3, std::string s4, std::string s5, std::string s6, std::string s7, std::string s8)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_g_classes.html#a245d51ad6c81e9eb4bfdfa0c4ab0f54c">ThrowError</a> (std::string s1, std::string s2, std::string s3, std::string s4, std::string s5, std::string s6, std::string s7, std::string s8, std::string s9)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_g_classes.html#aba4cb918ec65e021a90fcada14198626">ThrowError</a> (std::string s1, std::string s2, std::string s3, std::string s4, std::string s5, std::string s6, std::string s7, std::string s8, std::string s9, std::string s10)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_g_classes.html#ac299b5ca10e5219ab689162505bb2f45">_stricmp</a> (const char *szA, const char *szB)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_g_classes.html#af3f892c5e72c1d1c4f8e3c9888c4d68a">_strnicmp</a> (const char *szA, const char *szB, int len)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_g_classes.html#abf2d5c0e6bc3b0cb734034337f89241e">filelength</a> (int filedes)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_g_classes.html#aa91ed8e052b67d6f6b5f51e8b5af0b65">TestEqual</a> (const T1 &amp;expected, const T2 &amp;got, std::string test_descr)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Verify that <em>expected</em> and <em>got</em> are equal for test code. Unlike Assert, this check does not disappear in optimized builds.  <a href="#aa91ed8e052b67d6f6b5f51e8b5af0b65"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_g_classes.html#a46f3373726a90e727c435534d1bf2140">TestEqual</a> (char const *expected, char const *got, std::string desc)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">"Specialization" of TestEqual for c-strings done using overloading  <a href="#a46f3373726a90e727c435534d1bf2140"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_g_classes.html#a28ca93b6f8a64eb05c376afb1d9a6977">TestEqual</a> (char const *expected, char *got, std::string desc)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">"Specialization" of TestEqual for c-strings done using overloading  <a href="#a28ca93b6f8a64eb05c376afb1d9a6977"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_g_classes.html#acdefcc6a68bd526a30dd5ebef1766801">TestEqual</a> (char *expected, char *got, std::string desc)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">"Specialization" of TestEqual for c-strings done using overloading  <a href="#acdefcc6a68bd526a30dd5ebef1766801"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_g_classes.html#ae266a273da420b27b28b20e638463d51">rgbToHsv</a> (unsigned int c, float *pHue, float *pSaturation, float *pValue)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_g_classes.html#ab0156b4be8eaedb8c65356ce9b50a358">gAHSV</a> (int alpha, float hue, float saturation, float value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_g_classes.html#ab2bb631e561f25fe89748d2c00aa8d4c">ClipChan</a> (int n)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_g_classes.html#a627d51e02a0b5fc771faca02494f21b5">gRGB</a> (int r, int g, int b)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_g_classes.html#a4c96c5a192841890ff163cd8176aa0ac">gARGB</a> (int a, int r, int g, int b)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_g_classes.html#a7f13f70b83aa2dc2351695985411c0e9">gFromGray</a> (int gray)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_g_classes.html#aec68f053b2da8fe49d9bd0b3c9dbfd27">abgrToArgb</a> (unsigned int rgba)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_g_classes.html#ac62d5d7ffc509856d28e534e00803cb9">MixColors</a> (unsigned int a, unsigned int b, int nRatio)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_g_classes.html#af285ab4787ae320756ab77780062cab5">MultiplyBrightness</a> (unsigned int c, float f)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_g_classes.html#ae70c96238e9b027a50b2b7befb7a915d">rgbToHex</a> (char *pOutHex, unsigned int c)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_g_classes.html#a18c717a01145b96150c053c61f793979">hexToRgb</a> (const char *szHex)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_g_classes.html#aae9587620c0ea8309847008759e4ba5d">reverseBits</a> (T value)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverses the bits of value given that T is an unsigned integral type with binary representation and a number of bits that are a power of 2.  <a href="#aae9587620c0ea8309847008759e4ba5d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_g_classes.html#a98c44dbbda3f4d01163476d9cb1c09cb">reverseBitsTest</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_g_classes.html#a84e5bb9d6c30ab9651d535c5e42365e1">safe_strcpy</a> (char *szDest, const char *szSrc, size_t nDestBufferSize)</td></tr>
<tr><td colspan="2"><h2><a name="var-members"></a>
Variables</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">home mike tmp waftmp src <br class="typebreak"/>
GClasses G3D h typedef double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_g_classes.html#a539cbcfcda112c96cf42e7f59028a46b">G3DReal</a></td></tr>
</table>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="a05e6635da5dd8c2ed9fbca0de1888922"></a><!-- doxytag: member="GClasses::DaemonMainFunc" ref="a05e6635da5dd8c2ed9fbca0de1888922" args=")(void *pArg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* <a class="el" href="namespace_g_classes.html#a05e6635da5dd8c2ed9fbca0de1888922">GClasses::DaemonMainFunc</a>)(void *pArg)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a77ee1c95df9d35f82fb68af33a145a3e"></a><!-- doxytag: member="GClasses::EnsembleProgressCallback" ref="a77ee1c95df9d35f82fb68af33a145a3e" args=")(void *pThis, size_t i, size_t n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* <a class="el" href="namespace_g_classes.html#a77ee1c95df9d35f82fb68af33a145a3e">GClasses::EnsembleProgressCallback</a>)(void *pThis, size_t i, size_t n)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ae2576f1cef5c00b03a80fb750ce2f8ae"></a><!-- doxytag: member="GClasses::MathFunc" ref="ae2576f1cef5c00b03a80fb750ce2f8ae" args=")(void *pThis, double x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef double(* <a class="el" href="namespace_g_classes.html#ae2576f1cef5c00b03a80fb750ce2f8ae">GClasses::MathFunc</a>)(void *pThis, double x)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a70c393a5da93ac55bc41134644697609"></a><!-- doxytag: member="GClasses::PointerComparer" ref="a70c393a5da93ac55bc41134644697609" args=")(void *pThis, void *pA, void *pB)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* <a class="el" href="namespace_g_classes.html#a70c393a5da93ac55bc41134644697609">GClasses::PointerComparer</a>)(void *pThis, void *pA, void *pB)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="af7fa238518e08efc8a977ddf1b35fd59"></a><!-- doxytag: member="GClasses::RepValidateCallback" ref="af7fa238518e08efc8a977ddf1b35fd59" args=")(void *pThis, size_t nRep, size_t nFold, size_t labelDims, double *pFoldResults)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* <a class="el" href="namespace_g_classes.html#af7fa238518e08efc8a977ddf1b35fd59">GClasses::RepValidateCallback</a>)(void *pThis, size_t nRep, size_t nFold, size_t labelDims, double *pFoldResults)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a6b3b9015fd3581c392397706fb6a00a3"></a><!-- doxytag: member="GClasses::sighandler_t" ref="a6b3b9015fd3581c392397706fb6a00a3" args=")(int)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* <a class="el" href="namespace_g_classes.html#a6b3b9015fd3581c392397706fb6a00a3">GClasses::sighandler_t</a>)(int)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a167d05d64ce9a5f21994c18f1834e820"></a><!-- doxytag: member="GClasses::sp_relation" ref="a167d05d64ce9a5f21994c18f1834e820" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="class_g_classes_1_1smart__ptr.html">smart_ptr</a>&lt;<a class="el" href="class_g_classes_1_1_g_relation.html">GRelation</a>&gt; <a class="el" href="class_g_classes_1_1smart__ptr.html">GClasses::sp_relation</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a48f05d8e0221375ae6364f6d1a232483"></a><!-- doxytag: member="GClasses::THREAD_HANDLE" ref="a48f05d8e0221375ae6364f6d1a232483" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef unsigned long int <a class="el" href="namespace_g_classes.html#a48f05d8e0221375ae6364f6d1a232483">GClasses::THREAD_HANDLE</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a17e0716ae01035a6bf7aae9f9bbb8941"></a><!-- doxytag: member="GClasses::uint64" ref="a17e0716ae01035a6bf7aae9f9bbb8941" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef unsigned long long int <a class="el" href="namespace_g_classes.html#a17e0716ae01035a6bf7aae9f9bbb8941">GClasses::uint64</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ac299b5ca10e5219ab689162505bb2f45"></a><!-- doxytag: member="GClasses::_stricmp" ref="ac299b5ca10e5219ab689162505bb2f45" args="(const char *szA, const char *szB)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int GClasses::_stricmp </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>szA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>szB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="af3f892c5e72c1d1c4f8e3c9888c4d68a"></a><!-- doxytag: member="GClasses::_strnicmp" ref="af3f892c5e72c1d1c4f8e3c9888c4d68a" args="(const char *szA, const char *szB, int len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int GClasses::_strnicmp </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>szA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>szB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aec68f053b2da8fe49d9bd0b3c9dbfd27"></a><!-- doxytag: member="GClasses::abgrToArgb" ref="aec68f053b2da8fe49d9bd0b3c9dbfd27" args="(unsigned int rgba)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int GClasses::abgrToArgb </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>rgba</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ab2bb631e561f25fe89748d2c00aa8d4c"></a><!-- doxytag: member="GClasses::ClipChan" ref="ab2bb631e561f25fe89748d2c00aa8d4c" args="(int n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int GClasses::ClipChan </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="abf2d5c0e6bc3b0cb734034337f89241e"></a><!-- doxytag: member="GClasses::filelength" ref="abf2d5c0e6bc3b0cb734034337f89241e" args="(int filedes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long GClasses::filelength </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>filedes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ab0156b4be8eaedb8c65356ce9b50a358"></a><!-- doxytag: member="GClasses::gAHSV" ref="ab0156b4be8eaedb8c65356ce9b50a358" args="(int alpha, float hue, float saturation, float value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int GClasses::gAHSV </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>hue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>saturation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a4c96c5a192841890ff163cd8176aa0ac"></a><!-- doxytag: member="GClasses::gARGB" ref="a4c96c5a192841890ff163cd8176aa0ac" args="(int a, int r, int g, int b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int GClasses::gARGB </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a85499c08be1fc47b8cc1bd0cac041f0f"></a><!-- doxytag: member="GClasses::GAssertFailed" ref="a85499c08be1fc47b8cc1bd0cac041f0f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GClasses::GAssertFailed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a7f13f70b83aa2dc2351695985411c0e9"></a><!-- doxytag: member="GClasses::gFromGray" ref="a7f13f70b83aa2dc2351695985411c0e9" args="(int gray)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int GClasses::gFromGray </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>gray</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a627d51e02a0b5fc771faca02494f21b5"></a><!-- doxytag: member="GClasses::gRGB" ref="a627d51e02a0b5fc771faca02494f21b5" args="(int r, int g, int b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int GClasses::gRGB </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a18c717a01145b96150c053c61f793979"></a><!-- doxytag: member="GClasses::hexToRgb" ref="a18c717a01145b96150c053c61f793979" args="(const char *szHex)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int GClasses::hexToRgb </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>szHex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ac62d5d7ffc509856d28e534e00803cb9"></a><!-- doxytag: member="GClasses::MixColors" ref="ac62d5d7ffc509856d28e534e00803cb9" args="(unsigned int a, unsigned int b, int nRatio)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int GClasses::MixColors </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nRatio</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="af285ab4787ae320756ab77780062cab5"></a><!-- doxytag: member="GClasses::MultiplyBrightness" ref="af285ab4787ae320756ab77780062cab5" args="(unsigned int c, float f)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int GClasses::MultiplyBrightness </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aae9587620c0ea8309847008759e4ba5d"></a><!-- doxytag: member="GClasses::reverseBits" ref="aae9587620c0ea8309847008759e4ba5d" args="(T value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T GClasses::reverseBits </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reverses the bits of value given that T is an unsigned integral type with binary representation and a number of bits that are a power of 2. </p>
<p>Modified (added checks and some consts for readability) from the post at <a href="http://www.velocityreviews.com/forums/t457514-reverse-bit-order.html">http://www.velocityreviews.com/forums/t457514-reverse-bit-order.html</a> by Pete Becker, Author of "The Standard C++ Library Extensions: a Tutorial and
  Reference" </p>

</div>
</div>
<a class="anchor" id="a98c44dbbda3f4d01163476d9cb1c09cb"></a><!-- doxytag: member="GClasses::reverseBitsTest" ref="a98c44dbbda3f4d01163476d9cb1c09cb" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GClasses::reverseBitsTest </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ae70c96238e9b027a50b2b7befb7a915d"></a><!-- doxytag: member="GClasses::rgbToHex" ref="ae70c96238e9b027a50b2b7befb7a915d" args="(char *pOutHex, unsigned int c)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* GClasses::rgbToHex </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>pOutHex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ae266a273da420b27b28b20e638463d51"></a><!-- doxytag: member="GClasses::rgbToHsv" ref="ae266a273da420b27b28b20e638463d51" args="(unsigned int c, float *pHue, float *pSaturation, float *pValue)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GClasses::rgbToHsv </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>pHue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>pSaturation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>pValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a84e5bb9d6c30ab9651d535c5e42365e1"></a><!-- doxytag: member="GClasses::safe_strcpy" ref="a84e5bb9d6c30ab9651d535c5e42365e1" args="(char *szDest, const char *szSrc, size_t nDestBufferSize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t GClasses::safe_strcpy </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>szDest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>szSrc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nDestBufferSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a46f3373726a90e727c435534d1bf2140"></a><!-- doxytag: member="GClasses::TestEqual" ref="a46f3373726a90e727c435534d1bf2140" args="(char const *expected, char const *got, std::string desc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GClasses::TestEqual </td>
          <td>(</td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>expected</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>got</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>desc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>"Specialization" of TestEqual for c-strings done using overloading </p>

</div>
</div>
<a class="anchor" id="a28ca93b6f8a64eb05c376afb1d9a6977"></a><!-- doxytag: member="GClasses::TestEqual" ref="a28ca93b6f8a64eb05c376afb1d9a6977" args="(char const *expected, char *got, std::string desc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GClasses::TestEqual </td>
          <td>(</td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>expected</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>got</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>desc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>"Specialization" of TestEqual for c-strings done using overloading </p>

</div>
</div>
<a class="anchor" id="acdefcc6a68bd526a30dd5ebef1766801"></a><!-- doxytag: member="GClasses::TestEqual" ref="acdefcc6a68bd526a30dd5ebef1766801" args="(char *expected, char *got, std::string desc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GClasses::TestEqual </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>expected</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>got</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>desc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>"Specialization" of TestEqual for c-strings done using overloading </p>

</div>
</div>
<a class="anchor" id="aa91ed8e052b67d6f6b5f51e8b5af0b65"></a><!-- doxytag: member="GClasses::TestEqual" ref="aa91ed8e052b67d6f6b5f51e8b5af0b65" args="(const T1 &amp;expected, const T2 &amp;got, std::string test_descr)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GClasses::TestEqual </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>expected</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>got</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>test_descr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Verify that <em>expected</em> and <em>got</em> are equal for test code. Unlike Assert, this check does not disappear in optimized builds. </p>
<p>If expected==got then does nothing. Otherwise prints to stderr:</p>
<pre>
Test for equality failed: ---------test_descr goes here ---------------</pre><pre>Expected: ------------expected goes here---------------
Got     : ------------got goes here     ---------------
</pre><p>Then it throws an exception using ThrowError</p>
<p>Calls operator==(const T1&amp;,const T2&amp;) to determine equality.</p>
<p>Calls <a class="el" href="namespace_g_classes.html#a597f1897f173e6df4569efc03a7ec3c4">GClasses::to_str</a> to form the string representation of <em>expected</em> and <em>got</em>  expected The value expected from specifications</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">got</td><td>The value actually produced by the code</td></tr>
    <tr><td class="paramname">test_descr</td><td>A short test description to allow a human to easily find the failing test in the code and understand why it was written and have some help in diagnosing the bug. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a383091cc75d4ddabd02bec668fc599ff"></a><!-- doxytag: member="GClasses::ThrowError" ref="a383091cc75d4ddabd02bec668fc599ff" args="(std::string s1, std::string s2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GClasses::ThrowError </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>s2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="acd22e117e9b320c96bbd84ebe0185656"></a><!-- doxytag: member="GClasses::ThrowError" ref="acd22e117e9b320c96bbd84ebe0185656" args="(std::string s1, std::string s2, std::string s3, std::string s4, std::string s5, std::string s6, std::string s7, std::string s8)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GClasses::ThrowError </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>s2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>s3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>s4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>s5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>s6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>s7</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>s8</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a70dbbb956610c72344c05daf254a6681"></a><!-- doxytag: member="GClasses::ThrowError" ref="a70dbbb956610c72344c05daf254a6681" args="(std::string s1, std::string s2, std::string s3, std::string s4, std::string s5)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GClasses::ThrowError </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>s2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>s3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>s4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>s5</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="abe21ad856d6c20a3bd98ea3e39e041d6"></a><!-- doxytag: member="GClasses::ThrowError" ref="abe21ad856d6c20a3bd98ea3e39e041d6" args="(std::string s1, std::string s2, std::string s3, std::string s4, std::string s5, std::string s6)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GClasses::ThrowError </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>s2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>s3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>s4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>s5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>s6</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a9e9db4fbb7904149a64abbc9fbacd47a"></a><!-- doxytag: member="GClasses::ThrowError" ref="a9e9db4fbb7904149a64abbc9fbacd47a" args="(std::string s1, std::string s2, std::string s3)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GClasses::ThrowError </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>s2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>s3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aabea6f5d6ea3fac5357ddce762ad7efa"></a><!-- doxytag: member="GClasses::ThrowError" ref="aabea6f5d6ea3fac5357ddce762ad7efa" args="(std::string s1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GClasses::ThrowError </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>s1</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aba4cb918ec65e021a90fcada14198626"></a><!-- doxytag: member="GClasses::ThrowError" ref="aba4cb918ec65e021a90fcada14198626" args="(std::string s1, std::string s2, std::string s3, std::string s4, std::string s5, std::string s6, std::string s7, std::string s8, std::string s9, std::string s10)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GClasses::ThrowError </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>s2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>s3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>s4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>s5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>s6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>s7</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>s8</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>s9</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>s10</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ae16fa1ce1df6010b61659cf9dc29e46f"></a><!-- doxytag: member="GClasses::ThrowError" ref="ae16fa1ce1df6010b61659cf9dc29e46f" args="(std::string s1, std::string s2, std::string s3, std::string s4)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GClasses::ThrowError </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>s2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>s3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>s4</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ac6d6e1509ef5c53335f42576a01c3a21"></a><!-- doxytag: member="GClasses::ThrowError" ref="ac6d6e1509ef5c53335f42576a01c3a21" args="(std::string s1, std::string s2, std::string s3, std::string s4, std::string s5, std::string s6, std::string s7)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GClasses::ThrowError </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>s2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>s3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>s4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>s5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>s6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>s7</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a245d51ad6c81e9eb4bfdfa0c4ab0f54c"></a><!-- doxytag: member="GClasses::ThrowError" ref="a245d51ad6c81e9eb4bfdfa0c4ab0f54c" args="(std::string s1, std::string s2, std::string s3, std::string s4, std::string s5, std::string s6, std::string s7, std::string s8, std::string s9)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GClasses::ThrowError </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>s2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>s3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>s4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>s5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>s6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>s7</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>s8</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>s9</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a597f1897f173e6df4569efc03a7ec3c4"></a><!-- doxytag: member="GClasses::to_str" ref="a597f1897f173e6df4569efc03a7ec3c4" args="(const T &amp;n)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string GClasses::to_str </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Variable Documentation</h2>
<a class="anchor" id="a539cbcfcda112c96cf42e7f59028a46b"></a><!-- doxytag: member="GClasses::G3DReal" ref="a539cbcfcda112c96cf42e7f59028a46b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">home mike tmp waftmp src GClasses G3D h typedef double <a class="el" href="namespace_g_classes.html#a539cbcfcda112c96cf42e7f59028a46b">GClasses::G3DReal</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
</div>
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="namespace_g_classes.html">GClasses</a>      </li>
      <li class="footer">Generated on Mon Dec 5 2011 14:18:59 for GClasses by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.3 </li>
    </ul>
  </div>

</body>
</html>
