<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>GClasses: GClasses::GSelfOrganizingMap Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript">
$(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.3 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">GClasses</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('class_g_classes_1_1_g_self_organizing_map.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#friends">Friends</a>  </div>
  <div class="headertitle">
<h1>GClasses::GSelfOrganizingMap Class Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="GClasses::GSelfOrganizingMap" --><!-- doxytag: inherits="GClasses::GIncrementalTransform" -->
<p>An implementation of a Kohonen self-organizing map.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;GSelfOrganizingMap.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for GClasses::GSelfOrganizingMap:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_g_classes_1_1_g_self_organizing_map.png" usemap="#GClasses::GSelfOrganizingMap_map" alt=""/>
  <map id="GClasses::GSelfOrganizingMap_map" name="GClasses::GSelfOrganizingMap_map">
<area href="class_g_classes_1_1_g_incremental_transform.html" alt="GClasses::GIncrementalTransform" shape="rect" coords="0,56,202,80"/>
<area href="class_g_classes_1_1_g_transform.html" alt="GClasses::GTransform" shape="rect" coords="0,0,202,24"/>
</map>
 </div></div>

<p><a href="class_g_classes_1_1_g_self_organizing_map-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_self_organizing_map.html#a7387bb15c37344e234a1bb7fb28313a5">GSelfOrganizingMap</a> (int nMapDims, int nMapWidth, <a class="el" href="class_g_classes_1_1_g_rand.html">GRand</a> *pRand, <a class="el" href="class_g_classes_1_1_s_o_m_1_1_reporter.html">SOM::Reporter</a> *r=new <a class="el" href="class_g_classes_1_1_s_o_m_1_1_no_reporting.html">SOM::NoReporting</a>())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a map whose nodes are on a grid that uses euclidean distance to find the nearest point and is trained with the batch <a class="el" href="namespace_g_classes_1_1_s_o_m.html">SOM</a> algorithm with neighborhood decreasing exponentially from 2*nMapWidth to 1 in 100 super-epochs with each super-epoch involving waiting up to 100 iterations for convergence at that neighborhood width. The neighbors affect one another through a unit height Gaussian with sigma=neighborhood size. Every epoch and super-epoch, the reporter is notified. This map will be responsible for deleting the dynamically allocated reporter.  <a href="#a7387bb15c37344e234a1bb7fb28313a5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_self_organizing_map.html#a4ce7cf6f6d3a58f1ca480b2c3c6b997a">GSelfOrganizingMap</a> (const std::vector&lt; double &gt; &amp;outputAxes, std::size_t numNodes, <a class="el" href="class_g_classes_1_1_s_o_m_1_1_node_location_initialization.html">SOM::NodeLocationInitialization</a> *topology, <a class="el" href="class_g_classes_1_1_s_o_m_1_1_training_algorithm.html">SOM::TrainingAlgorithm</a> *trainer, <a class="el" href="class_g_classes_1_1_g_distance_metric.html">GDistanceMetric</a> *weightDistance, <a class="el" href="class_g_classes_1_1_g_distance_metric.html">GDistanceMetric</a> *nodeDistance)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a self-organizing map.  <a href="#a4ce7cf6f6d3a58f1ca480b2c3c6b997a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_self_organizing_map.html#af77404c4ee8a7ec0a231b98ecfb16f9b">GSelfOrganizingMap</a> (<a class="el" href="class_g_classes_1_1_g_dom_node.html">GDomNode</a> *pNode)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Reconstruct this self-organizing map from its serialized form in a dom document.  <a href="#af77404c4ee8a7ec0a231b98ecfb16f9b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_self_organizing_map.html#a8f02a036b37c633d8eb34a8d7dc7a1c4">~GSelfOrganizingMap</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_g_classes_1_1_g_matrix.html">GMatrix</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_self_organizing_map.html#aab16eb5df0c3769898153eb4e5ea09dc">doit</a> (<a class="el" href="class_g_classes_1_1_g_matrix.html">GMatrix</a> &amp;in)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms pIn after training on it.  <a href="#aab16eb5df0c3769898153eb4e5ea09dc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_g_classes_1_1_g_dom_node.html">GDomNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_self_organizing_map.html#a8708bf1110d7194f2710f61dbd6eda98">serialize</a> (<a class="el" href="class_g_classes_1_1_g_dom.html">GDom</a> *)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Add this map to a dom document and return the pointer to the tree added. <br/>
<br/>
 <b>WARNING</b>: the current imlementation DOES NOT SERIALIZE THE TRAINING ALGORITHM - do not train a <a class="el" href="class_g_classes_1_1_g_self_organizing_map.html" title="An implementation of a Kohonen self-organizing map.">GSelfOrganizingMap</a> obtained from a dom file.  <a href="#a8708bf1110d7194f2710f61dbd6eda98"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_self_organizing_map.html#af855289f024059225be522f13ecf2236">train</a> (<a class="el" href="class_g_classes_1_1_g_matrix.html">GMatrix</a> &amp;in)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">see comment on <a class="el" href="class_g_classes_1_1_g_incremental_transform.html#a778a3634b5276d72806c86351e5918c9" title="Trains the transform on the data in pData.">GIncrementalTransform::train(GMatrix&amp;)</a>  <a href="#af855289f024059225be522f13ecf2236"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_self_organizing_map.html#a96854a794e0179c9adad5e27c5204bbd">beginIncrementalTraining</a> (<a class="el" href="class_g_classes_1_1smart__ptr.html">sp_relation</a> &amp;, double *, double *)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">TODO: implement enableIncrementalTraining.  <a href="#a96854a794e0179c9adad5e27c5204bbd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_self_organizing_map.html#ae2075b5f0be6c34ae200a899fc2bfc58">transform</a> (const double *pIn, double *pOut)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform the given vector from input coordinates to map coordinates by finding the best match among the nodes.  <a href="#ae2075b5f0be6c34ae200a899fc2bfc58"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_self_organizing_map.html#aa11aa238df7f512a74fb4b4ee49bed20">bestMatch</a> (const double *pIn) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the index of the node whose weight vector best matches in under the distance metric for this <a class="el" href="namespace_g_classes_1_1_s_o_m.html">SOM</a>. Assumes there is at least one node.  <a href="#aa11aa238df7f512a74fb4b4ee49bed20"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_self_organizing_map.html#a38dd4b3876d01bd9c293ad5b6cd8f42d">bestData</a> (const <a class="el" href="class_g_classes_1_1_g_matrix.html">GMatrix</a> *pData) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a matrix containing input data of the correct dimensions, returns a vector v of nodes.size() indices into that matrix. v[i] is the index of the data in pData that gives the strongest response for node i. That is, pData-&gt;row(v[i]) is the data element that best matches node i.  <a href="#a38dd4b3876d01bd9c293ad5b6cd8f42d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_self_organizing_map.html#a5334a33a0537ac3703dd172bbd6d90fe">nearestNeighbors</a> (unsigned nodeIdx, unsigned numNeighbors, double epsilon=1e-8) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Inspector giving the indices of the nearest neighbors in output space of the node at index nodeIdx. If any neighbor with a given distance is returned all neighbors at that distance will be returned. Any distances within epsilon of one another are considered equivalent.  <a href="#a5334a33a0537ac3703dd172bbd6d90fe"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="class_g_classes_1_1_s_o_m_1_1_node_and_distance.html">SOM::NodeAndDistance</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_self_organizing_map.html#a79d2f046dd4ef6700a4d9ec59caa736e">neighborsInCircle</a> (unsigned nodeIdx, double radius) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return all neighbors of the node at that have a distance from nodeIdx of less than radius.  <a href="#a79d2f046dd4ef6700a4d9ec59caa736e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_self_organizing_map.html#ab505f8e6b43e400e26a9ad38336aadb5">inputDimensions</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of dimensions this takes as input.  <a href="#ab505f8e6b43e400e26a9ad38336aadb5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_self_organizing_map.html#a078e096536c1935b97a84afd2d55e35f">outputDimensions</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of dimensions this returns as output.  <a href="#a078e096536c1935b97a84afd2d55e35f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_self_organizing_map.html#ae1caa70325b3515b307cb73e3675bcb6">outputAxes</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the maximum for each output axis.  <a href="#ae1caa70325b3515b307cb73e3675bcb6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="class_g_classes_1_1_s_o_m_1_1_node.html">SOM::Node</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_self_organizing_map.html#a13e2096913dea9f236977ac9756ebef8">nodes</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Inspector for the nodes making up this map.  <a href="#a13e2096913dea9f236977ac9756ebef8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="class_g_classes_1_1_s_o_m_1_1_node.html">SOM::Node</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_self_organizing_map.html#a14b269cefa27627a701140e244d78cd8">nodes</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Accessor for the nodes making up this map.  <a href="#a14b269cefa27627a701140e244d78cd8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_g_classes_1_1_g_distance_metric.html">GDistanceMetric</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_self_organizing_map.html#a8ca2c02867c1e10f8c99398f42e61995">weightDistance</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Inspector for the distance metric used in input space, that is, between an input point and a weight for determining the winner.  <a href="#a8ca2c02867c1e10f8c99398f42e61995"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_g_classes_1_1_g_distance_metric.html">GDistanceMetric</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_self_organizing_map.html#afb4bc3203acbd6f4637fe4c96fd5565a">nodeDistance</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Inspector for the distance metric used in output space, that is, between two nodes for their relative influence.  <a href="#afb4bc3203acbd6f4637fe4c96fd5565a"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_self_organizing_map.html#ae92a249040cdb82b70c0015d090e46a8">test</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs unit tests for this class. Throws an exception if there is a failure.  <a href="#ae92a249040cdb82b70c0015d090e46a8"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_self_organizing_map.html#ab1377a2c159adb83c98de62ca1c7a47e">invalidateSortedNeighbors</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Marks sortedNeighbors as invalid and need of regeneration.  <a href="#ab1377a2c159adb83c98de62ca1c7a47e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_self_organizing_map.html#a07dd747fc79c5dd0a0f3c52294a0626c">regenerateSortedNeighbors</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Eliminates the current contents of m_sortedNeighbors and regenerates it from m_pNodeDistance and m_nodes. sets m_sortedNeighborsIsValid on completion. Note that the members this method changes are mutable, thus it can be marked as a const method and called from const methods.  <a href="#a07dd747fc79c5dd0a0f3c52294a0626c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const std::vector&lt; std::vector<br class="typebreak"/>
&lt; <a class="el" href="class_g_classes_1_1_s_o_m_1_1_node_and_distance.html">SOM::NodeAndDistance</a> &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_self_organizing_map.html#ab6b8e90e27722a398dabbdc073608c89">sortedNeighbors</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a sorted neighbor structure in which entry i is a list of the node indices sorted by their distance from node i.  <a href="#ab6b8e90e27722a398dabbdc073608c89"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_self_organizing_map.html#a2ce580e1ed6dd45f8a333fde26ec2568">m_nInputDims</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of input dimensions.  <a href="#a2ce580e1ed6dd45f8a333fde26ec2568"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_self_organizing_map.html#af0d0e2da0960b03be2c3a1ed723e8c03">m_outputAxes</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector containing the maximum number in each output axis - so axis #0 would have a range 0..m_vOutputAxes[0]. Remember to call m_pNodeDistance-&gt;init whenever you change the number of output axes.  <a href="#af0d0e2da0960b03be2c3a1ed723e8c03"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_g_classes_1_1_s_o_m_1_1_training_algorithm.html">SOM::TrainingAlgorithm</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_self_organizing_map.html#a381ba98aa852e1b82518e771ce863919">m_pTrainer</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The algorithm to be used to train this map on the next call to train. This object owns the training algorithm and is responsable for deleting it.  <a href="#a381ba98aa852e1b82518e771ce863919"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_g_classes_1_1_g_distance_metric.html">GDistanceMetric</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_self_organizing_map.html#aa814a1e3bebe5e6941d8163a29eb0013">m_pWeightDistance</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The distance function to use when finding the closest weight to a given input point - owned by this object. Remember to call init on this whenever you change the number of weights.  <a href="#aa814a1e3bebe5e6941d8163a29eb0013"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_g_classes_1_1_g_distance_metric.html">GDistanceMetric</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_self_organizing_map.html#a372c06cafea1c364c891042d43576ca4">m_pNodeDistance</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The distance function to use when calculating the distance between nodes in the map. If you change this, remember to invalidate the neighbor structure. - owned by this object. Remember to call init whenever you change the number of output axes.  <a href="#a372c06cafea1c364c891042d43576ca4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="class_g_classes_1_1_s_o_m_1_1_node.html">SOM::Node</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_self_organizing_map.html#a26a4c9b0d1831a7923971157b8d42f97">m_nodes</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The nodes in the map. Do not change the order of nodes once sortedNeighbors has been created unless you also invalidate sortedNeighbors. Remember to call m_pWeightDistance-&gt;init if you change the number of weights.  <a href="#a26a4c9b0d1831a7923971157b8d42f97"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_self_organizing_map.html#a3f4f5265f36dac5f6500891968887bb6">m_sortedNeighborsIsValid</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector<br class="typebreak"/>
&lt; <a class="el" href="class_g_classes_1_1_s_o_m_1_1_node_and_distance.html">SOM::NodeAndDistance</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_self_organizing_map.html#a974743eef82cdfbec2590539746635b7">m_sortedNeighbors</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Each entry sortedNeighbors[i] contains a vector of all the other nodes sorted by their distance from i in outputSpace.  <a href="#a974743eef82cdfbec2590539746635b7"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="friends"></a>
Friends</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_self_organizing_map.html#a59a98affa39a0ef9fd9323cdd8565820">SOM::TrainingAlgorithm</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>An implementation of a Kohonen self-organizing map. </p>
<p>Note: does not support more than 2^52 nodes -- I don't believe this will be a problem within the next 20 years.</p>
<p>See: T. Kohonen "Self Organizing Maps" Third Edition, 2001, published by Springer </p>
</div><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a7387bb15c37344e234a1bb7fb28313a5"></a><!-- doxytag: member="GClasses::GSelfOrganizingMap::GSelfOrganizingMap" ref="a7387bb15c37344e234a1bb7fb28313a5" args="(int nMapDims, int nMapWidth, GRand *pRand, SOM::Reporter *r=new SOM::NoReporting())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GClasses::GSelfOrganizingMap::GSelfOrganizingMap </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nMapDims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nMapWidth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_g_classes_1_1_g_rand.html">GRand</a> *&#160;</td>
          <td class="paramname"><em>pRand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_g_classes_1_1_s_o_m_1_1_reporter.html">SOM::Reporter</a> *&#160;</td>
          <td class="paramname"><em>r</em> = <code>new&#160;<a class="el" href="class_g_classes_1_1_s_o_m_1_1_no_reporting.html">SOM::NoReporting</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a map whose nodes are on a grid that uses euclidean distance to find the nearest point and is trained with the batch <a class="el" href="namespace_g_classes_1_1_s_o_m.html">SOM</a> algorithm with neighborhood decreasing exponentially from 2*nMapWidth to 1 in 100 super-epochs with each super-epoch involving waiting up to 100 iterations for convergence at that neighborhood width. The neighbors affect one another through a unit height Gaussian with sigma=neighborhood size. Every epoch and super-epoch, the reporter is notified. This map will be responsible for deleting the dynamically allocated reporter. </p>
<p>nMapDims specifies the number of dimensions for the map.</p>
<p>nMapWidth specifies the size in one dimension of the map.</p>
<p>(so if nMapDims is 3 and nMapWidth is 10, the map will contain 1000 (10^3) nodes.) </p>

</div>
</div>
<a class="anchor" id="a4ce7cf6f6d3a58f1ca480b2c3c6b997a"></a><!-- doxytag: member="GClasses::GSelfOrganizingMap::GSelfOrganizingMap" ref="a4ce7cf6f6d3a58f1ca480b2c3c6b997a" args="(const std::vector&lt; double &gt; &amp;outputAxes, std::size_t numNodes, SOM::NodeLocationInitialization *topology, SOM::TrainingAlgorithm *trainer, GDistanceMetric *weightDistance, GDistanceMetric *nodeDistance)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GClasses::GSelfOrganizingMap::GSelfOrganizingMap </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>outputAxes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>numNodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_g_classes_1_1_s_o_m_1_1_node_location_initialization.html">SOM::NodeLocationInitialization</a> *&#160;</td>
          <td class="paramname"><em>topology</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_g_classes_1_1_s_o_m_1_1_training_algorithm.html">SOM::TrainingAlgorithm</a> *&#160;</td>
          <td class="paramname"><em>trainer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_g_classes_1_1_g_distance_metric.html">GDistanceMetric</a> *&#160;</td>
          <td class="paramname"><em>weightDistance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_g_classes_1_1_g_distance_metric.html">GDistanceMetric</a> *&#160;</td>
          <td class="paramname"><em>nodeDistance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a self-organizing map. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">outputAxes</td><td>each node in the network will have a vector location and component i of that vector will range from 0..outputAxes[i]</td></tr>
    <tr><td class="paramname">numNodes</td><td>the number of nodes in the network</td></tr>
    <tr><td class="paramname">topology</td><td>determines the locations assigned to each node</td></tr>
    <tr><td class="paramname">trainer</td><td>algorithm to train the network on data</td></tr>
    <tr><td class="paramname">weightDistance</td><td>the distance used in determining which node's weight-set is closest to an input point</td></tr>
    <tr><td class="paramname">nodeDistance</td><td>the distance used to determine the influence of two nodes with different coordinates on one another. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af77404c4ee8a7ec0a231b98ecfb16f9b"></a><!-- doxytag: member="GClasses::GSelfOrganizingMap::GSelfOrganizingMap" ref="af77404c4ee8a7ec0a231b98ecfb16f9b" args="(GDomNode *pNode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GClasses::GSelfOrganizingMap::GSelfOrganizingMap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_g_classes_1_1_g_dom_node.html">GDomNode</a> *&#160;</td>
          <td class="paramname"><em>pNode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reconstruct this self-organizing map from its serialized form in a dom document. </p>

</div>
</div>
<a class="anchor" id="a8f02a036b37c633d8eb34a8d7dc7a1c4"></a><!-- doxytag: member="GClasses::GSelfOrganizingMap::~GSelfOrganizingMap" ref="a8f02a036b37c633d8eb34a8d7dc7a1c4" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual GClasses::GSelfOrganizingMap::~GSelfOrganizingMap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a96854a794e0179c9adad5e27c5204bbd"></a><!-- doxytag: member="GClasses::GSelfOrganizingMap::beginIncrementalTraining" ref="a96854a794e0179c9adad5e27c5204bbd" args="(sp_relation &amp;, double *, double *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void GClasses::GSelfOrganizingMap::beginIncrementalTraining </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_g_classes_1_1smart__ptr.html">sp_relation</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>TODO: implement enableIncrementalTraining. </p>

</div>
</div>
<a class="anchor" id="a38dd4b3876d01bd9c293ad5b6cd8f42d"></a><!-- doxytag: member="GClasses::GSelfOrganizingMap::bestData" ref="a38dd4b3876d01bd9c293ad5b6cd8f42d" args="(const GMatrix *pData) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::size_t&gt; GClasses::GSelfOrganizingMap::bestData </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_g_classes_1_1_g_matrix.html">GMatrix</a> *&#160;</td>
          <td class="paramname"><em>pData</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Given a matrix containing input data of the correct dimensions, returns a vector v of nodes.size() indices into that matrix. v[i] is the index of the data in pData that gives the strongest response for node i. That is, pData-&gt;row(v[i]) is the data element that best matches node i. </p>
<p>Assumes there is at least one row in pData </p>

</div>
</div>
<a class="anchor" id="aa11aa238df7f512a74fb4b4ee49bed20"></a><!-- doxytag: member="GClasses::GSelfOrganizingMap::bestMatch" ref="aa11aa238df7f512a74fb4b4ee49bed20" args="(const double *pIn) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t GClasses::GSelfOrganizingMap::bestMatch </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>pIn</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the index of the node whose weight vector best matches in under the distance metric for this <a class="el" href="namespace_g_classes_1_1_s_o_m.html">SOM</a>. Assumes there is at least one node. </p>

</div>
</div>
<a class="anchor" id="aab16eb5df0c3769898153eb4e5ea09dc"></a><!-- doxytag: member="GClasses::GSelfOrganizingMap::doit" ref="aab16eb5df0c3769898153eb4e5ea09dc" args="(GMatrix &amp;in)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_g_classes_1_1_g_matrix.html">GMatrix</a>* GClasses::GSelfOrganizingMap::doit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_g_classes_1_1_g_matrix.html">GMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Transforms pIn after training on it. </p>

<p>Reimplemented from <a class="el" href="class_g_classes_1_1_g_incremental_transform.html#a193c94073fd18095db4e0ecbd11c5826">GClasses::GIncrementalTransform</a>.</p>

</div>
</div>
<a class="anchor" id="ab505f8e6b43e400e26a9ad38336aadb5"></a><!-- doxytag: member="GClasses::GSelfOrganizingMap::inputDimensions" ref="ab505f8e6b43e400e26a9ad38336aadb5" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned GClasses::GSelfOrganizingMap::inputDimensions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the number of dimensions this takes as input. </p>

</div>
</div>
<a class="anchor" id="ab1377a2c159adb83c98de62ca1c7a47e"></a><!-- doxytag: member="GClasses::GSelfOrganizingMap::invalidateSortedNeighbors" ref="ab1377a2c159adb83c98de62ca1c7a47e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GClasses::GSelfOrganizingMap::invalidateSortedNeighbors </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Marks sortedNeighbors as invalid and need of regeneration. </p>

</div>
</div>
<a class="anchor" id="a5334a33a0537ac3703dd172bbd6d90fe"></a><!-- doxytag: member="GClasses::GSelfOrganizingMap::nearestNeighbors" ref="a5334a33a0537ac3703dd172bbd6d90fe" args="(unsigned nodeIdx, unsigned numNeighbors, double epsilon=1e&#45;8) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::size_t&gt; GClasses::GSelfOrganizingMap::nearestNeighbors </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>nodeIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>numNeighbors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>epsilon</em> = <code>1e-8</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Inspector giving the indices of the nearest neighbors in output space of the node at index nodeIdx. If any neighbor with a given distance is returned all neighbors at that distance will be returned. Any distances within epsilon of one another are considered equivalent. </p>
<p>If there are enough nodes in the network, at least numNeigbors neighbors will be returned. If there are fewer nodes in the network than the number of neighbors, a list of all indices will be returned. </p>

</div>
</div>
<a class="anchor" id="a79d2f046dd4ef6700a4d9ec59caa736e"></a><!-- doxytag: member="GClasses::GSelfOrganizingMap::neighborsInCircle" ref="a79d2f046dd4ef6700a4d9ec59caa736e" args="(unsigned nodeIdx, double radius) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="class_g_classes_1_1_s_o_m_1_1_node_and_distance.html">SOM::NodeAndDistance</a>&gt; GClasses::GSelfOrganizingMap::neighborsInCircle </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>nodeIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>radius</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return all neighbors of the node at that have a distance from nodeIdx of less than radius. </p>

</div>
</div>
<a class="anchor" id="afb4bc3203acbd6f4637fe4c96fd5565a"></a><!-- doxytag: member="GClasses::GSelfOrganizingMap::nodeDistance" ref="afb4bc3203acbd6f4637fe4c96fd5565a" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_g_classes_1_1_g_distance_metric.html">GDistanceMetric</a>* GClasses::GSelfOrganizingMap::nodeDistance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Inspector for the distance metric used in output space, that is, between two nodes for their relative influence. </p>

</div>
</div>
<a class="anchor" id="a13e2096913dea9f236977ac9756ebef8"></a><!-- doxytag: member="GClasses::GSelfOrganizingMap::nodes" ref="a13e2096913dea9f236977ac9756ebef8" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="class_g_classes_1_1_s_o_m_1_1_node.html">SOM::Node</a>&gt;&amp; GClasses::GSelfOrganizingMap::nodes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Inspector for the nodes making up this map. </p>

</div>
</div>
<a class="anchor" id="a14b269cefa27627a701140e244d78cd8"></a><!-- doxytag: member="GClasses::GSelfOrganizingMap::nodes" ref="a14b269cefa27627a701140e244d78cd8" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="class_g_classes_1_1_s_o_m_1_1_node.html">SOM::Node</a>&gt;&amp; GClasses::GSelfOrganizingMap::nodes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Accessor for the nodes making up this map. </p>

</div>
</div>
<a class="anchor" id="ae1caa70325b3515b307cb73e3675bcb6"></a><!-- doxytag: member="GClasses::GSelfOrganizingMap::outputAxes" ref="ae1caa70325b3515b307cb73e3675bcb6" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;double&gt; GClasses::GSelfOrganizingMap::outputAxes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the maximum for each output axis. </p>

</div>
</div>
<a class="anchor" id="a078e096536c1935b97a84afd2d55e35f"></a><!-- doxytag: member="GClasses::GSelfOrganizingMap::outputDimensions" ref="a078e096536c1935b97a84afd2d55e35f" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned GClasses::GSelfOrganizingMap::outputDimensions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the number of dimensions this returns as output. </p>

</div>
</div>
<a class="anchor" id="a07dd747fc79c5dd0a0f3c52294a0626c"></a><!-- doxytag: member="GClasses::GSelfOrganizingMap::regenerateSortedNeighbors" ref="a07dd747fc79c5dd0a0f3c52294a0626c" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GClasses::GSelfOrganizingMap::regenerateSortedNeighbors </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Eliminates the current contents of m_sortedNeighbors and regenerates it from m_pNodeDistance and m_nodes. sets m_sortedNeighborsIsValid on completion. Note that the members this method changes are mutable, thus it can be marked as a const method and called from const methods. </p>

</div>
</div>
<a class="anchor" id="a8708bf1110d7194f2710f61dbd6eda98"></a><!-- doxytag: member="GClasses::GSelfOrganizingMap::serialize" ref="a8708bf1110d7194f2710f61dbd6eda98" args="(GDom *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_g_classes_1_1_g_dom_node.html">GDomNode</a>* GClasses::GSelfOrganizingMap::serialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_g_classes_1_1_g_dom.html">GDom</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add this map to a dom document and return the pointer to the tree added. <br/>
<br/>
 <b>WARNING</b>: the current imlementation DOES NOT SERIALIZE THE TRAINING ALGORITHM - do not train a <a class="el" href="class_g_classes_1_1_g_self_organizing_map.html" title="An implementation of a Kohonen self-organizing map.">GSelfOrganizingMap</a> obtained from a dom file. </p>
<p>TODO: make all serialize's const </p>

<p>Implements <a class="el" href="class_g_classes_1_1_g_incremental_transform.html#a96175c8846e4548bfa8c6b175d2fd754">GClasses::GIncrementalTransform</a>.</p>

</div>
</div>
<a class="anchor" id="ab6b8e90e27722a398dabbdc073608c89"></a><!-- doxytag: member="GClasses::GSelfOrganizingMap::sortedNeighbors" ref="ab6b8e90e27722a398dabbdc073608c89" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;std::vector&lt;<a class="el" href="class_g_classes_1_1_s_o_m_1_1_node_and_distance.html">SOM::NodeAndDistance</a>&gt; &gt;&amp; GClasses::GSelfOrganizingMap::sortedNeighbors </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return a sorted neighbor structure in which entry i is a list of the node indices sorted by their distance from node i. </p>

</div>
</div>
<a class="anchor" id="ae92a249040cdb82b70c0015d090e46a8"></a><!-- doxytag: member="GClasses::GSelfOrganizingMap::test" ref="ae92a249040cdb82b70c0015d090e46a8" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void GClasses::GSelfOrganizingMap::test </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Performs unit tests for this class. Throws an exception if there is a failure. </p>

</div>
</div>
<a class="anchor" id="af855289f024059225be522f13ecf2236"></a><!-- doxytag: member="GClasses::GSelfOrganizingMap::train" ref="af855289f024059225be522f13ecf2236" args="(GMatrix &amp;in)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void GClasses::GSelfOrganizingMap::train </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_g_classes_1_1_g_matrix.html">GMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>see comment on <a class="el" href="class_g_classes_1_1_g_incremental_transform.html#a778a3634b5276d72806c86351e5918c9" title="Trains the transform on the data in pData.">GIncrementalTransform::train(GMatrix&amp;)</a> </p>

<p>Implements <a class="el" href="class_g_classes_1_1_g_incremental_transform.html#a778a3634b5276d72806c86351e5918c9">GClasses::GIncrementalTransform</a>.</p>

</div>
</div>
<a class="anchor" id="ae2075b5f0be6c34ae200a899fc2bfc58"></a><!-- doxytag: member="GClasses::GSelfOrganizingMap::transform" ref="ae2075b5f0be6c34ae200a899fc2bfc58" args="(const double *pIn, double *pOut)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GClasses::GSelfOrganizingMap::transform </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>pIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>pOut</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Transform the given vector from input coordinates to map coordinates by finding the best match among the nodes. </p>
<p>see comment on <a class="el" href="class_g_classes_1_1_g_incremental_transform.html" title="This is the base class of algorithms that can transform data one row at a time without supervision...">GIncrementalTransform</a>::(const double*, double*) </p>

<p>Implements <a class="el" href="class_g_classes_1_1_g_incremental_transform.html#a093147212d83f1cc420577e753093552">GClasses::GIncrementalTransform</a>.</p>

</div>
</div>
<a class="anchor" id="a8ca2c02867c1e10f8c99398f42e61995"></a><!-- doxytag: member="GClasses::GSelfOrganizingMap::weightDistance" ref="a8ca2c02867c1e10f8c99398f42e61995" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_g_classes_1_1_g_distance_metric.html">GDistanceMetric</a>* GClasses::GSelfOrganizingMap::weightDistance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Inspector for the distance metric used in input space, that is, between an input point and a weight for determining the winner. </p>

</div>
</div>
<hr/><h2>Friends And Related Function Documentation</h2>
<a class="anchor" id="a59a98affa39a0ef9fd9323cdd8565820"></a><!-- doxytag: member="GClasses::GSelfOrganizingMap::SOM::TrainingAlgorithm" ref="a59a98affa39a0ef9fd9323cdd8565820" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="class_g_classes_1_1_s_o_m_1_1_training_algorithm.html">SOM::TrainingAlgorithm</a><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="a2ce580e1ed6dd45f8a333fde26ec2568"></a><!-- doxytag: member="GClasses::GSelfOrganizingMap::m_nInputDims" ref="a2ce580e1ed6dd45f8a333fde26ec2568" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="class_g_classes_1_1_g_self_organizing_map.html#a2ce580e1ed6dd45f8a333fde26ec2568">GClasses::GSelfOrganizingMap::m_nInputDims</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Number of input dimensions. </p>

</div>
</div>
<a class="anchor" id="a26a4c9b0d1831a7923971157b8d42f97"></a><!-- doxytag: member="GClasses::GSelfOrganizingMap::m_nodes" ref="a26a4c9b0d1831a7923971157b8d42f97" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="class_g_classes_1_1_s_o_m_1_1_node.html">SOM::Node</a>&gt; <a class="el" href="class_g_classes_1_1_g_self_organizing_map.html#a26a4c9b0d1831a7923971157b8d42f97">GClasses::GSelfOrganizingMap::m_nodes</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The nodes in the map. Do not change the order of nodes once sortedNeighbors has been created unless you also invalidate sortedNeighbors. Remember to call m_pWeightDistance-&gt;init if you change the number of weights. </p>

</div>
</div>
<a class="anchor" id="af0d0e2da0960b03be2c3a1ed723e8c03"></a><!-- doxytag: member="GClasses::GSelfOrganizingMap::m_outputAxes" ref="af0d0e2da0960b03be2c3a1ed723e8c03" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;double&gt; <a class="el" href="class_g_classes_1_1_g_self_organizing_map.html#af0d0e2da0960b03be2c3a1ed723e8c03">GClasses::GSelfOrganizingMap::m_outputAxes</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Vector containing the maximum number in each output axis - so axis #0 would have a range 0..m_vOutputAxes[0]. Remember to call m_pNodeDistance-&gt;init whenever you change the number of output axes. </p>

</div>
</div>
<a class="anchor" id="a372c06cafea1c364c891042d43576ca4"></a><!-- doxytag: member="GClasses::GSelfOrganizingMap::m_pNodeDistance" ref="a372c06cafea1c364c891042d43576ca4" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_g_classes_1_1_g_distance_metric.html">GDistanceMetric</a>* <a class="el" href="class_g_classes_1_1_g_self_organizing_map.html#a372c06cafea1c364c891042d43576ca4">GClasses::GSelfOrganizingMap::m_pNodeDistance</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The distance function to use when calculating the distance between nodes in the map. If you change this, remember to invalidate the neighbor structure. - owned by this object. Remember to call init whenever you change the number of output axes. </p>

</div>
</div>
<a class="anchor" id="a381ba98aa852e1b82518e771ce863919"></a><!-- doxytag: member="GClasses::GSelfOrganizingMap::m_pTrainer" ref="a381ba98aa852e1b82518e771ce863919" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_g_classes_1_1_s_o_m_1_1_training_algorithm.html">SOM::TrainingAlgorithm</a>* <a class="el" href="class_g_classes_1_1_g_self_organizing_map.html#a381ba98aa852e1b82518e771ce863919">GClasses::GSelfOrganizingMap::m_pTrainer</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The algorithm to be used to train this map on the next call to train. This object owns the training algorithm and is responsable for deleting it. </p>

</div>
</div>
<a class="anchor" id="aa814a1e3bebe5e6941d8163a29eb0013"></a><!-- doxytag: member="GClasses::GSelfOrganizingMap::m_pWeightDistance" ref="aa814a1e3bebe5e6941d8163a29eb0013" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_g_classes_1_1_g_distance_metric.html">GDistanceMetric</a>* <a class="el" href="class_g_classes_1_1_g_self_organizing_map.html#aa814a1e3bebe5e6941d8163a29eb0013">GClasses::GSelfOrganizingMap::m_pWeightDistance</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The distance function to use when finding the closest weight to a given input point - owned by this object. Remember to call init on this whenever you change the number of weights. </p>

</div>
</div>
<a class="anchor" id="a974743eef82cdfbec2590539746635b7"></a><!-- doxytag: member="GClasses::GSelfOrganizingMap::m_sortedNeighbors" ref="a974743eef82cdfbec2590539746635b7" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;<a class="el" href="class_g_classes_1_1_s_o_m_1_1_node_and_distance.html">SOM::NodeAndDistance</a>&gt; &gt; <a class="el" href="class_g_classes_1_1_g_self_organizing_map.html#a974743eef82cdfbec2590539746635b7">GClasses::GSelfOrganizingMap::m_sortedNeighbors</a><code> [mutable, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Each entry sortedNeighbors[i] contains a vector of all the other nodes sorted by their distance from i in outputSpace. </p>

</div>
</div>
<a class="anchor" id="a3f4f5265f36dac5f6500891968887bb6"></a><!-- doxytag: member="GClasses::GSelfOrganizingMap::m_sortedNeighborsIsValid" ref="a3f4f5265f36dac5f6500891968887bb6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_g_classes_1_1_g_self_organizing_map.html#a3f4f5265f36dac5f6500891968887bb6">GClasses::GSelfOrganizingMap::m_sortedNeighborsIsValid</a><code> [mutable, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
</div>
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="namespace_g_classes.html">GClasses</a>      </li>
      <li class="navelem"><a class="el" href="class_g_classes_1_1_g_self_organizing_map.html">GSelfOrganizingMap</a>      </li>
      <li class="footer">Generated on Mon Dec 5 2011 14:19:03 for GClasses by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.3 </li>
    </ul>
  </div>

</body>
</html>
