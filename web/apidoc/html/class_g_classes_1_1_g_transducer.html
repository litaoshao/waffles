<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>GClasses: GClasses::GTransducer Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript">
$(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.3 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">GClasses</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('class_g_classes_1_1_g_transducer.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a>  </div>
  <div class="headertitle">
<h1>GClasses::GTransducer Class Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="GClasses::GTransducer" -->
<p>This is the base class of supervised learning algorithms (that may or may not have an internal model allowing them to generalize rows that were not available at training time). Note that the literature typically refers to supervised learning algorithms that can't generalize (because they lack an internal hypothesis model) as "Semi-supervised". (You cannot generalize with a semi-supervised algorithm--you have to train again with the new rows.)  
<a href="#_details">More...</a></p>

<p><code>#include &lt;GLearner.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for GClasses::GTransducer:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_g_classes_1_1_g_transducer.png" usemap="#GClasses::GTransducer_map" alt=""/>
  <map id="GClasses::GTransducer_map" name="GClasses::GTransducer_map">
<area href="class_g_classes_1_1_g_agglomerative_transducer.html" alt="GClasses::GAgglomerativeTransducer" shape="rect" coords="0,56,226,80"/>
<area href="class_g_classes_1_1_g_graph_cut_transducer.html" alt="GClasses::GGraphCutTransducer" shape="rect" coords="236,56,462,80"/>
<area href="class_g_classes_1_1_g_neighbor_transducer.html" alt="GClasses::GNeighborTransducer" shape="rect" coords="472,56,698,80"/>
<area href="class_g_classes_1_1_g_supervised_learner.html" alt="GClasses::GSupervisedLearner" shape="rect" coords="708,56,934,80"/>
<area href="class_g_classes_1_1_g_baseline_learner.html" alt="GClasses::GBaselineLearner" shape="rect" coords="944,112,1170,136"/>
<area href="class_g_classes_1_1_g_bucket.html" alt="GClasses::GBucket" shape="rect" coords="944,168,1170,192"/>
<area href="class_g_classes_1_1_g_decision_tree.html" alt="GClasses::GDecisionTree" shape="rect" coords="944,224,1170,248"/>
<area href="class_g_classes_1_1_g_ensemble.html" alt="GClasses::GEnsemble" shape="rect" coords="944,280,1170,304"/>
<area href="class_g_classes_1_1_g_identity_function.html" alt="GClasses::GIdentityFunction" shape="rect" coords="944,336,1170,360"/>
<area href="class_g_classes_1_1_g_incremental_learner.html" alt="GClasses::GIncrementalLearner" shape="rect" coords="944,392,1170,416"/>
<area href="class_g_classes_1_1_g_linear_regressor.html" alt="GClasses::GLinearRegressor" shape="rect" coords="944,448,1170,472"/>
<area href="class_g_classes_1_1_g_mean_margins_tree.html" alt="GClasses::GMeanMarginsTree" shape="rect" coords="944,504,1170,528"/>
<area href="class_g_classes_1_1_g_polynomial.html" alt="GClasses::GPolynomial" shape="rect" coords="944,560,1170,584"/>
<area href="class_g_classes_1_1_g_random_forest.html" alt="GClasses::GRandomForest" shape="rect" coords="944,616,1170,640"/>
<area href="class_g_classes_1_1_g_wag.html" alt="GClasses::GWag" shape="rect" coords="944,672,1170,696"/>
</map>
 </div></div>

<p><a href="class_g_classes_1_1_g_transducer-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_transducer.html#a67fd909f16e329a2825977d805f39638">GTransducer</a> (<a class="el" href="class_g_classes_1_1_g_rand.html">GRand</a> &amp;rand)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_transducer.html#ae77843e6a0cdbc0fa8c840e64b3efefa">~GTransducer</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_transducer.html#a35df6d2e140eb0d8625dd30be6b2fbcd">canGeneralize</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns false because semi-supervised learners have no internal model, so they can't evaluate previously unseen rows.  <a href="#a35df6d2e140eb0d8625dd30be6b2fbcd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_transducer.html#aa57bff4886e0fd85f946e8f627798a0b">canTrainIncrementally</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns false because semi-supervised learners cannot be trained incrementally.  <a href="#aa57bff4886e0fd85f946e8f627798a0b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_g_classes_1_1_g_matrix.html">GMatrix</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_transducer.html#a708e5f61de9a505c86f28331eb58a376">transduce</a> (<a class="el" href="class_g_classes_1_1_g_matrix.html">GMatrix</a> &amp;features1, <a class="el" href="class_g_classes_1_1_g_matrix.html">GMatrix</a> &amp;labels1, <a class="el" href="class_g_classes_1_1_g_matrix.html">GMatrix</a> &amp;features2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Predicts a set of labels to correspond with features2, such that these labels will be consistent with the patterns exhibited by features1 and labels1.  <a href="#a708e5f61de9a505c86f28331eb58a376"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_transducer.html#adbb4ac473432a5d38fa0504e3b56f049">trainAndTest</a> (<a class="el" href="class_g_classes_1_1_g_matrix.html">GMatrix</a> &amp;trainFeatures, <a class="el" href="class_g_classes_1_1_g_matrix.html">GMatrix</a> &amp;trainLabels, <a class="el" href="class_g_classes_1_1_g_matrix.html">GMatrix</a> &amp;testFeatures, <a class="el" href="class_g_classes_1_1_g_matrix.html">GMatrix</a> &amp;testLabels, double *pOutResults, std::vector&lt; <a class="el" href="class_g_classes_1_1_g_matrix.html">GMatrix</a> * &gt; *pNominalLabelStats=NULL)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Trains and tests this learner. pOutResults should have an element for each label dim.  <a href="#adbb4ac473432a5d38fa0504e3b56f049"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_g_classes_1_1_g_matrix.html">GMatrix</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_transducer.html#a77955a03f1cdaf59accb514c5213d158">crossValidate</a> (<a class="el" href="class_g_classes_1_1_g_matrix.html">GMatrix</a> &amp;features, <a class="el" href="class_g_classes_1_1_g_matrix.html">GMatrix</a> &amp;labels, size_t nFolds, <a class="el" href="namespace_g_classes.html#af7fa238518e08efc8a977ddf1b35fd59">RepValidateCallback</a> pCB=NULL, size_t nRep=0, void *pThis=NULL)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform n-fold cross validation on pData. Uses trainAndTest for each fold. pCB is an optional callback method for reporting intermediate stats. It can be NULL if you don't want intermediate reporting. nRep is just the rep number that will be passed to the callback. pThis is just a pointer that will be passed to the callback for you to use however you want. It doesn't affect this method. The results of each fold is returned in a dataset.  <a href="#a77955a03f1cdaf59accb514c5213d158"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_g_classes_1_1_g_matrix.html">GMatrix</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_transducer.html#a6a4d522c96d6c278b30c3de6e8879f7c">repValidate</a> (<a class="el" href="class_g_classes_1_1_g_matrix.html">GMatrix</a> &amp;features, <a class="el" href="class_g_classes_1_1_g_matrix.html">GMatrix</a> &amp;labels, size_t reps, size_t nFolds, <a class="el" href="namespace_g_classes.html#af7fa238518e08efc8a977ddf1b35fd59">RepValidateCallback</a> pCB=NULL, void *pThis=NULL)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform cross validation "nReps" times and return the average score. (5 reps with 2 folds is preferred over 10-fold cross validation because it yields less type 1 error.) pCB is an optional callback method for reporting intermediate stats It can be NULL if you don't want intermediate reporting. pThis is just a pointer that will be passed to the callback for you to use however you want. It doesn't affect this method. The results of each fold is returned in a dataset.  <a href="#a6a4d522c96d6c278b30c3de6e8879f7c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_transducer.html#a5d017dc7b13e81f4916357b098640047">heuristicValidate</a> (<a class="el" href="class_g_classes_1_1_g_matrix.html">GMatrix</a> &amp;features, <a class="el" href="class_g_classes_1_1_g_matrix.html">GMatrix</a> &amp;labels)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This performs two-fold cross-validation on a shuffled non-uniform split of the data, and returns an error value that represents the results of all labels combined.  <a href="#a5d017dc7b13e81f4916357b098640047"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_g_classes_1_1_g_rand.html">GRand</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_transducer.html#a75222cbff9cc5e58cb6605a05872215d">rand</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the random number generator associated with this object.  <a href="#a75222cbff9cc5e58cb6605a05872215d"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_g_classes_1_1_g_matrix.html">GMatrix</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_transducer.html#ace338b47883c78de8802029afe252f60">transduceInner</a> (<a class="el" href="class_g_classes_1_1_g_matrix.html">GMatrix</a> &amp;features1, <a class="el" href="class_g_classes_1_1_g_matrix.html">GMatrix</a> &amp;labels1, <a class="el" href="class_g_classes_1_1_g_matrix.html">GMatrix</a> &amp;features2)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the algorithm's implementation of transduction. (It is called by the transduce method.)  <a href="#ace338b47883c78de8802029afe252f60"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_transducer.html#a07c1bac223ab1fc1eb369a10313688de">canImplicitlyHandleNominalFeatures</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true iff this algorithm can implicitly handle nominal features. If it cannot, then the <a class="el" href="class_g_classes_1_1_g_nominal_to_cat.html" title="This is sort-of the opposite of discretize. It converts each nominal attribute to a categorical distr...">GNominalToCat</a> transform will be used to convert nominal features to continuous values before passing them to it.  <a href="#a07c1bac223ab1fc1eb369a10313688de"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_transducer.html#a9aae27544b0e0dd12c9de27d294debcd">canImplicitlyHandleContinuousFeatures</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true iff this algorithm can implicitly handle continuous features. If it cannot, then the <a class="el" href="class_g_classes_1_1_g_discretize.html" title="This transform uses buckets to convert continuous data into discrete data. It is common to use GFilte...">GDiscretize</a> transform will be used to convert continuous features to nominal values before passing them to it.  <a href="#a9aae27544b0e0dd12c9de27d294debcd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_transducer.html#ac7b2855e39b2897801641b42870dee20">supportedFeatureRange</a> (double *pOutMin, double *pOutMax)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this algorithm supports any feature value, or if it does not implicitly handle continuous features. If a limited range of continuous values is supported, returns false and sets pOutMin and pOutMax to specify the range.  <a href="#ac7b2855e39b2897801641b42870dee20"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_transducer.html#ad4557a177f7d0c92f26d40c102418e90">canImplicitlyHandleMissingFeatures</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true iff this algorithm supports missing feature values. If it cannot, then an imputation filter will be used to predict missing values before any feature-vectors are passed to the algorithm.  <a href="#ad4557a177f7d0c92f26d40c102418e90"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_transducer.html#a5b07f5b4775bb69cb982d64f0b75c430">canImplicitlyHandleNominalLabels</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true iff this algorithm can implicitly handle nominal labels (a.k.a. classification). If it cannot, then the <a class="el" href="class_g_classes_1_1_g_nominal_to_cat.html" title="This is sort-of the opposite of discretize. It converts each nominal attribute to a categorical distr...">GNominalToCat</a> transform will be used during training to convert nominal labels to continuous values, and to convert categorical predictions back to nominal labels.  <a href="#a5b07f5b4775bb69cb982d64f0b75c430"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_transducer.html#a765a402b9f356b530b16b7b195f0923c">canImplicitlyHandleContinuousLabels</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true iff this algorithm can implicitly handle continuous labels (a.k.a. regression). If it cannot, then the <a class="el" href="class_g_classes_1_1_g_discretize.html" title="This transform uses buckets to convert continuous data into discrete data. It is common to use GFilte...">GDiscretize</a> transform will be used during training to convert nominal labels to continuous values, and to convert nominal predictions back to continuous labels.  <a href="#a765a402b9f356b530b16b7b195f0923c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_transducer.html#a477f7104321653ab2a089f273c5002ee">supportedLabelRange</a> (double *pOutMin, double *pOutMax)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this algorithm supports any label value, or if it does not implicitly handle continuous labels. If a limited range of continuous values is supported, returns false and sets pOutMin and pOutMax to specify the range.  <a href="#a477f7104321653ab2a089f273c5002ee"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_g_classes_1_1_g_rand.html">GRand</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_transducer.html#a992a4009e292aba4abf19c9e69c00aab">m_rand</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>This is the base class of supervised learning algorithms (that may or may not have an internal model allowing them to generalize rows that were not available at training time). Note that the literature typically refers to supervised learning algorithms that can't generalize (because they lack an internal hypothesis model) as "Semi-supervised". (You cannot generalize with a semi-supervised algorithm--you have to train again with the new rows.) </p>
</div><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a67fd909f16e329a2825977d805f39638"></a><!-- doxytag: member="GClasses::GTransducer::GTransducer" ref="a67fd909f16e329a2825977d805f39638" args="(GRand &amp;rand)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GClasses::GTransducer::GTransducer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_g_classes_1_1_g_rand.html">GRand</a> &amp;&#160;</td>
          <td class="paramname"><em>rand</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ae77843e6a0cdbc0fa8c840e64b3efefa"></a><!-- doxytag: member="GClasses::GTransducer::~GTransducer" ref="ae77843e6a0cdbc0fa8c840e64b3efefa" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual GClasses::GTransducer::~GTransducer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a35df6d2e140eb0d8625dd30be6b2fbcd"></a><!-- doxytag: member="GClasses::GTransducer::canGeneralize" ref="a35df6d2e140eb0d8625dd30be6b2fbcd" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool GClasses::GTransducer::canGeneralize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns false because semi-supervised learners have no internal model, so they can't evaluate previously unseen rows. </p>

<p>Reimplemented in <a class="el" href="class_g_classes_1_1_g_supervised_learner.html#ab1e4fe0616f81d4df99f71a618c64f75">GClasses::GSupervisedLearner</a>.</p>

</div>
</div>
<a class="anchor" id="a9aae27544b0e0dd12c9de27d294debcd"></a><!-- doxytag: member="GClasses::GTransducer::canImplicitlyHandleContinuousFeatures" ref="a9aae27544b0e0dd12c9de27d294debcd" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool GClasses::GTransducer::canImplicitlyHandleContinuousFeatures </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline, protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns true iff this algorithm can implicitly handle continuous features. If it cannot, then the <a class="el" href="class_g_classes_1_1_g_discretize.html" title="This transform uses buckets to convert continuous data into discrete data. It is common to use GFilte...">GDiscretize</a> transform will be used to convert continuous features to nominal values before passing them to it. </p>

<p>Reimplemented in <a class="el" href="class_g_classes_1_1_g_naive_bayes.html#a1c93c7e47abe538d1b696e90647b2655">GClasses::GNaiveBayes</a>.</p>

</div>
</div>
<a class="anchor" id="a765a402b9f356b530b16b7b195f0923c"></a><!-- doxytag: member="GClasses::GTransducer::canImplicitlyHandleContinuousLabels" ref="a765a402b9f356b530b16b7b195f0923c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool GClasses::GTransducer::canImplicitlyHandleContinuousLabels </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline, protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns true iff this algorithm can implicitly handle continuous labels (a.k.a. regression). If it cannot, then the <a class="el" href="class_g_classes_1_1_g_discretize.html" title="This transform uses buckets to convert continuous data into discrete data. It is common to use GFilte...">GDiscretize</a> transform will be used during training to convert nominal labels to continuous values, and to convert nominal predictions back to continuous labels. </p>

<p>Reimplemented in <a class="el" href="class_g_classes_1_1_g_agglomerative_transducer.html#a8dde912f45dc145e57fc844e9aecf157">GClasses::GAgglomerativeTransducer</a>, <a class="el" href="class_g_classes_1_1_g_graph_cut_transducer.html#a57f44773ec8db5e3af6f1a25086b7760">GClasses::GGraphCutTransducer</a>, <a class="el" href="class_g_classes_1_1_g_bayesian_model_averaging.html#a048aef66d779f914aae1e7836c216e3b">GClasses::GBayesianModelAveraging</a>, <a class="el" href="class_g_classes_1_1_g_bayesian_model_combination.html#ac9467b1069d4c9dcdb3b636f0aa281c3">GClasses::GBayesianModelCombination</a>, <a class="el" href="class_g_classes_1_1_g_ada_boost.html#a7400fe19da0f7c91f5aefb61cbc81012">GClasses::GAdaBoost</a>, <a class="el" href="class_g_classes_1_1_g_neighbor_transducer.html#aa138ba17df36d54a7b598451067008af">GClasses::GNeighborTransducer</a>, and <a class="el" href="class_g_classes_1_1_g_naive_bayes.html#afd5b89b265810f26931f4ac39f3f4c32">GClasses::GNaiveBayes</a>.</p>

</div>
</div>
<a class="anchor" id="ad4557a177f7d0c92f26d40c102418e90"></a><!-- doxytag: member="GClasses::GTransducer::canImplicitlyHandleMissingFeatures" ref="ad4557a177f7d0c92f26d40c102418e90" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool GClasses::GTransducer::canImplicitlyHandleMissingFeatures </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline, protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns true iff this algorithm supports missing feature values. If it cannot, then an imputation filter will be used to predict missing values before any feature-vectors are passed to the algorithm. </p>

<p>Reimplemented in <a class="el" href="class_g_classes_1_1_g_k_n_n.html#a81ef14ce3e52b171400e0cd9ea298193">GClasses::GKNN</a>, and <a class="el" href="class_g_classes_1_1_g_neural_net.html#ae82282648edc1a9a16f87e7b1ecadaa5">GClasses::GNeuralNet</a>.</p>

</div>
</div>
<a class="anchor" id="a07c1bac223ab1fc1eb369a10313688de"></a><!-- doxytag: member="GClasses::GTransducer::canImplicitlyHandleNominalFeatures" ref="a07c1bac223ab1fc1eb369a10313688de" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool GClasses::GTransducer::canImplicitlyHandleNominalFeatures </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline, protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns true iff this algorithm can implicitly handle nominal features. If it cannot, then the <a class="el" href="class_g_classes_1_1_g_nominal_to_cat.html" title="This is sort-of the opposite of discretize. It converts each nominal attribute to a categorical distr...">GNominalToCat</a> transform will be used to convert nominal features to continuous values before passing them to it. </p>

<p>Reimplemented in <a class="el" href="class_g_classes_1_1_g_mean_margins_tree.html#aaad3686dd9cbeafb9351af7a282f048f">GClasses::GMeanMarginsTree</a>, <a class="el" href="class_g_classes_1_1_g_wag.html#aa1b788f038144721e312442fd20dcebe">GClasses::GWag</a>, <a class="el" href="class_g_classes_1_1_g_neighbor_transducer.html#adf96d0f28a797280d991330e97be711e">GClasses::GNeighborTransducer</a>, <a class="el" href="class_g_classes_1_1_g_instance_table.html#a65177ebca8c9b4ae0b1db75f3f9379a3">GClasses::GInstanceTable</a>, <a class="el" href="class_g_classes_1_1_g_linear_regressor.html#a0db67ccfe677bbf723fff955479d9c2b">GClasses::GLinearRegressor</a>, <a class="el" href="class_g_classes_1_1_g_naive_instance.html#a9b3018959f6f4c589359a806296401fc">GClasses::GNaiveInstance</a>, <a class="el" href="class_g_classes_1_1_g_neural_net.html#a9507ad0abba2a4baafecc64f56422301">GClasses::GNeuralNet</a>, and <a class="el" href="class_g_classes_1_1_g_polynomial.html#a1f2672db11ddb0a323275f760e7e00c3">GClasses::GPolynomial</a>.</p>

</div>
</div>
<a class="anchor" id="a5b07f5b4775bb69cb982d64f0b75c430"></a><!-- doxytag: member="GClasses::GTransducer::canImplicitlyHandleNominalLabels" ref="a5b07f5b4775bb69cb982d64f0b75c430" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool GClasses::GTransducer::canImplicitlyHandleNominalLabels </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline, protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns true iff this algorithm can implicitly handle nominal labels (a.k.a. classification). If it cannot, then the <a class="el" href="class_g_classes_1_1_g_nominal_to_cat.html" title="This is sort-of the opposite of discretize. It converts each nominal attribute to a categorical distr...">GNominalToCat</a> transform will be used during training to convert nominal labels to continuous values, and to convert categorical predictions back to nominal labels. </p>

<p>Reimplemented in <a class="el" href="class_g_classes_1_1_g_mean_margins_tree.html#a0be25f0277cf3660e0c58b2d1ddd3226">GClasses::GMeanMarginsTree</a>, <a class="el" href="class_g_classes_1_1_g_wag.html#a1fc2c2f953aa19b30f3956bfd35373bc">GClasses::GWag</a>, <a class="el" href="class_g_classes_1_1_g_linear_regressor.html#ae748055c7d2f6b3098f066a000706ae2">GClasses::GLinearRegressor</a>, <a class="el" href="class_g_classes_1_1_g_naive_instance.html#a69718c31985abc8cf52e41c87f895eaf">GClasses::GNaiveInstance</a>, <a class="el" href="class_g_classes_1_1_g_neural_net.html#a6528bdaa8bfdfc8174237791f3a54238">GClasses::GNeuralNet</a>, and <a class="el" href="class_g_classes_1_1_g_polynomial.html#aab79b2947209f5b471170eaab881e440">GClasses::GPolynomial</a>.</p>

</div>
</div>
<a class="anchor" id="aa57bff4886e0fd85f946e8f627798a0b"></a><!-- doxytag: member="GClasses::GTransducer::canTrainIncrementally" ref="aa57bff4886e0fd85f946e8f627798a0b" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool GClasses::GTransducer::canTrainIncrementally </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns false because semi-supervised learners cannot be trained incrementally. </p>

<p>Reimplemented in <a class="el" href="class_g_classes_1_1_g_incremental_learner.html#a83151d491b3016b3c05a71a13736209e">GClasses::GIncrementalLearner</a>.</p>

</div>
</div>
<a class="anchor" id="a77955a03f1cdaf59accb514c5213d158"></a><!-- doxytag: member="GClasses::GTransducer::crossValidate" ref="a77955a03f1cdaf59accb514c5213d158" args="(GMatrix &amp;features, GMatrix &amp;labels, size_t nFolds, RepValidateCallback pCB=NULL, size_t nRep=0, void *pThis=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_g_classes_1_1_g_matrix.html">GMatrix</a>* GClasses::GTransducer::crossValidate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_g_classes_1_1_g_matrix.html">GMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>features</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_g_classes_1_1_g_matrix.html">GMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>labels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nFolds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_g_classes.html#af7fa238518e08efc8a977ddf1b35fd59">RepValidateCallback</a>&#160;</td>
          <td class="paramname"><em>pCB</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nRep</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pThis</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Perform n-fold cross validation on pData. Uses trainAndTest for each fold. pCB is an optional callback method for reporting intermediate stats. It can be NULL if you don't want intermediate reporting. nRep is just the rep number that will be passed to the callback. pThis is just a pointer that will be passed to the callback for you to use however you want. It doesn't affect this method. The results of each fold is returned in a dataset. </p>

</div>
</div>
<a class="anchor" id="a5d017dc7b13e81f4916357b098640047"></a><!-- doxytag: member="GClasses::GTransducer::heuristicValidate" ref="a5d017dc7b13e81f4916357b098640047" args="(GMatrix &amp;features, GMatrix &amp;labels)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double GClasses::GTransducer::heuristicValidate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_g_classes_1_1_g_matrix.html">GMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>features</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_g_classes_1_1_g_matrix.html">GMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>labels</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This performs two-fold cross-validation on a shuffled non-uniform split of the data, and returns an error value that represents the results of all labels combined. </p>

</div>
</div>
<a class="anchor" id="a75222cbff9cc5e58cb6605a05872215d"></a><!-- doxytag: member="GClasses::GTransducer::rand" ref="a75222cbff9cc5e58cb6605a05872215d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_g_classes_1_1_g_rand.html">GRand</a>&amp; GClasses::GTransducer::rand </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a reference to the random number generator associated with this object. </p>

</div>
</div>
<a class="anchor" id="a6a4d522c96d6c278b30c3de6e8879f7c"></a><!-- doxytag: member="GClasses::GTransducer::repValidate" ref="a6a4d522c96d6c278b30c3de6e8879f7c" args="(GMatrix &amp;features, GMatrix &amp;labels, size_t reps, size_t nFolds, RepValidateCallback pCB=NULL, void *pThis=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_g_classes_1_1_g_matrix.html">GMatrix</a>* GClasses::GTransducer::repValidate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_g_classes_1_1_g_matrix.html">GMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>features</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_g_classes_1_1_g_matrix.html">GMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>labels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>reps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nFolds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_g_classes.html#af7fa238518e08efc8a977ddf1b35fd59">RepValidateCallback</a>&#160;</td>
          <td class="paramname"><em>pCB</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pThis</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Perform cross validation "nReps" times and return the average score. (5 reps with 2 folds is preferred over 10-fold cross validation because it yields less type 1 error.) pCB is an optional callback method for reporting intermediate stats It can be NULL if you don't want intermediate reporting. pThis is just a pointer that will be passed to the callback for you to use however you want. It doesn't affect this method. The results of each fold is returned in a dataset. </p>

</div>
</div>
<a class="anchor" id="ac7b2855e39b2897801641b42870dee20"></a><!-- doxytag: member="GClasses::GTransducer::supportedFeatureRange" ref="ac7b2855e39b2897801641b42870dee20" args="(double *pOutMin, double *pOutMax)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool GClasses::GTransducer::supportedFeatureRange </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>pOutMin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>pOutMax</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns true if this algorithm supports any feature value, or if it does not implicitly handle continuous features. If a limited range of continuous values is supported, returns false and sets pOutMin and pOutMax to specify the range. </p>

<p>Reimplemented in <a class="el" href="class_g_classes_1_1_g_neural_net.html#a18ca749935c5a40ce3a9e9ae138196ff">GClasses::GNeuralNet</a>.</p>

</div>
</div>
<a class="anchor" id="a477f7104321653ab2a089f273c5002ee"></a><!-- doxytag: member="GClasses::GTransducer::supportedLabelRange" ref="a477f7104321653ab2a089f273c5002ee" args="(double *pOutMin, double *pOutMax)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool GClasses::GTransducer::supportedLabelRange </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>pOutMin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>pOutMax</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns true if this algorithm supports any label value, or if it does not implicitly handle continuous labels. If a limited range of continuous values is supported, returns false and sets pOutMin and pOutMax to specify the range. </p>

<p>Reimplemented in <a class="el" href="class_g_classes_1_1_g_neural_net.html#a5d699a8170b1c4bea6d2d1bbcc6d5395">GClasses::GNeuralNet</a>.</p>

</div>
</div>
<a class="anchor" id="adbb4ac473432a5d38fa0504e3b56f049"></a><!-- doxytag: member="GClasses::GTransducer::trainAndTest" ref="adbb4ac473432a5d38fa0504e3b56f049" args="(GMatrix &amp;trainFeatures, GMatrix &amp;trainLabels, GMatrix &amp;testFeatures, GMatrix &amp;testLabels, double *pOutResults, std::vector&lt; GMatrix * &gt; *pNominalLabelStats=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void GClasses::GTransducer::trainAndTest </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_g_classes_1_1_g_matrix.html">GMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>trainFeatures</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_g_classes_1_1_g_matrix.html">GMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>trainLabels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_g_classes_1_1_g_matrix.html">GMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>testFeatures</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_g_classes_1_1_g_matrix.html">GMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>testLabels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>pOutResults</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="class_g_classes_1_1_g_matrix.html">GMatrix</a> * &gt; *&#160;</td>
          <td class="paramname"><em>pNominalLabelStats</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Trains and tests this learner. pOutResults should have an element for each label dim. </p>

<p>Reimplemented in <a class="el" href="class_g_classes_1_1_g_supervised_learner.html#ad1708ae4609132dea558a5d7458e0b5a">GClasses::GSupervisedLearner</a>.</p>

</div>
</div>
<a class="anchor" id="a708e5f61de9a505c86f28331eb58a376"></a><!-- doxytag: member="GClasses::GTransducer::transduce" ref="a708e5f61de9a505c86f28331eb58a376" args="(GMatrix &amp;features1, GMatrix &amp;labels1, GMatrix &amp;features2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_g_classes_1_1_g_matrix.html">GMatrix</a>* GClasses::GTransducer::transduce </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_g_classes_1_1_g_matrix.html">GMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>features1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_g_classes_1_1_g_matrix.html">GMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>labels1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_g_classes_1_1_g_matrix.html">GMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>features2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Predicts a set of labels to correspond with features2, such that these labels will be consistent with the patterns exhibited by features1 and labels1. </p>

</div>
</div>
<a class="anchor" id="ace338b47883c78de8802029afe252f60"></a><!-- doxytag: member="GClasses::GTransducer::transduceInner" ref="ace338b47883c78de8802029afe252f60" args="(GMatrix &amp;features1, GMatrix &amp;labels1, GMatrix &amp;features2)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_g_classes_1_1_g_matrix.html">GMatrix</a>* GClasses::GTransducer::transduceInner </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_g_classes_1_1_g_matrix.html">GMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>features1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_g_classes_1_1_g_matrix.html">GMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>labels1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_g_classes_1_1_g_matrix.html">GMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>features2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected, pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This is the algorithm's implementation of transduction. (It is called by the transduce method.) </p>

<p>Implemented in <a class="el" href="class_g_classes_1_1_g_agglomerative_transducer.html#a58e422c869a0ac2fc2b3c630c0118750">GClasses::GAgglomerativeTransducer</a>, <a class="el" href="class_g_classes_1_1_g_graph_cut_transducer.html#a93130129349c05f9fba3af50471e8345">GClasses::GGraphCutTransducer</a>, <a class="el" href="class_g_classes_1_1_g_neighbor_transducer.html#a4dded2efe06c9bed6eb8628b4ff8b85f">GClasses::GNeighborTransducer</a>, and <a class="el" href="class_g_classes_1_1_g_supervised_learner.html#ac9d20a57948137cb4141b01e33b90184">GClasses::GSupervisedLearner</a>.</p>

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="a992a4009e292aba4abf19c9e69c00aab"></a><!-- doxytag: member="GClasses::GTransducer::m_rand" ref="a992a4009e292aba4abf19c9e69c00aab" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_g_classes_1_1_g_rand.html">GRand</a>&amp; <a class="el" href="class_g_classes_1_1_g_transducer.html#a992a4009e292aba4abf19c9e69c00aab">GClasses::GTransducer::m_rand</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
</div>
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="namespace_g_classes.html">GClasses</a>      </li>
      <li class="navelem"><a class="el" href="class_g_classes_1_1_g_transducer.html">GTransducer</a>      </li>
      <li class="footer">Generated on Mon Dec 5 2011 14:19:01 for GClasses by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.3 </li>
    </ul>
  </div>

</body>
</html>
