<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>GClasses: Class List</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript">
$(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.3 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">GClasses</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li class="current"><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('annotated.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<h1>Class List</h1>  </div>
</div>
<div class="contents">
<div class="textblock">Here are the classes, structs, unions and interfaces with brief descriptions:</div><table>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_array_holder.html">GClasses::ArrayHolder&lt; T &gt;</a></td><td class="indexvalue">Just like <a class="el" href="class_g_classes_1_1_holder.html" title="This class is very similar to the standard C++ class auto_ptr, except it throws an exception if you t...">Holder</a>, except for arrays </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_s_o_m_1_1_batch_training.html">GClasses::SOM::BatchTraining</a></td><td class="indexvalue">Implements the batch training algorithm for self-organizing maps as described in T. Kohonen "Self Organizing Maps" Third Edition, 2001, published by Springer </td></tr>
  <tr><td class="indexkey"><a class="el" href="struct_g_classes_1_1_complex_number.html">GClasses::ComplexNumber</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_s_o_m_1_1_dummy_training_algorithm.html">GClasses::SOM::DummyTrainingAlgorithm</a></td><td class="indexvalue">A training algorithm that throws an exception when train is called - stub for fully serializing training algorithms </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_file_holder.html">GClasses::FileHolder</a></td><td class="indexvalue">Closes a file when this object goes out of scope </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g2_d_region_graph.html">GClasses::G2DRegionGraph</a></td><td class="indexvalue">Implements a region adjacency graph for 2D images, and lets you merge similar regions to create a hierarchical breakdown of the image </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g3d_letter_maker.html">GClasses::G3dLetterMaker</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g3_d_matrix.html">GClasses::G3DMatrix</a></td><td class="indexvalue">Represents a 3x3 matrix </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g3_d_vector.html">GClasses::G3DVector</a></td><td class="indexvalue">Represents a 3D vector </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_action_path.html">GClasses::GActionPath</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_action_path_search.html">GClasses::GActionPathSearch</a></td><td class="indexvalue">This is the base class of search algorithms that can only perform a discreet set of actions (as opposed to jumping to anywhere in the search space), and seeks to minimize the error of a path of actions </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_action_path_state.html">GClasses::GActionPathState</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_activation_algebraic.html">GClasses::GActivationAlgebraic</a></td><td class="indexvalue">The hyperbolic tangent activation function </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_activation_arc_tan.html">GClasses::GActivationArcTan</a></td><td class="indexvalue">The arctan activation function </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_activation_bend.html">GClasses::GActivationBend</a></td><td class="indexvalue">This provides an alternative to using <a class="el" href="class_g_classes_1_1_g_activation_identity.html" title="Use this function when you do not want to squash the net. For example, using this activation function...">GActivationIdentity</a> on the output layer for regression problems. It may add more power because it is non-linear, but like the identity function, its co-domain is the same as its domain </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_activation_bi_dir.html">GClasses::GActivationBiDir</a></td><td class="indexvalue">This is an output-layer activation function shaped like a sigmoid, but with both a co-domain and domain that spans the continuous values </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_activation_function.html">GClasses::GActivationFunction</a></td><td class="indexvalue">The base class for activation functions. Typically, this are sigmoid-shaped functions used to "squash" the output of a network node. These are typically used in conjunction with the <a class="el" href="class_g_classes_1_1_g_neural_net.html" title="An artificial neural network.">GNeuralNet</a> class </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_activation_gaussian.html">GClasses::GActivationGaussian</a></td><td class="indexvalue">This is a simple Gaussian function </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_activation_identity.html">GClasses::GActivationIdentity</a></td><td class="indexvalue">Use this function when you do not want to squash the net. For example, using this activation function with a network that has no hidden layers makes a perceptron model. Also, it is common to use this activation function on the output layer for regression problems </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_activation_logistic.html">GClasses::GActivationLogistic</a></td><td class="indexvalue">The logistic activation function </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_activation_piecewise.html">GClasses::GActivationPiecewise</a></td><td class="indexvalue">This is an experimental activation function intended to reduce the required computation involved in inverting neural networks </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_activation_sinc.html">GClasses::GActivationSinc</a></td><td class="indexvalue">This is a canonical wavelet </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_activation_tan_h.html">GClasses::GActivationTanH</a></td><td class="indexvalue">The hyperbolic tangent activation function </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_ada_boost.html">GClasses::GAdaBoost</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_agent_action_iterator.html">GClasses::GAgentActionIterator</a></td><td class="indexvalue">Iterates through all the actions that are valid in the current state. If actions are continuous or very numerous, this should sample valid actions in a random order. The caller may decide that it has sampled enough at any time </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_agglomerative_clusterer.html">GClasses::GAgglomerativeClusterer</a></td><td class="indexvalue">This merges each cluster with its closest neighbor. (The distance between clusters is computed as the distance between the closest members of the clusters times (n^b), where n is the total number of points from both clusters, and b is a balancing factor </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_agglomerative_transducer.html">GClasses::GAgglomerativeTransducer</a></td><td class="indexvalue">This is a semi-supervised agglomerative clusterer. It can only handle one output, and it must be nominal. All inputs must be continuous. Also, it assumes that all output values are represented in the training set </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_annealing.html">GClasses::GAnnealing</a></td><td class="indexvalue">This algorithm tries the current direction and a slightly perturbed direction at each step. If the perturbed direction resulted in faster improvement, it becomes the new current direction. As long as the current direction yields improvement, it accelerates, otherwise it decelerates </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_app.html">GClasses::GApp</a></td><td class="indexvalue">Contains some generally useful functions for launching applications </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_arff_attribute.html">GClasses::GArffAttribute</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_arff_relation.html">GClasses::GArffRelation</a></td><td class="indexvalue">ARFF = Attribute-Relation File Format. This stores richer information than <a class="el" href="class_g_classes_1_1_g_relation.html" title="Holds the metadata for a dataset, including which attributes are continuous or nominal, and how many values each nominal attribute supports.">GRelation</a>. This includes a name, a name for each attribute, and names for each supported nominal value </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_arg_reader.html">GClasses::GArgReader</a></td><td class="indexvalue">Parses command-line args and provides methods to conveniently process them </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_atomic_cycle_finder.html">GClasses::GAtomicCycleFinder</a></td><td class="indexvalue">This finds all of the atomic cycles (cycles that cannot be divided into two smaller cycles) in a graph </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_attribute_selector.html">GClasses::GAttributeSelector</a></td><td class="indexvalue">Generates subsets of data that contain only the most relevant features for predicting the labels. The train method of this class produces a ranked ordering of the feature attributes by training a single-layer neural network, and deselecting the weakest attribute until all attributes have been deselected. The transform method uses only the highest-ranked attributes </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_s_o_m_1_1_gaussian_window_function.html">GClasses::SOM::GaussianWindowFunction</a></td><td class="indexvalue">Uses a unit-height, zero-mean Gaussian weighting with the width as sigma truncated to 0 at 5 standard deviations </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_back_prop.html">GClasses::GBackProp</a></td><td class="indexvalue">This class performs backpropagation on a neural network. (I made it a separate class because it is only needed during training. There is no reason to waste this space after training is complete, or if you choose to use a different technique to train the neural network.) </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_back_prop_layer.html">GClasses::GBackPropLayer</a></td><td class="indexvalue">An internal class used by <a class="el" href="class_g_classes_1_1_g_back_prop.html" title="This class performs backpropagation on a neural network. (I made it a separate class because it is on...">GBackProp</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_back_prop_neuron.html">GClasses::GBackPropNeuron</a></td><td class="indexvalue">An internal class used by <a class="el" href="class_g_classes_1_1_g_back_prop.html" title="This class performs backpropagation on a neural network. (I made it a separate class because it is on...">GBackProp</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_back_prop_weight.html">GClasses::GBackPropWeight</a></td><td class="indexvalue">An internal class used by <a class="el" href="class_g_classes_1_1_g_back_prop.html" title="This class performs backpropagation on a neural network. (I made it a separate class because it is on...">GBackProp</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_bag.html">GClasses::GBag</a></td><td class="indexvalue">BAG stands for bootstrap aggregator. It represents an ensemble of voting modelers. Each model is trained with a slightly different training set, which is produced by drawing randomly from the original training set with replacement until we have a new training set of the same size. Each model is given equal weight in the vote </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_bag_of_recommenders.html">GClasses::GBagOfRecommenders</a></td><td class="indexvalue">This class performs bootstrap aggregation with collaborative filtering algorithms </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_baseline_learner.html">GClasses::GBaselineLearner</a></td><td class="indexvalue">Always outputs the label mean (for continuous labels) and the most common class (for nominal labels) </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_baseline_recommender.html">GClasses::GBaselineRecommender</a></td><td class="indexvalue">This class always predicts the average rating for each item, no matter to whom it is making the recommendation. The purpose of this algorithm is to serve as a baseline for comparison </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_bayesian_model_averaging.html">GClasses::GBayesianModelAveraging</a></td><td class="indexvalue">This is an ensemble that uses the bagging approach for training, and Bayesian Model Averaging to combine the models. That is, it trains each model with data drawn randomly with replacement from the original training data. It combines the models with weights proporitional to their likelihood as computed using Bayes' law </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_bayesian_model_combination.html">GClasses::GBayesianModelCombination</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_bayesian_network_child_iterator.html">GClasses::GBayesianNetworkChildIterator</a></td><td class="indexvalue">Iterates through all the children of the specified node in a Bayesian network </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_bayesian_network_node.html">GClasses::GBayesianNetworkNode</a></td><td class="indexvalue">This is the base class for all nodes in a Bayesian network. Classes that inherit from this class must implement three pure virtual methods. Note that the <a class="el" href="class_g_classes_1_1_g_univariate_distribution.html" title="This is the base class for univariate distributions.">GUnivariateDistribution</a> class has an IsDiscrete and an IsSupported method, so if your class wraps a <a class="el" href="class_g_classes_1_1_g_univariate_distribution.html" title="This is the base class for univariate distributions.">GUnivariateDistribution</a> then two of them are taken care of for you. In order to implement ComputeLogLikelihood, your class will probably need references to its parent nodes so that it can obtain their values to use as parameters for its distribution. You can implement your network structure however you like. When you have your network set up, you're ready to use MCMC to infer values for the network. To do this, just create a loop that calls Sample on each node in the network, and the whole network should eventually converge to good values. (Also, you need to make <a class="el" href="class_g_classes_1_1_g_bayesian_network_child_iterator.html" title="Iterates through all the children of the specified node in a Bayesian network.">GBayesianNetworkChildIterator</a> work, which I haven't worked out yet.) </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_beta_distribution.html">GClasses::GBetaDistribution</a></td><td class="indexvalue">The Beta distribution </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_bezier.html">GClasses::GBezier</a></td><td class="indexvalue">Represents a Bezier curve </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_big_int.html">GClasses::GBigInt</a></td><td class="indexvalue">Represents an integer of arbitrary size, and provides basic arithmetic functionality. Also contains functionality for implementing RSA symmetric-key cryptography </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_billboard.html">GClasses::GBillboard</a></td><td class="indexvalue">This is a billboard (a 2-D image in a 3-D world) for use with <a class="el" href="class_g_classes_1_1_g_billboard_world.html" title="This class represents a world of billboards, and provides a rendering engine.">GBillboardWorld</a>. You can set m_repeatX and/or m_repeatY to make the image repeat across the billboard </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_billboard_world.html">GClasses::GBillboardWorld</a></td><td class="indexvalue">This class represents a world of billboards, and provides a rendering engine </td></tr>
  <tr><td class="indexkey"><a class="el" href="struct_g_classes_1_1_g_bit_reverser__imp.html">GClasses::GBitReverser_imp&lt; T, numBits &gt;</a></td><td class="indexvalue">Template used for reversing numBits of type T. You shouldn't need this, use the function reverseBits </td></tr>
  <tr><td class="indexkey"><a class="el" href="struct_g_classes_1_1_g_bit_reverser__imp_3_01_t_00_011_01_4.html">GClasses::GBitReverser_imp&lt; T, 1 &gt;</a></td><td class="indexvalue">Base case of template used for reversing numBits of type T. You shouldn't need this, use the function reverseBits </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_bits.html">GClasses::GBits</a></td><td class="indexvalue">Contains various functions for bit analysis </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_bit_table.html">GClasses::GBitTable</a></td><td class="indexvalue">Represents a table of bits </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_blob_incoming.html">GClasses::GBlobIncoming</a></td><td class="indexvalue">This class is for deserializing blobs. It takes care of Endianness issues and protects against buffer overruns. This class would be particularly useful for writing a network protocol </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_blob_outgoing.html">GClasses::GBlobOutgoing</a></td><td class="indexvalue">This class is for serializing objects. It is the complement to <a class="el" href="class_g_classes_1_1_g_blob_incoming.html" title="This class is for deserializing blobs. It takes care of Endianness issues and protects against buffer...">GBlobIncoming</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_blob_queue.html">GClasses::GBlobQueue</a></td><td class="indexvalue">This is a special queue for handling blobs that come in and go out in varying sizes. It is particulary designed for streaming things that must travel or be parsed in packets that may differ in size from how they are sent or transmitted </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_brandes_betweenness_centrality.html">GClasses::GBrandesBetweennessCentrality</a></td><td class="indexvalue">Computes the number of times that the shortest-path between every pair of points passes over each edge and vertex </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_breadth_first_unfolding.html">GClasses::GBreadthFirstUnfolding</a></td><td class="indexvalue">A manifold learning algorithm that reduces dimensionality in local neighborhoods, and then stitches the reduced local neighborhoods together using the Kabsch algorithm </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_brute_force_neighbor_finder.html">GClasses::GBruteForceNeighborFinder</a></td><td class="indexvalue">Finds neighbors by measuring the distance to all points. This one should work properly even if the distance metric does not support the triangle inequality </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_brute_force_search.html">GClasses::GBruteForceSearch</a></td><td class="indexvalue">This performs a brute force search with uniform sampling over the unit hypercube with increasing granularity. (Your target function should scale the candidate vectors as necessary to cover the desired space.) </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_bucket.html">GClasses::GBucket</a></td><td class="indexvalue">When Train is called, this performs cross-validation on the training set to determine which learner is the best. It then trains that learner with the entire training set </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_camera.html">GClasses::GCamera</a></td><td class="indexvalue">This camera assumes the canvas is specified in cartesian coordinates. The 3D space is based on a right-handed coordinate system. (So if x goes to the right and y goes up, then z comes out of the screen toward you.) </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_categorical_distribution.html">GClasses::GCategoricalDistribution</a></td><td class="indexvalue">This is a distribution that specifies a probability for each value in a set of nominal values </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_categorical_sampler.html">GClasses::GCategoricalSampler</a></td><td class="indexvalue">This class is for efficiently drawing random values from a categorical distribution with a large number of categories </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_categorical_sampler_batch.html">GClasses::GCategoricalSamplerBatch</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_char_set.html">GClasses::GCharSet</a></td><td class="indexvalue">This is a helper-class used by <a class="el" href="class_g_classes_1_1_g_tokenizer.html" title="This is a simple tokenizer that reads a file, one token at-a-time.">GTokenizer</a>. Use <a class="el" href="class_g_classes_1_1_g_tokenizer.html#a35d6ac294de56c643e50e0db39d946d4" title="Returns a GCharSet. Many of the methods in this class require a GCharSet as a parameter. You get it by calling this method. szChars is an un-ordered set of characters (with no separator between them). The only special character is &#39;-&#39;, which is used to indicate a range of characters if it is not the first character in the string. (So, if you want &#39;-&#39; in your set of characters, it should come first.) For example, the following string includes all letters: &quot;a-zA-Z&quot;, and the following string includes all characters that might appear in a floating-point number: &quot;-.,0-9e&quot;. (There is no way to include &#39;\0&#39; as a character in the set, since that character indicates the end of the string, but that is okay since &#39;\0&#39; should not occur in text files anyway, and this class is designed for parsing text files.)">GTokenizer::charSet</a> to create </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_chess_board.html">GClasses::GChessBoard</a></td><td class="indexvalue">Represents the state of a chess board, and provides some basic functionality for implementing a chess game </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_chess_move_iterator.html">GClasses::GChessMoveIterator</a></td><td class="indexvalue">Iterates through all the possible moves for the specified color. It iterates through the pieces in a random order. It also iterates through the moves for each piece in a random order, but it will visit each move for the current piece before considering the next piece </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_clusterer.html">GClasses::GClusterer</a></td><td class="indexvalue">The base class for clustering algorithms. Classes that inherit from this class must implement a method named "cluster" which performs clustering, and a method named "whichCluster" which reports which cluster the specified row is determined to be a member of </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_collaborative_filter.html">GClasses::GCollaborativeFilter</a></td><td class="indexvalue">The base class for collaborative filtering recommender systems </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_compressor.html">GClasses::GCompressor</a></td><td class="indexvalue">This implements a simple compression/decompression algorithm </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_const_string_hash_table.html">GClasses::GConstStringHashTable</a></td><td class="indexvalue">Hash table based on keys of constant strings (or at least strings that won't change during the lifetime of the hash table). It's a good idea to use a <a class="el" href="class_g_classes_1_1_g_heap.html" title="Provides a heap in which to put strings or whatever you need to store. If you need to allocate space ...">GHeap</a> in connection with this class </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_const_string_to_index_hash_table.html">GClasses::GConstStringToIndexHashTable</a></td><td class="indexvalue">Hash table based on keys of constant strings (or at least strings that won't change during the lifetime of the hash table). It's a good idea to use a <a class="el" href="class_g_classes_1_1_g_heap.html" title="Provides a heap in which to put strings or whatever you need to store. If you need to allocate space ...">GHeap</a> in connection with this class </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_coord_vector_iterator.html">GClasses::GCoordVectorIterator</a></td><td class="indexvalue">An iterator for an n-dimensional coordinate vector. For example, suppose you have a 4-dimensional 2x3x2x1 grid, and you want to iterate through its coordinates: (0000, 0010, 0100, 0110, 0200, 0210, 1000, 1010, 1100, 1110, 1200, 1210). This class will iterate over coordinate vectors in this manner. (For 0-dimensional coordinate vectors, it behaves as though the origin is the only valid coordinate.) </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_cosine_similarity.html">GClasses::GCosineSimilarity</a></td><td class="indexvalue">This is a similarity metric that computes the cosine of the angle bewtween two sparse vectors </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_crypto.html">GClasses::GCrypto</a></td><td class="indexvalue">This is a symmetric-key block-cypher. It utilizes a 2048-byte internal state which is initialized using the passphrase. It uses repeated applications of sha-512 to advance the internal state, and to generate an 1024-byte pad that it xor's with your data to encrypt or decrypt it. Warning: You use this algorithm at your own risk. Many encryption algorithms eventually turn out to be insecure, and to my knowledge, this algorithm has not yet been extensively scrutinized </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_cycle_cut.html">GClasses::GCycleCut</a></td><td class="indexvalue">This finds the shortcuts in a table of neighbors and replaces them with INVALID_INDEX </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_decision_tree.html">GClasses::GDecisionTree</a></td><td class="indexvalue">This is an efficient learning algorithm. It divides on the attributes that reduce entropy the most, or alternatively can make random divisions </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_dense_cluster_recommender.html">GClasses::GDenseClusterRecommender</a></td><td class="indexvalue">This class clusters the rows according to a dense distance metric, then uses the baseline vector in each cluster to make predictions </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_diff.html">GClasses::GDiff</a></td><td class="indexvalue">This class finds the differences between two text files It is case and whitespace sensitive, but is tolerant of Unix/Windows/Mac line endings. It uses lines as the atomic unit. It accepts matching lines in a greedy manner </td></tr>
  <tr><td class="indexkey"><a class="el" href="struct_g_classes_1_1_g_diff_line.html">GClasses::GDiffLine</a></td><td class="indexvalue">This is a helper struct used by <a class="el" href="class_g_classes_1_1_g_diff.html" title="This class finds the differences between two text files It is case and whitespace sensitive...">GDiff</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_dijkstra.html">GClasses::GDijkstra</a></td><td class="indexvalue">Finds the shortest path from an origin vertex to all other vertices. Implemented with a binary-heap priority-queue. If the graph is sparse on edges, it will run in about O(n log(n)) time. If the graph is dense, it runs in about O(n^2 log(n)) </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_dir_list.html">GClasses::GDirList</a></td><td class="indexvalue">This class contains a list of files and a list of folders. The constructor populates these lists with the names of files and folders in the current working directory </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_discrete_action_iterator.html">GClasses::GDiscreteActionIterator</a></td><td class="indexvalue">This is a simple and common action iterator that can be used when there is a discrete set of possible actions </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_discretize.html">GClasses::GDiscretize</a></td><td class="indexvalue">This transform uses buckets to convert continuous data into discrete data. It is common to use GFilter to combine this with your favorite modeler (which only supports discrete values) to create a modeler that can also support continuous values as well </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_distance_metric.html">GClasses::GDistanceMetric</a></td><td class="indexvalue">This class enables you to define a distance (or dissimilarity) metric between two vectors. pScaleFactors is an optional parameter (it can be NULL) that lets the calling class scale the significance of each dimension. Distance metrics that do not mix with this concept may simply ignore any scale factors. Typically, classes that use this should be able to assume that the triangle inequality will hold, but do not necessarily enforce the parallelogram law </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_distribution.html">GClasses::GDistribution</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_dom.html">GClasses::GDom</a></td><td class="indexvalue">A Document Object Model. This represents a document as a hierarchy of objects. The DOM can be loaded-from or saved-to a file in JSON (JavaScript Object Notation) format. (See <a href="http://json.org.">http://json.org.</a>) In the future, support for XML and/or other formats may be added </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_dom_list_iterator.html">GClasses::GDomListIterator</a></td><td class="indexvalue">This class iterates over the items in a list node </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_dom_node.html">GClasses::GDomNode</a></td><td class="indexvalue">Represents a single node in a DOM </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_double_rect.html">GClasses::GDoubleRect</a></td><td class="indexvalue">Represents a rectangular region with doubles </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_dynamic_page_server.html">GClasses::GDynamicPageServer</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_dynamic_page_session.html">GClasses::GDynamicPageSession</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_dynamic_page_session_extension.html">GClasses::GDynamicPageSessionExtension</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_dynamic_system_state_aligner.html">GClasses::GDynamicSystemStateAligner</a></td><td class="indexvalue">This uses graph-cut to divide the data into two clusters. It then trains a linear regression model for each cluster to map from inputs to change-in-state. It then aligns the smaller cluster with the larger one such that the linear models are in agreement (as much as possible) </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_empirical_gradient_descent.html">GClasses::GEmpiricalGradientDescent</a></td><td class="indexvalue">This algorithm does a gradient descent by feeling a small distance out in each dimension to measure the gradient. For efficiency reasons, it only measures the gradient in one dimension (which it cycles round-robin style) per iteration and uses the remembered gradient in the other dimensions </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_ensemble.html">GClasses::GEnsemble</a></td><td class="indexvalue">This is a base-class for ensembles that combine the predictions from multiple weightd models </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_evolutionary_optimizer.html">GClasses::GEvolutionaryOptimizer</a></td><td class="indexvalue">Uses an evolutionary process to optimize a vector </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_extended_kalman_filter.html">GClasses::GExtendedKalmanFilter</a></td><td class="indexvalue">This is an implementation of the Extended Kalman Filter. This class is used by alternately calling advance and correct </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_file.html">GClasses::GFile</a></td><td class="indexvalue">Contains some useful routines for manipulating files </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_float_rect.html">GClasses::GFloatRect</a></td><td class="indexvalue">Represents a rectangular region with floats </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_floyd_warshall.html">GClasses::GFloydWarshall</a></td><td class="indexvalue">Computes the shortest-cost path between all pairs of vertices in a graph. Takes O(n^3) time </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_folder_deserializer.html">GClasses::GFolderDeserializer</a></td><td class="indexvalue">This class complements <a class="el" href="class_g_classes_1_1_g_folder_serializer.html" title="This turns a file or a folder (and its contents recursively) into a stream of bytes.">GFolderSerializer</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_folder_serializer.html">GClasses::GFolderSerializer</a></td><td class="indexvalue">This turns a file or a folder (and its contents recursively) into a stream of bytes </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_fourier.html">GClasses::GFourier</a></td><td class="indexvalue">Fourier transform </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_fourier_wave_processor.html">GClasses::GFourierWaveProcessor</a></td><td class="indexvalue">This is an abstract class that processes a wave file in blocks. Specifically, it divides the wave file up into overlapping blocks, converts them into Fourier space, calls the abstract "process" method with each block, converts back from Fourier space, and then interpolates to create the wave output </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_function.html">GClasses::GFunction</a></td><td class="indexvalue">This class represents a math function. (It might be used, for example, in a plotting tool.) </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_function_parser.html">GClasses::GFunctionParser</a></td><td class="indexvalue">This class parses math equations. (This is useful, for example, for plotting tools.) </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_fuzzy_k_means.html">GClasses::GFuzzyKMeans</a></td><td class="indexvalue">A K-means clustering algorithm where every point has partial membership in each cluster. This algorithm is specified in Li, D. and Deogun, J. and Spaulding, W. and Shuart, B., Towards missing data imputation: A study of fuzzy K-means clustering method, In Rough Sets and Current Trends in Computing, Springer, pages 573--579, 2004 </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_gamma_distribution.html">GClasses::GGammaDistribution</a></td><td class="indexvalue">The Gamma distribution </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_graph_cut.html">GClasses::GGraphCut</a></td><td class="indexvalue">This implements an optimized max-flow/min-cut algorithm described in "An experimental comparison of min-cut/max-flow algorithms for energy minimization in vision" by Boykov, Y. and Kolmogorov, V. This implementation assumes that edges are undirected </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_graph_cut_transducer.html">GClasses::GGraphCutTransducer</a></td><td class="indexvalue">A transduction algorithm that uses a max-flow/min-cut graph-cut algorithm to partition the data until each class is in a separate cluster. Unlabeled points are then assigned the label of the cluster in which they fall </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_graph_edge_iterator.html">GClasses::GGraphEdgeIterator</a></td><td class="indexvalue">Iterates over the edges that connect to the specified node </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_hash_table.html">GClasses::GHashTable</a></td><td class="indexvalue">Implements a typical hash table. (It doesn't take ownership of the objects you add, so you must still delete them yourself.) </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_hash_table_base.html">GClasses::GHashTableBase</a></td><td class="indexvalue">The base class of hash tables </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_hash_table_enumerator.html">GClasses::GHashTableEnumerator</a></td><td class="indexvalue">This class iterates over the values in a hash table </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_heap.html">GClasses::GHeap</a></td><td class="indexvalue">Provides a heap in which to put strings or whatever you need to store. If you need to allocate space for a lot of small objects, it's much more efficient to use this class than the C++ heap. Plus, you can delete them all by simply deleting the heap. You can't, however, reuse the space for individual objects in this heap </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_hidden_markov_model.html">GClasses::GHiddenMarkovModel</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_hill_climber.html">GClasses::GHillClimber</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_histogram.html">GClasses::GHistogram</a></td><td class="indexvalue">Gathers values and puts them in bins </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_html.html">GClasses::GHtml</a></td><td class="indexvalue">This class is for parsing HTML files. It's designed to be very simple. This class might be useful, for example, for building a web-crawler or for extracting readable text from a web page </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_http_client.html">GClasses::GHttpClient</a></td><td class="indexvalue">This class allows you to get files using the HTTP protocol </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_http_multipart_parser.html">GClasses::GHttpMultipartParser</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_http_param_parser.html">GClasses::GHttpParamParser</a></td><td class="indexvalue">A class for parsing the name/value pairs that follow the "?" in a URL </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_http_server.html">GClasses::GHttpServer</a></td><td class="indexvalue">This class allows you to implement a simple HTTP daemon </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_identity_function.html">GClasses::GIdentityFunction</a></td><td class="indexvalue">This is an implementation of the identity function. It might be useful, for example, as the observation function in a <a class="el" href="class_g_classes_1_1_g_recurrent_model.html" title="This class can be used to implement recurrent neural networks, or recurrent forms of other supervised...">GRecurrentModel</a> if you want to create a Jordan network </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_image.html">GClasses::GImage</a></td><td class="indexvalue">Represents an image </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_image_jitterer.html">GClasses::GImageJitterer</a></td><td class="indexvalue">Given an image encoded as a rasterized row of channel values, this class computes a single pixel drawn from the image as if the image had been rotated, translated, and zoomed by a small random amount. (The purpose of this class is to make it possible to train <a class="el" href="class_g_classes_1_1_g_unsupervised_back_prop.html" title="A manifold learning algorithm that uses back-propagation to train a neural net model to map from low-...">GUnsupervisedBackProp</a> to understand these common image-based transformations.) </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_impute_missing_vals.html">GClasses::GImputeMissingVals</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_incremental_learner.html">GClasses::GIncrementalLearner</a></td><td class="indexvalue">This is the base class of supervised learning algorithms that can learn one row at a time </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_incremental_learner_q_agent.html">GClasses::GIncrementalLearnerQAgent</a></td><td class="indexvalue">This is an implementation of <a class="el" href="class_g_classes_1_1_g_q_learner.html" title="The base class of a Q-Learner. To use this class, there are four abstract methods you&#39;ll need to ...">GQLearner</a> that uses an incremental learner for its Q-table and a SoftMax (usually pick the best action, but sometimes randomly pick the action) strategy to balance between exploration vs exploitation. To use this class, you need to supply an incremental learner (see the comment for the constructor for more details) and to implement the GetRewardForLastAction method </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_incremental_transform.html">GClasses::GIncrementalTransform</a></td><td class="indexvalue">This is the base class of algorithms that can transform data one row at a time without supervision </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_index_vec.html">GClasses::GIndexVec</a></td><td class="indexvalue">Useful functions for operating on vectors of indexes </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_instance_recommender.html">GClasses::GInstanceRecommender</a></td><td class="indexvalue">This class makes recommendations by finding the nearest-neighbors (as determined by evaluating only overlapping ratings), and assuming that the ratings of these neighbors will be predictive of your ratings </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_instance_table.html">GClasses::GInstanceTable</a></td><td class="indexvalue">This represents a grid of values. It might be useful as a Q-table with Q-learning </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_inverse_gamma_distribution.html">GClasses::GInverseGammaDistribution</a></td><td class="indexvalue">The inverse Gamma distribution </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_isomap.html">GClasses::GIsomap</a></td><td class="indexvalue">Isomap is a manifold learning algorithm that uses the Floyd-Warshall algorithm to compute an estimate of the geodesic distance between every pair of points using local neighborhoods, and then uses classic multidimensional scaling to compute a low-dimensional projection </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_kd_tree.html">GClasses::GKdTree</a></td><td class="indexvalue">An efficient algorithm for finding neighbors </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_kernel.html">GClasses::GKernel</a></td><td class="indexvalue">The base class for kernel functions. Classes which implement this must provide an "apply" method that applies the kernel to two vectors. Kernels may be combined together to form a more complex kernel, to which the kernel trick will still apply </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_kernel_add.html">GClasses::GKernelAdd</a></td><td class="indexvalue">An addition kernel </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_kernel_exp.html">GClasses::GKernelExp</a></td><td class="indexvalue">The Exponential kernel </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_kernel_gaussian_r_b_f.html">GClasses::GKernelGaussianRBF</a></td><td class="indexvalue">A Gaussian RBF kernel </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_kernel_identity.html">GClasses::GKernelIdentity</a></td><td class="indexvalue">The identity kernel </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_kernel_multiply.html">GClasses::GKernelMultiply</a></td><td class="indexvalue">A multiplication kernel </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_kernel_normalize.html">GClasses::GKernelNormalize</a></td><td class="indexvalue">A Normalizing kernel </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_kernel_polynomial.html">GClasses::GKernelPolynomial</a></td><td class="indexvalue">A polynomial kernel </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_kernel_pow.html">GClasses::GKernelPow</a></td><td class="indexvalue">A power kernel </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_kernel_scale.html">GClasses::GKernelScale</a></td><td class="indexvalue">A scalar kernel </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_kernel_translate.html">GClasses::GKernelTranslate</a></td><td class="indexvalue">A translation kernel </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_key_pair.html">GClasses::GKeyPair</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_k_means.html">GClasses::GKMeans</a></td><td class="indexvalue">An implementation of the K-means clustering algorithm </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_k_means_sparse.html">GClasses::GKMeansSparse</a></td><td class="indexvalue">An implementation of the K-means clustering algorithm </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_k_medoids.html">GClasses::GKMedoids</a></td><td class="indexvalue">An implementation of the K-medoids clustering algorithm </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_k_medoids_sparse.html">GClasses::GKMedoidsSparse</a></td><td class="indexvalue">An implementation of the K-medoids clustering algorithm for sparse data </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_k_n_n.html">GClasses::GKNN</a></td><td class="indexvalue">The k-Nearest Neighbor learning algorithm </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_learner_loader.html">GClasses::GLearnerLoader</a></td><td class="indexvalue">This class is for loading various learning algorithms from a DOM. When any learning algorithm is saved, it calls baseDomNode, which creates (among other things) a field named "class" which specifies the class name of the algorithm. This class contains methods that will recognize any of the classes in this library and load them. If it doesn't recognize a class, it will either return NULL or throw and exception, depending on the flags you pass to the constructor. Obviously this loader won't recognize any classes that you make. Therefore, you should overload the corresponding method in this class with a new method that will first recognize and load your classes, and then call these methods to handle other types </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_linear_programming.html">GClasses::GLinearProgramming</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_linear_regressor.html">GClasses::GLinearRegressor</a></td><td class="indexvalue">A linear regression model. Let f be a feature vector of real values, and let l be a label vector of real values, then this model estimates l=Bf+e, where B is a matrix of real values, and e is a vector of real values. (In the Wikipedia article on linear regression, B is called "beta", and e is called "epsilon". The approach used by this model to compute beta and epsilon, however, is much more efficient than the approach currently described in that article.) </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_l_l_e.html">GClasses::GLLE</a></td><td class="indexvalue">Locally Linear Embedding is a manifold learning algorithm that uses sparse matrix techniques to efficiently compute a low-dimensional projection </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_l_norm_distance.html">GClasses::GLNormDistance</a></td><td class="indexvalue">Interpolates between manhattan distance (norm=1), Euclidean distance (norm=2), and Chebyshev distance (norm=infinity). For nominal attributes, Hamming distance is used </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_manifold.html">GClasses::GManifold</a></td><td class="indexvalue">This class stores static methods that are useful for manifold learning </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_manifold_learner.html">GClasses::GManifoldLearner</a></td><td class="indexvalue">This is the base class of manifold learning (aka non-linear dimensionality reducing) algorithms </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_manifold_sculpting.html">GClasses::GManifoldSculpting</a></td><td class="indexvalue">Manifold Sculpting. A non-linear dimensionality reduction algorithm. (See Gashler, Michael S. and Ventura, Dan and Martinez, Tony. Iterative non-linear dimensionality reduction with manifold sculpting. In Advances in Neural Information Processing Systems 20, pages 513–520, MIT Press, Cambridge, MA, 2008.) </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_math.html">GClasses::GMath</a></td><td class="indexvalue">Provides some useful math functions </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_matrix.html">GClasses::GMatrix</a></td><td class="indexvalue">Represents a matrix or a database table. Elements can be discrete or continuous. References a <a class="el" href="class_g_classes_1_1_g_relation.html" title="Holds the metadata for a dataset, including which attributes are continuous or nominal, and how many values each nominal attribute supports.">GRelation</a> object, which stores the meta-information about each column </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_matrix_array.html">GClasses::GMatrixArray</a></td><td class="indexvalue">Represents an array of matrices or datasets that all have the same number of columns </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_matrix_factorization.html">GClasses::GMatrixFactorization</a></td><td class="indexvalue">This factors the sparse matrix of ratings, M, such that M = PQ^T where each row in P gives the principal preferences for the corresponding user, and each row in Q gives the linear combination of those preferences that map to a rating for an item. (Actually, P and Q also contain an extra column added for a bias.) This class is implemented according to the specification on page 631 in Takacs, G., Pilaszy, I., Nemeth, B., and Tikk, D. Scalable collaborative filtering approaches for large recommender systems. The Journal of Machine Learning Research, 10:623–656, 2009. ISSN 1532-4435., except with the addition of learning-rate decay and a different stopping criteria </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_mean_margins_tree.html">GClasses::GMeanMarginsTree</a></td><td class="indexvalue">A <a class="el" href="class_g_classes_1_1_g_mean_margins_tree.html" title="A GMeanMarginsTree is an oblique decision tree specified in Gashler, Michael S. and Giraud-Carrier...">GMeanMarginsTree</a> is an oblique decision tree specified in Gashler, Michael S. and Giraud-Carrier, Christophe and Martinez, Tony. Decision Tree Ensemble: Small Heterogeneous Is Better Than Large Homogeneous. In The Seventh International Conference on Machine Learning and Applications, Pages 900 - 905, ICMLA '08. 2008. It divides features as follows: It finds the mean and principle component of the output vectors. It divides all the vectors into two groups, one that has a positive dot-product with the principle component (after subtracting the mean) and one that has a negative dot-product with the principle component (after subtracting the mean). Next it finds the average input vector for each of the two groups. Then it finds the mean and principle component of those two vectors. The dividing criteria for this node is to subtract the mean and then see whether the dot-product with the principle component is positive or negative </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_merge_data_holder.html">GClasses::GMergeDataHolder</a></td><td class="indexvalue">This class guarantees that the rows in b are merged vertically back into a when this object goes out of scope </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_mixed_relation.html">GClasses::GMixedRelation</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_mixture_of_gaussians.html">GClasses::GMixtureOfGaussians</a></td><td class="indexvalue">This class uses Expectency Maximization to find the mixture of Gaussians that best approximates the data in a specified real attribute of a data set </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_momentum_greedy_search.html">GClasses::GMomentumGreedySearch</a></td><td class="indexvalue">At each iteration this algorithm moves in only one dimension. If the situation doesn't improve it tries the opposite direction. If both directions are worse, it decreases the step size for that dimension, otherwise it increases the step size for that dimension </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_multivariate_normal_distribution.html">GClasses::GMultivariateNormalDistribution</a></td><td class="indexvalue">A multivariate Normal distribution. It can compute the likelihood of a specified vector, and can also generate random vectors from the distribution </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_naive_bayes.html">GClasses::GNaiveBayes</a></td><td class="indexvalue">A naive Bayes classifier </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_naive_instance.html">GClasses::GNaiveInstance</a></td><td class="indexvalue">This is an instance-based learner. Instead of finding the k-nearest neighbors of a feature vector, it finds the k-nearst neighbors in each dimension. That is, it finds n*k neighbors, considering each dimension independently. It then combines the label from all of these neighbors to make a prediction. Finding neighbors in this way makes it more robust to high-dimensional datasets. It tends to perform worse than k-nn in low-dimensional space, and better than k-nn in high-dimensional space. (It may be thought of as a cross between a k-nn instance learner and a Naive Bayes learner. It only supports continuous features and labels (so it is common to wrap it in a Categorize filter which will convert nominal features to a categorical distribution of continuous values) </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_neighbor_finder.html">GClasses::GNeighborFinder</a></td><td class="indexvalue">Finds the k-nearest neighbors of any vector in a dataset </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_neighbor_finder_cache_wrapper.html">GClasses::GNeighborFinderCacheWrapper</a></td><td class="indexvalue">This wraps a neighbor finding algorithm. It caches the queries for neighbors for the purpose of improving runtime performance </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_neighbor_finder_generalizing.html">GClasses::GNeighborFinderGeneralizing</a></td><td class="indexvalue">Finds the k-nearest neighbors (in a dataset) of an arbitrary vector (which may or may not be in the dataset) </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_neighbor_transducer.html">GClasses::GNeighborTransducer</a></td><td class="indexvalue">An instance-based transduction algorithm </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_neural_net.html">GClasses::GNeuralNet</a></td><td class="indexvalue">An artificial neural network </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_neural_net_inverse_layer.html">GClasses::GNeuralNetInverseLayer</a></td><td class="indexvalue">A helper class used by <a class="el" href="class_g_classes_1_1_g_neural_net_pseudo_inverse.html" title="Computes the pseudo-inverse of a neural network.">GNeuralNetPseudoInverse</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_neural_net_layer.html">GClasses::GNeuralNetLayer</a></td><td class="indexvalue">Represents a layer of neurons in a neural network </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_neural_net_pseudo_inverse.html">GClasses::GNeuralNetPseudoInverse</a></td><td class="indexvalue">Computes the pseudo-inverse of a neural network </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_neuron.html">GClasses::GNeuron</a></td><td class="indexvalue">Represents a single neuron in a neural network </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_neuro_p_c_a.html">GClasses::GNeuroPCA</a></td><td class="indexvalue">This class is a generalization of PCA. When the bias is clamped, and the activation function is "identity", it is strictly equivalent to PCA. By default, however, the bias is allowed to drift from the mean, which gives better results. Also, by default, the activation function is "logistic", which enables it to find non-linear components in the data. (<a class="el" href="class_g_classes_1_1_g_unsupervised_back_prop.html" title="A manifold learning algorithm that uses back-propagation to train a neural net model to map from low-...">GUnsupervisedBackProp</a> is a multi-layer generalization of this algorithm.) </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_node_hash_table.html">GClasses::GNodeHashTable</a></td><td class="indexvalue">This is a hash table that uses any object which inherits from <a class="el" href="class_g_classes_1_1_hash_table_node.html" title="Objects used with GNodeHashTable should inherit from this class. They must implement two methods (to ...">HashTableNode</a> as the key </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_noise_generator.html">GClasses::GNoiseGenerator</a></td><td class="indexvalue">Just generates Gaussian noise </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_nominal_to_cat.html">GClasses::GNominalToCat</a></td><td class="indexvalue">This is sort-of the opposite of discretize. It converts each nominal attribute to a categorical distribution by representing each value using the corresponding row of the identity matrix. For example, if a certain nominal attribute has 4 possible values, then a value of 3 would be encoded as the vector 0 0 1 0. When predictions are converted back to nominal values, the mode of the categorical distribution is used as the predicted value. (This is similar to Weka's NominalToBinaryFilter.) </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_nonlinear_p_c_a.html">GClasses::GNonlinearPCA</a></td><td class="indexvalue">This class trains a neural network to fit to the ratings. Although the name implies that it is an extension of PCA, I think it is better described as a non-linear generalization of matrix factorization. This algorithm was published in Scholz, M. Kaplan, F. Guy, C. L. Kopka, J. Selbig, J., Non-linear PCA: a missing data approach, In Bioinformatics, Vol. 21, Number 20, pp. 3887-3895, Oxford University Press, 2005 </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_normal_distribution.html">GClasses::GNormalDistribution</a></td><td class="indexvalue">This is the Normal (a.k.a. Gaussian) distribution </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_normalize.html">GClasses::GNormalize</a></td><td class="indexvalue">This transform scales and shifts continuous values to make them fall within a specified range </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_nurbs.html">GClasses::GNurbs</a></td><td class="indexvalue">NURBS = Non Uniform Rational B-Spline Periodic = closed loop </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_optimizer.html">GClasses::GOptimizer</a></td><td class="indexvalue">This is the base class of all search algorithms that can jump to any vector in the search space seek the vector that minimizes error </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_overrun_sentinel.html">GClasses::GOverrunSentinel</a></td><td class="indexvalue">Placing these on the stack can help catch buffer overruns </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_package_client.html">GClasses::GPackageClient</a></td><td class="indexvalue">This class abstracts a client that speaks a home-made protocol that guarantees packages will arrive in the same order and size as when they were sent. This protocol is a simple layer on top of TCP </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_package_server.html">GClasses::GPackageServer</a></td><td class="indexvalue">This class abstracts a server that speaks a home-made protocol that guarantees packages will arrive in the same order and size as when they were sent. This protocol is a simple layer on top of TCP </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_pair_product.html">GClasses::GPairProduct</a></td><td class="indexvalue">Generates data by computing the product of each pair of attributes. This is useful for augmenting data </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_parallel_optimizers.html">GClasses::GParallelOptimizers</a></td><td class="indexvalue">This class simplifies simultaneously solving several optimization problems </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_particle_swarm.html">GClasses::GParticleSwarm</a></td><td class="indexvalue">An optimization algorithm inspired by flocking birds </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_passive_console.html">GClasses::GPassiveConsole</a></td><td class="indexvalue">This class provides a non-blocking method for reading characters from stdin. (If there are no characters ready in stdin, it immediately returns '\0'.) The constructor sets flags on the console so that it passes characters to the stream immediately (instead of when Enter is pressed), and so that it doesn't echo the keys (if desired), and it makes stdin non-blocking. The destructor puts all those things back the way they were </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_p_c_a.html">GClasses::GPCA</a></td><td class="indexvalue">Principal Component Analysis. (Computes the principal components about the mean of the data when you call train. The transformed (reduced-dimensional) data will have a mean about the origin.) </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_p_c_a_rotate_only.html">GClasses::GPCARotateOnly</a></td><td class="indexvalue">Principle Component Analysis without the projection. It only rotates axes to align with the first few principal components </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_peach_agent.html">GClasses::GPeachAgent</a></td><td class="indexvalue">This is an experimental policy-learning algorithm. It's currently too slow to be practical </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_pearson_correlation.html">GClasses::GPearsonCorrelation</a></td><td class="indexvalue">This is a similarity metric that computes the Pearson correlation between two sparse vectors </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_pipe.html">GClasses::GPipe</a></td><td class="indexvalue">This class wraps the handle of a pipe. It closes the pipe when it is destroyed. This class is useful in conjunction with <a class="el" href="class_g_classes_1_1_g_app.html#ae973a376ac63f7133cd0239bdb7844a4" title="Executes the specified system command. (szCommand should contain the app name as well as args...">GApp::systemExecute</a> for reading from, or writing to, the standard i/o streams of a child process </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_plot_label_spacer.html">GClasses::GPlotLabelSpacer</a></td><td class="indexvalue">If you need to place grid lines or labels at regular intervals (like 1000, 2000, 3000, 4000... or 20, 25, 30, 35... or 0, 2, 4, 6, 8, 10...) this class will help you pick where to place the labels so that there are a reasonable number of them, and they all land on nice label values </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_plot_label_spacer_logarithmic.html">GClasses::GPlotLabelSpacerLogarithmic</a></td><td class="indexvalue">Similar to <a class="el" href="class_g_classes_1_1_g_plot_label_spacer.html" title="If you need to place grid lines or labels at regular intervals (like 1000, 2000, 3000, 4000... or 20, 25, 30, 35... or 0, 2, 4, 6, 8, 10...) this class will help you pick where to place the labels so that there are a reasonable number of them, and they all land on nice label values.">GPlotLabelSpacer</a>, except for logarithmic grids. To plot in logarithmic space, set your plot window to have a range from log_e(min) to log_e(max). When you actually plot things, plot them at log_e(x), where x is the position of the thing you want to plot </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_plot_window.html">GClasses::GPlotWindow</a></td><td class="indexvalue">This class makes it easy to plot points and functions on 2D cartesian coordinates </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_poisson_distribution.html">GClasses::GPoissonDistribution</a></td><td class="indexvalue">The Poisson distribution </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_policy_learner.html">GClasses::GPolicyLearner</a></td><td class="indexvalue">This is the base class for algorithms that learn a policy </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_polynomial.html">GClasses::GPolynomial</a></td><td class="indexvalue">This regresses a multi-dimensional polynomial to fit the data </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_prediction.html">GClasses::GPrediction</a></td><td class="indexvalue">This class is used to represent the predicted distribution made by a supervised learning algorithm. (It is just a shallow wrapper around <a class="el" href="class_g_classes_1_1_g_distribution.html">GDistribution</a>.) It is used in conjunction with calls to <a class="el" href="class_g_classes_1_1_g_supervised_learner.html#ac459ae8751f42b1dd85839ae419ee320" title="Evaluate pIn and compute a prediction for pOut. pOut is expected to point to an array of GPrediction ...">GSupervisedLearner::predictDistribution</a>. The predicted distributions will be either categorical distributions (for nominal values) or Normal distributions (for continuous values) </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_priority_queue.html">GClasses::GPriorityQueue</a></td><td class="indexvalue">An implementation of a double-ended heap-based priority queue. (Note that the multimap STL class can also be used to implement a double-ended priority queue, but the STL does not currently provide a heap-based double-ended priority queue, which is asymptotically more efficient for insertions.) </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_priority_queue_entry.html">GClasses::GPriorityQueueEntry</a></td><td class="indexvalue">An internal class used by <a class="el" href="class_g_classes_1_1_g_priority_queue.html" title="An implementation of a double-ended heap-based priority queue. (Note that the multimap STL class can ...">GPriorityQueue</a>. You should not use this class directly </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_probe_search.html">GClasses::GProbeSearch</a></td><td class="indexvalue">This is somewhat of a multi-dimensional version of binary-search. It greedily probes the best choices first, but then starts trying the opposite choices at the higher divisions so that it can also handle non-monotonic target functions. Each iteration performs a binary (divide-and-conquer) search within the unit hypercube. (Your target function should scale the candidate vectors as necessary to cover the desired space.) Because the high-level divisions are typically less correlated with the quality of the final result than the low-level divisions, it searches through the space of possible "probes" by toggling choices in the order from high level to low level. In low-dimensional space, this algorithm tends to quickly find good solutions, especially if the target function is somewhat smooth. In high-dimensional space, the number of iterations to find a good solution seems to grow exponentially </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_q_learner.html">GClasses::GQLearner</a></td><td class="indexvalue">The base class of a Q-Learner. To use this class, there are four abstract methods you'll need to implement. See also the comment for <a class="el" href="class_g_classes_1_1_g_policy_learner.html" title="This is the base class for algorithms that learn a policy.">GPolicyLearner</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_rand.html">GClasses::GRand</a></td><td class="indexvalue">This is a 64-bit pseudo-random number generator </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_random_forest.html">GClasses::GRandomForest</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_random_search.html">GClasses::GRandomSearch</a></td><td class="indexvalue">At each iteration, this tries a random vector from the unit hypercube. (Your target function should scale the candidate vectors as necessary to cover the desired space.) </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_ray_trace_area_light.html">GClasses::GRayTraceAreaLight</a></td><td class="indexvalue">Represents a light source with area </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_ray_trace_bounding_box_base.html">GClasses::GRayTraceBoundingBoxBase</a></td><td class="indexvalue">A class used for making ray-tracing faster </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_ray_trace_bounding_box_interior.html">GClasses::GRayTraceBoundingBoxInterior</a></td><td class="indexvalue">A class used for making ray-tracing faster </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_ray_trace_bounding_box_leaf.html">GClasses::GRayTraceBoundingBoxLeaf</a></td><td class="indexvalue">A class used for making ray-tracing faster </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_ray_trace_camera.html">GClasses::GRayTraceCamera</a></td><td class="indexvalue">Represents the camera for a ray tracing scene </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_ray_trace_color.html">GClasses::GRayTraceColor</a></td><td class="indexvalue">This class represents a color. It's more precise than GColor, but takes up more memory. Note that the ray tracer ignores the alpha channel because the material specifies a unique transmission color </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_ray_trace_directional_light.html">GClasses::GRayTraceDirectionalLight</a></td><td class="indexvalue">Represents directional light in a ray-tracing scene </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_ray_trace_image_texture.html">GClasses::GRayTraceImageTexture</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_ray_trace_light.html">GClasses::GRayTraceLight</a></td><td class="indexvalue">Represents a source of light in a ray-tracing scene </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_ray_trace_material.html">GClasses::GRayTraceMaterial</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_ray_trace_object.html">GClasses::GRayTraceObject</a></td><td class="indexvalue">An object in a ray-tracing scene </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_ray_trace_physical_material.html">GClasses::GRayTracePhysicalMaterial</a></td><td class="indexvalue">Represents the material of which an object is made in a ray-tracing scene </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_ray_trace_point_light.html">GClasses::GRayTracePointLight</a></td><td class="indexvalue">Represents a point light in a ray-tracing scene </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_ray_trace_scene.html">GClasses::GRayTraceScene</a></td><td class="indexvalue">Represents a scene that you can ray-trace </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_ray_trace_sphere.html">GClasses::GRayTraceSphere</a></td><td class="indexvalue">A sphere in a ray-tracing scene </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_ray_trace_triangle.html">GClasses::GRayTraceTriangle</a></td><td class="indexvalue">A single triangle in a ray-tracing scene </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_ray_trace_tri_mesh.html">GClasses::GRayTraceTriMesh</a></td><td class="indexvalue">Represents a triangle mesh in a ray-tracing scene </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_rect.html">GClasses::GRect</a></td><td class="indexvalue">Represents a rectangular region with integers </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_recurrent_model.html">GClasses::GRecurrentModel</a></td><td class="indexvalue">This class can be used to implement recurrent neural networks, or recurrent forms of other supervised models </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_region_ajacency_graph.html">GClasses::GRegionAjacencyGraph</a></td><td class="indexvalue">The base class for region ajacency graphs. These are useful for breaking down an image into patches of similar color </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_region_area_iterator.html">GClasses::GRegionAreaIterator</a></td><td class="indexvalue">Iterates over all the pixels in an image that have the same color and are transitively adjacent. In other words, if you were to flood-fill a the specified point, this returns all the pixels that would be changed </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_region_border_iterator.html">GClasses::GRegionBorderIterator</a></td><td class="indexvalue">Iterates the border of a 2D region by running around the border and reporting the coordinates of each interior border pixel and the direction to the edge. It goes in a counter-clockwise direction </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_relation.html">GClasses::GRelation</a></td><td class="indexvalue">Holds the metadata for a dataset, including which attributes are continuous or nominal, and how many values each nominal attribute supports </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_release_data_holder.html">GClasses::GReleaseDataHolder</a></td><td class="indexvalue">This is a special holder that guarantees the data set will release all of its data before it is deleted </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_s_o_m_1_1_grid_topology.html">GClasses::SOM::GridTopology</a></td><td class="indexvalue">Set the nodes to lie on an integer grid within the given maxima. A grid with 10,10 maximum is assumed to go from 0..9. NOTE: if the difference between a dimensional maximum and the nearest integer is less than 1e-6 then the maximum is taken to be that integer. Otherwise it is taken to be the maximum rounded down </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_row_distance.html">GClasses::GRowDistance</a></td><td class="indexvalue">This uses a combination of Euclidean distance for continuous attributes, and Hamming distance for nominal attributes. In particular, for each attribute, it calculates pA[i]-pB[i], squares it and takes the square root of that sum. For nominal attributes pA[i]-pB[i] is 0 if they are the same and 1 if they are different </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_row_distance_scaled.html">GClasses::GRowDistanceScaled</a></td><td class="indexvalue">This uses a combination of Euclidean distance for continuous attributes, and Hamming distance for nominal attributes. This version honors scale factors given by the user. See comments on <a class="el" href="class_g_classes_1_1_g_row_distance.html" title="This uses a combination of Euclidean distance for continuous attributes, and Hamming distance for nom...">GRowDistance</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_rubber_ball_swarm.html">GClasses::GRubberBallSwarm</a></td><td class="indexvalue">This is an algorithm for finding good starting points within a constrained optimization problem. It works by simulating "rubber balls" which bounce around inside the constrained region. After many iterations, they tend to be spread somewhat uniformly, even with very complex constrained shapes. The balls learn to approximate the shape of the shell, so if the room is wider than it is tall, the balls will learn to bounce sideways more often than vertically </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_saffron.html">GClasses::GSaffron</a></td><td class="indexvalue">This class implementes the SAFFRON intelligent neighbor-finding algorithm published in Gashler, Michael S. and Martinez, Tony. Tangent space guided intelligent neighbor finding. In Proceedings of the IEEE International Joint Conference on Neural Networks IJCNN’11, pages 2617–2624, IEEE Press, 2011. This class intelligently selects neighbors for each point in a dataset, such that the neighbors define a good neighborhood for manifold learning. A relaxation technique is used to ensure that neighbors lie on a consistent tangent-space while remaining close to the point. This makes manifold learning possible with difficult (somtimes even self-intersecting) manifolds </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_sample_climber.html">GClasses::GSampleClimber</a></td><td class="indexvalue">This is a variant of empirical gradient descent that tries to estimate the gradient using a minimal number of samples. It is more efficient than empirical gradient descent, but it only works well if the optimization surface is quite locally linear </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_s_d_l.html">GClasses::GSDL</a></td><td class="indexvalue">A collection of routines that are useful when interfacing with SDL </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_self_organizing_map.html">GClasses::GSelfOrganizingMap</a></td><td class="indexvalue">An implementation of a Kohonen self-organizing map </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_sequence_neighbor_finder.html">GClasses::GSequenceNeighborFinder</a></td><td class="indexvalue">A simple neighbor-finder that reports the nearest neighbors in the sequence. (That is, the previous and next rows are the closest neighbors.) The distance is sequential distance to the neighbor (not squared) </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_shortcut_pruner.html">GClasses::GShortcutPruner</a></td><td class="indexvalue">This finds the shortcuts in a table of neighbors and replaces them with INVALID_INDEX </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_signal_handler.html">GClasses::GSignalHandler</a></td><td class="indexvalue">Temporarily handles certain signals. (When this object is destroyed, it puts all the signal handlers back the way they were.) Periodically call "check" to see if a signal has occurred </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_smtp.html">GClasses::GSmtp</a></td><td class="indexvalue">For sending email to an SMTP server </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_soft_impulse_distribution.html">GClasses::GSoftImpulseDistribution</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_sparse_clusterer.html">GClasses::GSparseClusterer</a></td><td class="indexvalue">This is a base class for clustering algorithms that operate on sparse matrices </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_sparse_cluster_recommender.html">GClasses::GSparseClusterRecommender</a></td><td class="indexvalue">This class clusters the rows according to a sparse similarity metric, then uses the baseline vector in each cluster to make predictions </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_sparse_matrix.html">GClasses::GSparseMatrix</a></td><td class="indexvalue">This class stores a row-compressed sparse matrix. That is, each row consists of a map from a column-index to a value </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_sparse_similarity.html">GClasses::GSparseSimilarity</a></td><td class="indexvalue">The base class for similarity metrics that operate on sparse vectors </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_spin_lock.html">GClasses::GSpinLock</a></td><td class="indexvalue">A spin-lock for synchronization purposes </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_spin_lock_holder.html">GClasses::GSpinLockHolder</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_stemmer.html">GClasses::GStemmer</a></td><td class="indexvalue">This class just wraps the Porter Stemmer. It finds the stems of words. Examples: "cats"-&gt;"cat" "dogs"-&gt;"dog" "fries"-&gt;"fri" "fishes"-&gt;"fish" "pies"-&gt;"pi" "lovingly"-&gt;"lovingli" "candy"-&gt;"candi" "babies"-&gt;"babi" "bus"-&gt;"bu" "busses"-&gt;"buss" "women"-&gt;"women" "hasty"-&gt;"hasti" "hastily"-&gt;"hastili" "fly"-&gt;"fly" "kisses"-&gt;"kiss" "goes"-&gt;"goe" "brought"-&gt;"brought" As you can see the stems aren't always real words, but that's okay as long as it produces the same stem for words that have the same etymological roots. Even then it still isn't perfect (notice it got "bus" wrong), but it should still improve analysis somewhat in many cases </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_string_chopper.html">GClasses::GStringChopper</a></td><td class="indexvalue">This class chops a big string at word breaks so you can display it intelligently on multiple lines </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_sub_image_finder.html">GClasses::GSubImageFinder</a></td><td class="indexvalue">This class uses Fourier phase correlation to efficiently find sub-images within a larger image </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_sub_image_finder2.html">GClasses::GSubImageFinder2</a></td><td class="indexvalue">This class uses heuristics to find sub-images within a larger image. It is slower, but more stable than <a class="el" href="class_g_classes_1_1_g_sub_image_finder.html" title="This class uses Fourier phase correlation to efficiently find sub-images within a larger image...">GSubImageFinder</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_supervised_learner.html">GClasses::GSupervisedLearner</a></td><td class="indexvalue">This is the base class of algorithms that learn with supervision and have an internal hypothesis model that allows them to generalize rows that were not available at training time </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_system_learner.html">GClasses::GSystemLearner</a></td><td class="indexvalue">This is the base class for algorithms that learn to model dynamical systems </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_target_function.html">GClasses::GTargetFunction</a></td><td class="indexvalue">The optimizer seeks to find values that minimize this target function </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_t_c_p_client.html">GClasses::GTCPClient</a></td><td class="indexvalue">This class is an abstraction of a TCP client socket connection </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_t_c_p_connection.html">GClasses::GTCPConnection</a></td><td class="indexvalue">This class is used by <a class="el" href="class_g_classes_1_1_g_t_c_p_server.html" title="This class is an abstraction of a TCP server, which maintains a set of socket connections.">GTCPServer</a> to represent a connection with one of the clients. (If you want to associate some additional objects with each connection, you can inherrit from this class, and overload <a class="el" href="class_g_classes_1_1_g_t_c_p_server.html#a1c6d88f34f86b916ff15e801012acfa4" title="This is called just before a new connection is accepted. It returns a pointer to a new GTCPConnection...">GTCPServer::makeConnection</a> to return your own custom object.) </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_t_c_p_server.html">GClasses::GTCPServer</a></td><td class="indexvalue">This class is an abstraction of a TCP server, which maintains a set of socket connections </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_temp_buf_helper.html">GClasses::GTempBufHelper</a></td><td class="indexvalue">A helper class used by the GTEMPBUF macro </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_temporal_neighbor_finder.html">GClasses::GTemporalNeighborFinder</a></td><td class="indexvalue">A neighbor finder that specializes in dynamical systems. It determines neighbors by searching for the shortest path of actions between observations, and computes the distance as the number of time-steps in that path. This algorithm was published in Gashler, Michael S. and Martinez, Tony. Temporal nonlinear dimensionality reduction. In Proceedings of the International Joint Conference on Neural Networks IJCNN’11, pages 1959–1966, IEEE Press, 2011 </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_thread.html">GClasses::GThread</a></td><td class="indexvalue">A wrapper for PThreads on Linux and for some corresponding WIN32 api on Windows </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_time.html">GClasses::GTime</a></td><td class="indexvalue">Provides some time-related functions </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_tokenizer.html">GClasses::GTokenizer</a></td><td class="indexvalue">This is a simple tokenizer that reads a file, one token at-a-time </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_tokenizer_map_comparer.html">GClasses::GTokenizerMapComparer</a></td><td class="indexvalue">This is a helper-class used by <a class="el" href="class_g_classes_1_1_g_tokenizer.html" title="This is a simple tokenizer that reads a file, one token at-a-time.">GTokenizer</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_transducer.html">GClasses::GTransducer</a></td><td class="indexvalue">This is the base class of supervised learning algorithms (that may or may not have an internal model allowing them to generalize rows that were not available at training time). Note that the literature typically refers to supervised learning algorithms that can't generalize (because they lack an internal hypothesis model) as "Semi-supervised". (You cannot generalize with a semi-supervised algorithm--you have to train again with the new rows.) </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_transform.html">GClasses::GTransform</a></td><td class="indexvalue">This is the base class of algorithms that transform data without supervision </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_tri_mesh_builder.html">GClasses::GTriMeshBuilder</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_two_way_incremental_transform.html">GClasses::GTwoWayIncrementalTransform</a></td><td class="indexvalue">This is the base class of algorithms that can transform data one row at a time without supervision, and can (un)transform a row back to its original form if necessary </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_two_way_transform_chainer.html">GClasses::GTwoWayTransformChainer</a></td><td class="indexvalue">This wraps two two-way-incremental-transoforms to form a single combination transform </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_uniform_distribution.html">GClasses::GUniformDistribution</a></td><td class="indexvalue">This is a continuous uniform distribution </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_uniform_relation.html">GClasses::GUniformRelation</a></td><td class="indexvalue">A relation with a minimal memory footprint that assumes all attributes are continuous, or all of them are nominal and have the same number of possible values </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_univariate_distribution.html">GClasses::GUnivariateDistribution</a></td><td class="indexvalue">This is the base class for univariate distributions </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_unsupervised_back_prop.html">GClasses::GUnsupervisedBackProp</a></td><td class="indexvalue">A manifold learning algorithm that uses back-propagation to train a neural net model to map from low-dimensional space to high-dimensional space </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_vec.html">GClasses::GVec</a></td><td class="indexvalue">Contains some useful functions for operating on vectors </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_vec_buf.html">GClasses::GVecBuf</a></td><td class="indexvalue">Holds an array of doubles that can be resized. This class is slightly lighter-weight than the C++ vector class, and it allows access to the buffer in the form of an array of doubles. Basically, it is useful when working with C-style functions that expect parameters in the form of an array of doubles, rather than as a vector of doubles </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_vocabulary.html">GClasses::GVocabulary</a></td><td class="indexvalue">This is a helper class which is useful for text-mining. It collects words, stems them, filters them through a list of stop-words, and assigns a discrete number to each word </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_wag.html">GClasses::GWag</a></td><td class="indexvalue">This model trains several multi-layer perceptrons, then averages their weights together in an intelligent manner </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_wave.html">GClasses::GWave</a></td><td class="indexvalue">Currently only supports PCM wave format </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_wave_iterator.html">GClasses::GWaveIterator</a></td><td class="indexvalue">This class iterates over the samples in a WAVE file. Regardless of the bits-per-sample, this iterator will convert all samples to doubles with a range from -1 to 1 </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_web_socket_client.html">GClasses::GWebSocketClient</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_weighted_model.html">GClasses::GWeightedModel</a></td><td class="indexvalue">This is a helper-class used by <a class="el" href="class_g_classes_1_1_g_bag.html" title="BAG stands for bootstrap aggregator. It represents an ensemble of voting modelers. Each model is trained with a slightly different training set, which is produced by drawing randomly from the original training set with replacement until we have a new training set of the same size. Each model is given equal weight in the vote.">GBag</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_widget.html">GClasses::GWidget</a></td><td class="indexvalue">The base class of all GUI widgets </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_widget_animation.html">GClasses::GWidgetAnimation</a></td><td class="indexvalue">An image with multiple frames </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_widget_atomic.html">GClasses::GWidgetAtomic</a></td><td class="indexvalue">The base class of all atomic widgets (widgets that are not composed of other widgets) </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_widget_bullet_group.html">GClasses::GWidgetBulletGroup</a></td><td class="indexvalue">This creates a whole group of bullets arranged either horizontally or vertically at regular intervals </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_widget_bullet_hole.html">GClasses::GWidgetBulletHole</a></td><td class="indexvalue">The easiest way to do bullets is to use the <a class="el" href="class_g_classes_1_1_g_widget_bullet_group.html" title="This creates a whole group of bullets arranged either horizontally or vertically at regular intervals...">GWidgetBulletGroup</a> class, but if you really want to manage individual bullets yourself, you can use this class to do it </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_widget_canvas.html">GClasses::GWidgetCanvas</a></td><td class="indexvalue">A painting canvas </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_widget_check_box.html">GClasses::GWidgetCheckBox</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_widget_common.html">GClasses::GWidgetCommon</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_widget_dialog.html">GClasses::GWidgetDialog</a></td><td class="indexvalue">A form or dialog </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_widget_file_system_browser.html">GClasses::GWidgetFileSystemBrowser</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_widget_grid.html">GClasses::GWidgetGrid</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_widget_group.html">GClasses::GWidgetGroup</a></td><td class="indexvalue">The base class of all widgets that are composed of other widgets </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_widget_group_box.html">GClasses::GWidgetGroupBox</a></td><td class="indexvalue">This just draws a rectangular box </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_widget_horiz_scroll_bar.html">GClasses::GWidgetHorizScrollBar</a></td><td class="indexvalue">Makes a horizontal scroll bar </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_widget_horiz_slider.html">GClasses::GWidgetHorizSlider</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_widget_image_button.html">GClasses::GWidgetImageButton</a></td><td class="indexvalue">A button with an image on it. The left half of the image is the unpressed image and the right half is the pressed image </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_widget_image_label.html">GClasses::GWidgetImageLabel</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_widget_progress_bar.html">GClasses::GWidgetProgressBar</a></td><td class="indexvalue">Automatically determines wether to be horizontal or vertical based on dimensions. Progress ranges from 0 to 1, or from 0 to -1 if you want it to go the other way </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_widget_slider_tab.html">GClasses::GWidgetSliderTab</a></td><td class="indexvalue">This widget is not meant to be used by itself. It creates one of the parts of a scroll bar or slider bar </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_widget_text_box.html">GClasses::GWidgetTextBox</a></td><td class="indexvalue">This is a box in which the user can enter text </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_widget_text_button.html">GClasses::GWidgetTextButton</a></td><td class="indexvalue">A button with text on it </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_widget_text_label.html">GClasses::GWidgetTextLabel</a></td><td class="indexvalue">A text label </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_widget_text_tab.html">GClasses::GWidgetTextTab</a></td><td class="indexvalue">Represents a tab (like for tabbed menus, etc.) </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_widget_v_c_r_button.html">GClasses::GWidgetVCRButton</a></td><td class="indexvalue">A button with a common icon on it </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_widget_vert_scroll_bar.html">GClasses::GWidgetVertScrollBar</a></td><td class="indexvalue">Makes a vertical scroll bar </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_widget_vert_slider.html">GClasses::GWidgetVertSlider</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_widget_wave.html">GClasses::GWidgetWave</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_word_iterator.html">GClasses::GWordIterator</a></td><td class="indexvalue">This iterates over the words in a block of text </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_g_word_stats.html">GClasses::GWordStats</a></td><td class="indexvalue">Stores statistics about each word in a <a class="el" href="class_g_classes_1_1_g_vocabulary.html" title="This is a helper class which is useful for text-mining. It collects words, stems them, filters them through a list of stop-words, and assigns a discrete number to each word.">GVocabulary</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="struct_g_classes_1_1_hash_bucket.html">GClasses::HashBucket</a></td><td class="indexvalue">This is an internal structure used by <a class="el" href="class_g_classes_1_1_g_hash_table.html" title="Implements a typical hash table. (It doesn&#39;t take ownership of the objects you add...">GHashTable</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_hash_table_node.html">GClasses::HashTableNode</a></td><td class="indexvalue">Objects used with <a class="el" href="class_g_classes_1_1_g_node_hash_table.html" title="This is a hash table that uses any object which inherits from HashTableNode as the key...">GNodeHashTable</a> should inherit from this class. They must implement two methods (to hash and compare the nodes) </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_holder.html">GClasses::Holder&lt; T &gt;</a></td><td class="indexvalue">This class is very similar to the standard C++ class auto_ptr, except it throws an exception if you try to make a copy of it. This way, it will fail early if you use it in a manner that could result in non-deterministic behavior. (For example, if you create a vector of auto_ptrs, wierd things happen if an oom exception is thrown while resizing the buffer--part of the data will be lost when it reverts back to the original buffer. But if you make a vector of these, it will fail quickly, thus alerting you to the issue.) </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_s_o_m_1_1_iteration_interval_reporter.html">GClasses::SOM::IterationIntervalReporter</a></td><td class="indexvalue">Calls its sub-reporter on start, the first iteration of a block of "interval" iterations, and finally on stop </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_s_o_m_1_1_neighborhood_window_function.html">GClasses::SOM::NeighborhoodWindowFunction</a></td><td class="indexvalue">Function that given a width, and a distance from the center of the neighborhood returns a weight to be used to calculate the influence of neighboring nodes at that distance. For each radius, can tell a distance d (possibly infinity) from the center for which all weights for distances greater than or equal to d will be 0 </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_s_o_m_1_1_node.html">GClasses::SOM::Node</a></td><td class="indexvalue">A node in a self-organizing map </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_s_o_m_1_1_node_and_distance.html">GClasses::SOM::NodeAndDistance</a></td><td class="indexvalue">Used for creating an array of nodes sorted by nearness to a source node </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_s_o_m_1_1_node_location_initialization.html">GClasses::SOM::NodeLocationInitialization</a></td><td class="indexvalue">Way of initializing the node positions according to a given topology - for example: points on a grid, on a triangular lattice, or random points in space </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_s_o_m_1_1_node_weight_initialization.html">GClasses::SOM::NodeWeightInitialization</a></td><td class="indexvalue">Algorithm to initialize the weights of the nodes in the network before training </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_s_o_m_1_1_node_weight_initialization_training_set_sample.html">GClasses::SOM::NodeWeightInitializationTrainingSetSample</a></td><td class="indexvalue">Initializes the weights to a random sample of rows from the training set </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_s_o_m_1_1_no_reporting.html">GClasses::SOM::NoReporting</a></td><td class="indexvalue">A reporter that does nothing </td></tr>
  <tr><td class="indexkey"><a class="el" href="struct_g_classes_1_1_path_data.html">GClasses::PathData</a></td><td class="indexvalue">Helper struct to hold the results from GFile::ParsePath </td></tr>
  <tr><td class="indexkey"><a class="el" href="struct_g_classes_1_1_s_o_m_1_1_s_v_g2_d_weight_reporter_1_1_point.html">GClasses::SOM::SVG2DWeightReporter::Point</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_s_o_m_1_1_reporter.html">GClasses::SOM::Reporter</a></td><td class="indexvalue">Reports periodically on the training of a self-organizing map - writing status to a stream every so many seconds or iterations, writing visualizations of the network or the network itself to sequentially named files </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_s_o_m_1_1_reporter_chain.html">GClasses::SOM::ReporterChain</a></td><td class="indexvalue">A <a class="el" href="class_g_classes_1_1_s_o_m_1_1_reporter_chain.html" title="A ReporterChain contains a list of Reporter objects. When a method is called on the ReporterChain...">ReporterChain</a> contains a list of <a class="el" href="class_g_classes_1_1_s_o_m_1_1_reporter.html" title="Reports periodically on the training of a self-organizing map - writing status to a stream every so m...">Reporter</a> objects. When a method is called on the <a class="el" href="class_g_classes_1_1_s_o_m_1_1_reporter_chain.html" title="A ReporterChain contains a list of Reporter objects. When a method is called on the ReporterChain...">ReporterChain</a>, it calls the same method on each of its sub-objects in turn </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1smart__ptr.html">GClasses::smart_ptr&lt; T &gt;</a></td><td class="indexvalue">A reference-counting smart-pointer </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1smart__ptr__ref__counter.html">GClasses::smart_ptr_ref_counter&lt; T &gt;</a></td><td class="indexvalue">A helper class used by the <a class="el" href="class_g_classes_1_1smart__ptr.html" title="A reference-counting smart-pointer.">smart_ptr</a> class </td></tr>
  <tr><td class="indexkey"><a class="el" href="struct_g_classes_1_1str_comp.html">GClasses::strComp</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_s_o_m_1_1_s_v_g2_d_weight_reporter.html">GClasses::SOM::SVG2DWeightReporter</a></td><td class="indexvalue">Writes out sequentially numbered svg files giving the weight locations in 2 dimensions of input space connected by a mesh that connects each weight with its nearest neighbors. Writes one file each time newStatus is called and once when stop is called. The output of stop may duplicate the last newStatus's output, but is not guaranteed to </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_s_o_m_1_1_traditional_training.html">GClasses::SOM::TraditionalTraining</a></td><td class="indexvalue">Implments the traditional step-wise training of self-organized maps //TODO: finish this comment </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_s_o_m_1_1_training_algorithm.html">GClasses::SOM::TrainingAlgorithm</a></td><td class="indexvalue">An algorithm for training self-organizing maps. Before training is started, it is expected that the nodes are allocated and that the geometry of the map has been set by giving each node a position and a distance function. However, the weight vectors and the output dimensionality will be completely overwritten by training </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_s_o_m_1_1_uniform_window_function.html">GClasses::SOM::UniformWindowFunction</a></td><td class="indexvalue">Uses a unit-height, zero-mean Uniform weighting with the width being the radius of the circle anything beyond width is 0 </td></tr>
  <tr><td class="indexkey"><a class="el" href="class_g_classes_1_1_vector_of_pointers_holder.html">GClasses::VectorOfPointersHolder&lt; T &gt;</a></td><td class="indexvalue">Deletes all of the pointers in a vector when this object goes out of scope </td></tr>
</table>
</div>
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="footer">Generated on Mon Dec 5 2011 14:18:58 for GClasses by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.3 </li>
    </ul>
  </div>

</body>
</html>
