<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>GClasses: GClasses::GMatrix Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript">
$(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.3 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">GClasses</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('class_g_classes_1_1_g_matrix.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a>  </div>
  <div class="headertitle">
<h1>GClasses::GMatrix Class Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="GClasses::GMatrix" -->
<p>Represents a matrix or a database table. Elements can be discrete or continuous. References a <a class="el" href="class_g_classes_1_1_g_relation.html" title="Holds the metadata for a dataset, including which attributes are continuous or nominal, and how many values each nominal attribute supports.">GRelation</a> object, which stores the meta-information about each column.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;GMatrix.h&gt;</code></p>

<p><a href="class_g_classes_1_1_g_matrix-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_matrix.html#a9585673b8e4a0020717fbe96a0cf0445">GMatrix</a> (size_t rows, size_t cols, <a class="el" href="class_g_classes_1_1_g_heap.html">GHeap</a> *pHeap=NULL)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a rows x cols matrix. All elements of the matrix are assumed to be continuous. (It is okay to initially set rows to 0 and later call newRow to add each row. Adding columns later, however, is not very computationally efficient.)  <a href="#a9585673b8e4a0020717fbe96a0cf0445"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_matrix.html#aa45db306b5d8ed69ba5a71f2fe498f8d">GMatrix</a> (std::vector&lt; size_t &gt; &amp;attrValues, <a class="el" href="class_g_classes_1_1_g_heap.html">GHeap</a> *pHeap=NULL)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a matrix with a mixed relation. That is, one with some continuous attributes (columns), and some nominal attributes (columns). attrValues specifies the number of nominal values suppored in each attribute (column), or 0 for a continuous attribute. Initially, this matrix will have 0 rows, but you can add more rows by calling newRow or newRows.  <a href="#aa45db306b5d8ed69ba5a71f2fe498f8d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_matrix.html#af0cd6e78752ad67a5fd47c268a0631d1">GMatrix</a> (<a class="el" href="class_g_classes_1_1smart__ptr.html">sp_relation</a> &amp;pRelation, <a class="el" href="class_g_classes_1_1_g_heap.html">GHeap</a> *pHeap=NULL)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">pRelation is a smart-pointer to a relation, which specifies the type of each attribute (column) in the data set. Initially, this matrix will have 0 rows, but you can add more rows by calling newRow or newRows.  <a href="#af0cd6e78752ad67a5fd47c268a0631d1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_matrix.html#a8349791d011aa902ee706a2492fe5497">GMatrix</a> (<a class="el" href="class_g_classes_1_1_g_dom_node.html">GDomNode</a> *pNode, <a class="el" href="class_g_classes_1_1_g_heap.html">GHeap</a> *pHeap=NULL)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Load from a DOM.  <a href="#a8349791d011aa902ee706a2492fe5497"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_matrix.html#abea47a0f7f54fc21de9e74bb4920b21d">~GMatrix</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_matrix.html#aad46e9ec8b3e64d46140a79ddfcd3a18">newRow</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a new row to the dataset. (The values in the row are not initialized)  <a href="#aad46e9ec8b3e64d46140a79ddfcd3a18"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_matrix.html#ab95a2e5f6e0853c8100b723c0b04a0e7">newRows</a> (size_t nRows)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds "nRows" uninitialized rows to the data set.  <a href="#ab95a2e5f6e0853c8100b723c0b04a0e7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_matrix.html#a38f337d0a19de0d89e921a305d58b3c4">add</a> (<a class="el" href="class_g_classes_1_1_g_matrix.html">GMatrix</a> *pThat, bool transpose)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Matrix add. Adds the values in pThat to this. (If transpose is true, adds the transpose of pThat to this.) Both datasets must have the same dimensions. Behavior is undefined for nominal columns.  <a href="#a38f337d0a19de0d89e921a305d58b3c4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_g_classes_1_1_g_matrix.html">GMatrix</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_matrix.html#af61cdc8ee72210fb86fbcc5ce14cd377">attrSubset</a> (size_t firstAttr, size_t attrCount)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new dataset that contains a subset of the attributes in this dataset.  <a href="#af61cdc8ee72210fb86fbcc5ce14cd377"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_g_classes_1_1_g_matrix.html">GMatrix</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_matrix.html#a0f1c8bbc22cc90fda7436c8b59f77286">cholesky</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This computes the square root of this matrix. (If you take the matrix that this returns and multiply it by its transpose, you should get the original dataset again.) Behavior is undefined if there are nominal attributes. If this matrix is not positive definate, it will throw an exception.  <a href="#a0f1c8bbc22cc90fda7436c8b59f77286"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_g_classes_1_1_g_matrix.html">GMatrix</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_matrix.html#a3e1673d444453bccaab50f63dfc9697b">clone</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a deep copy of this dataset.  <a href="#a3e1673d444453bccaab50f63dfc9697b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_g_classes_1_1_g_matrix.html">GMatrix</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_matrix.html#a50bd1a6f1b8674200e6b0c05b72b82b6">cloneSub</a> (size_t rowStart, size_t colStart, size_t rowCount, size_t colCount)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a deep copy of the specified rectangular region of this matrix.  <a href="#a50bd1a6f1b8674200e6b0c05b72b82b6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_matrix.html#a1e47e3c45852c349e097a97fcbd96a48">col</a> (size_t index, double *pOutVector)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the specified column into pOutVector.  <a href="#a1e47e3c45852c349e097a97fcbd96a48"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_matrix.html#af6396fe43ffaddb8de01acb294261040">cols</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of columns in the dataset.  <a href="#af6396fe43ffaddb8de01acb294261040"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_matrix.html#a75778fd6da49e21efc4264e08ffaeade">copy</a> (<a class="el" href="class_g_classes_1_1_g_matrix.html">GMatrix</a> *pThat)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies all the data from pThat. (Just references the same relation)  <a href="#a75778fd6da49e21efc4264e08ffaeade"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_matrix.html#a2a1595814c3a3ed5c70269c36d3b859c">copyColumns</a> (size_t nDestStartColumn, <a class="el" href="class_g_classes_1_1_g_matrix.html">GMatrix</a> *pSource, size_t nSourceStartColumn, size_t nColumnCount)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the specified block of columns from pSource to this dataset. pSource must have the same number of rows as this dataset.  <a href="#a2a1595814c3a3ed5c70269c36d3b859c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_matrix.html#ac3253fa91205ff8ea3d2434d6457cb79">copyRow</a> (const double *pRow)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a copy of the row to the data set.  <a href="#ac3253fa91205ff8ea3d2434d6457cb79"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_matrix.html#ac5a93dfebe585d6777779f20308c68b1">determinant</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the determinant of this matrix.  <a href="#ac5a93dfebe585d6777779f20308c68b1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_matrix.html#a60808f8423858403d3d32a6909586836">eigenValue</a> (const double *pEigenVector)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the eigenvalue that corresponds to the specified eigenvector of this matrix.  <a href="#a60808f8423858403d3d32a6909586836"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_matrix.html#acf6d992960f0a96a1e0e099bb6e483ae">eigenVector</a> (double eigenvalue, double *pOutVector)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the eigenvector that corresponds to the specified eigenvalue of this matrix. Note that this method trashes this matrix, so make a copy first if you care.  <a href="#acf6d992960f0a96a1e0e099bb6e483ae"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_matrix.html#a12ecf5d914ffd54f0dad712a24836fcf">gaussianElimination</a> (double *pVector)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes y in the equation M*y=x (or y=M^(-1)x), where M is this dataset, which must be a square matrix, and x is pVector as passed in, and y is pVector after the call. If there are multiple solutions, it finds the one for which all the variables in the null-space have a value of 1. If there are no solutions, it returns false. Note that this method trashes this dataset (so make a copy first if you care).  <a href="#a12ecf5d914ffd54f0dad712a24836fcf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_g_classes_1_1_g_heap.html">GHeap</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_matrix.html#a49934d4ebef97e061d370f3cc990ec1f">heap</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the heap used to allocate rows for this dataset.  <a href="#a49934d4ebef97e061d370f3cc990ec1f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_matrix.html#a7a7aeb47cb054242d3af098e494a0965">LUDecomposition</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs an in-place LU-decomposition, such that the lower triangle of this matrix (including the diagonal) specifies L, and the uppoer triangle of this matrix (not including the diagonal) specifies U, and all values of U along the diagonal are ones. (The upper triangle of L and the lower triangle of U are all zeros.)  <a href="#a7a7aeb47cb054242d3af098e494a0965"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_matrix.html#ade147cd214e8b3e251fad0bdab8c2982">makeIdentity</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this dataset to an identity matrix. (It doesn't change the number of columns or rows. It just stomps over existing values.)  <a href="#ade147cd214e8b3e251fad0bdab8c2982"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_matrix.html#acac2ce92f893fee91980df02622688e6">mirrorTriangle</a> (bool upperToLower)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">If upperToLower is true, copies the upper triangle of this matrix over the lower triangle If upperToLower is false, copies the lower triangle of this matrix over the upper triangle.  <a href="#acac2ce92f893fee91980df02622688e6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_matrix.html#a6e616ccd27cf69ee02cc82a6698d1c57">mergeVert</a> (<a class="el" href="class_g_classes_1_1_g_matrix.html">GMatrix</a> *pData)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Steals all the rows from pData and adds them to this set. (You still have to delete pData.) Both datasets must have the same number of columns.  <a href="#a6e616ccd27cf69ee02cc82a6698d1c57"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_g_classes_1_1_g_matrix.html">GMatrix</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_matrix.html#a63be21347369430296300f8b32e01363">eigs</a> (size_t nCount, double *pEigenVals, <a class="el" href="class_g_classes_1_1_g_rand.html">GRand</a> *pRand, bool mostSignificant)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes nCount eigenvectors and the corresponding eigenvalues using the power method. (This method is only accurate if a small number of eigenvalues/vectors are needed.) If mostSignificant is true, the largest eigenvalues are found. If mostSignificant is false, the smallest eigenvalues are found.  <a href="#a63be21347369430296300f8b32e01363"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_matrix.html#aa6e444b7360b8bdac125be34930940db">multiply</a> (double scalar)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies every element in the dataset by scalar. Behavior is undefined for nominal columns.  <a href="#aa6e444b7360b8bdac125be34930940db"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_matrix.html#a339e1a241c2055e49672eadc7237b8fe">multiply</a> (const double *pVectorIn, double *pVectorOut, bool transpose=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies this matrix by the column vector pVectorIn to get pVectorOut. (If transpose is true, then it multiplies the transpose of this matrix by pVectorIn to get pVectorOut.) pVectorIn should have the same number of elements as columns (or rows if transpose is true) and pVectorOut should have the same number of elements as rows (or cols, if transpose is true.) Note that if transpose is true, it is the same as if pVectorIn is a row vector and you multiply it by this matrix to get pVectorOut.  <a href="#a339e1a241c2055e49672eadc7237b8fe"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_g_classes_1_1_g_matrix.html">GMatrix</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_matrix.html#a473577be149730954c63176a5b6573ea">pseudoInverse</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the Moore-Penrose pseudoinverse of this matrix (using the SVD method). You are responsible to delete the matrix this returns.  <a href="#a473577be149730954c63176a5b6573ea"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_g_classes_1_1smart__ptr.html">sp_relation</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_matrix.html#a77eaf97d52e453b1b40147bfedc85aa9">relation</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a relation object, which holds meta-data about the attributes (columns)  <a href="#a77eaf97d52e453b1b40147bfedc85aa9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_matrix.html#a8288f6e519b774e96feddb0445414c78">reserve</a> (size_t n)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates space for the specified number of patters (to avoid superfluous resizing)  <a href="#a8288f6e519b774e96feddb0445414c78"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_matrix.html#a9448d98edf2a217d369ed10033c4eae2">rows</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of rows in the dataset.  <a href="#a9448d98edf2a217d369ed10033c4eae2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_matrix.html#afe61ef0b4468bd437273fbf31099c761">saveArff</a> (const char *szFilename)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Saves the dataset to a file in ARFF format.  <a href="#afe61ef0b4468bd437273fbf31099c761"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_matrix.html#afd58df6b9655a073686e8d6218258d88">setRelation</a> (<a class="el" href="class_g_classes_1_1smart__ptr.html">sp_relation</a> &amp;pRelation)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the relation for this dataset.  <a href="#afd58df6b9655a073686e8d6218258d88"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_matrix.html#ae6fe4e212ae91d86fb3ccd6a2a343507">singularValueDecomposition</a> (<a class="el" href="class_g_classes_1_1_g_matrix.html">GMatrix</a> **ppU, double **ppDiag, <a class="el" href="class_g_classes_1_1_g_matrix.html">GMatrix</a> **ppV, bool throwIfNoConverge=false, size_t maxIters=80)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs SVD on A, where A is this m-by-n matrix. *ppU will be set to an m-by-m matrix where the columns are the eigenvectors of A(A^T). *ppDiag will be set to an array of n doubles holding the square roots of the corresponding eigenvalues. *ppV will be set to an n-by-n matrix where the rows are the eigenvectors of (A^T)A. You are responsible to delete(*ppU), delete(*ppV), and delete[] *ppDiag.  <a href="#ae6fe4e212ae91d86fb3ccd6a2a343507"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_matrix.html#a31e37f844df5bd88948d6816c9ae36a7">subtract</a> (<a class="el" href="class_g_classes_1_1_g_matrix.html">GMatrix</a> *pThat, bool transpose)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Matrix subtract. Subtracts the values in pThat from this. (If transpose is true, subtracts the transpose of pThat from this.) Both datasets must have the same dimensions. Behavior is undefined for nominal columns.  <a href="#a31e37f844df5bd88948d6816c9ae36a7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_matrix.html#a16754aef670fb4790971a51b5e698ab5">sumSquaredDiffWithIdentity</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the sum squared difference between this matrix and an identity matrix.  <a href="#a16754aef670fb4790971a51b5e698ab5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_matrix.html#afdb6652ac98c0349ad28b1de588a9406">takeRow</a> (double *pRow)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an already-allocated row to this dataset. The row must be allocated in the same heap that this dataset uses. (There is no way for this method to verify that, so be careful.)  <a href="#afdb6652ac98c0349ad28b1de588a9406"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_matrix.html#a4df04b0c88f77cd907c9c4d01107d988">toReducedRowEchelonForm</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the matrix to reduced row echelon form.  <a href="#a4df04b0c88f77cd907c9c4d01107d988"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_matrix.html#a25025c28523e9165808ba8fb97894f1d">toVector</a> (double *pVector)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies all the data from this dataset into pVector. pVector must be big enough to hold <a class="el" href="class_g_classes_1_1_g_matrix.html#a9448d98edf2a217d369ed10033c4eae2" title="Returns the number of rows in the dataset.">rows()</a> x <a class="el" href="class_g_classes_1_1_g_matrix.html#af6396fe43ffaddb8de01acb294261040" title="Returns the number of columns in the dataset.">cols()</a> doubles.  <a href="#a25025c28523e9165808ba8fb97894f1d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_g_classes_1_1_g_dom_node.html">GDomNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_matrix.html#a90747ea872073c76fb9d8629f8c60845">serialize</a> (<a class="el" href="class_g_classes_1_1_g_dom.html">GDom</a> *pDoc)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Marshalls this object to a DOM, which may be saved to a variety of serial formats.  <a href="#a90747ea872073c76fb9d8629f8c60845"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_matrix.html#a337831ebe052692fa5bbc28cf06f405c">trace</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the sum of the diagonal elements.  <a href="#a337831ebe052692fa5bbc28cf06f405c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_g_classes_1_1_g_matrix.html">GMatrix</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_matrix.html#aac04deecc7a90e39046ed486d138f94d">transpose</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a dataset that is this dataset transposed. (All columns in the returned dataset will be continuous.)  <a href="#aac04deecc7a90e39046ed486d138f94d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_matrix.html#ab8d323a4b4e09a7556a504cc89f0004e">fromVector</a> (const double *pVector, size_t nRows)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the data from pVector over this dataset. nRows specifies the number of rows of data in pVector.  <a href="#ab8d323a4b4e09a7556a504cc89f0004e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_matrix.html#a87bbe8281adb693abcd92c7dd67e5bf2">row</a> (size_t index)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the specified row.  <a href="#a87bbe8281adb693abcd92c7dd67e5bf2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_matrix.html#aceead558e83c92a0b76fc57492e34b54">operator[]</a> (size_t index)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the specified row.  <a href="#aceead558e83c92a0b76fc57492e34b54"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_matrix.html#a81c1652544f45d4f7254e9671b84c956">row</a> (size_t index) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const pointer to the specified row.  <a href="#a81c1652544f45d4f7254e9671b84c956"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_matrix.html#a05b809e2e06b7933c26700fdf2f97d59">operator[]</a> (size_t index) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const pointer to the specified row.  <a href="#a05b809e2e06b7933c26700fdf2f97d59"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_matrix.html#a277ad3066b9118d8db3f0c6c0e8c5dd3">setAll</a> (double val)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets all elements in this dataset to the specified value.  <a href="#a277ad3066b9118d8db3f0c6c0e8c5dd3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_matrix.html#ae4e9dd0f7ee61a5205ae34424449eb73">setCol</a> (size_t index, const double *pVector)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies pVector over the specified column.  <a href="#ae4e9dd0f7ee61a5205ae34424449eb73"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_matrix.html#a20fe0b5aa7e6fe100f3594376a38aecf">swapRows</a> (size_t a, size_t b)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the two specified rows.  <a href="#a20fe0b5aa7e6fe100f3594376a38aecf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_matrix.html#af4160fd7dd9ad1e34e86442229fc6e49">swapColumns</a> (size_t nAttr1, size_t nAttr2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps two columns.  <a href="#af4160fd7dd9ad1e34e86442229fc6e49"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_matrix.html#a06b18fc37ac59c6d8589d81cb5659ea2">deleteColumn</a> (size_t index)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes a column.  <a href="#a06b18fc37ac59c6d8589d81cb5659ea2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_matrix.html#a52d75c3f13f55c7dc618f671839eecf5">releaseRow</a> (size_t index)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the specified row with the last row, and then releases it from the dataset. If this dataset does not have its own heap, then you must delete the row this returns.  <a href="#a52d75c3f13f55c7dc618f671839eecf5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_matrix.html#a219ef0044b0bb06820e0cc386fd19cc2">deleteRow</a> (size_t index)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the specified row with the last row, and then deletes it.  <a href="#a219ef0044b0bb06820e0cc386fd19cc2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_matrix.html#a8fc61deb6c65bd43d33f1da0a616d7d9">releaseRowPreserveOrder</a> (size_t index)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases the specified row from the dataset and shifts everything after it up one slot. If this dataset does not have its own heap, then you must delete the row this returns.  <a href="#a8fc61deb6c65bd43d33f1da0a616d7d9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_matrix.html#afb72c4f2c51f4ca1f5e702521e616f64">deleteRowPreserveOrder</a> (size_t index)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the specified row and shifts everything after it up one slot.  <a href="#afb72c4f2c51f4ca1f5e702521e616f64"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_matrix.html#acbf13e5159e9c537b55b52992ac5d690">fixNans</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces any occurrences of NAN in the matrix with the corresponding values from an identity matrix.  <a href="#acbf13e5159e9c537b55b52992ac5d690"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_matrix.html#af3c0eb63b018c99353bfa8a571025149">flush</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes all the data.  <a href="#af3c0eb63b018c99353bfa8a571025149"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_matrix.html#a300e36efd9c810d05eadfef2312bcfcf">releaseAllRows</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Abandons (leaks) all the rows of data.  <a href="#a300e36efd9c810d05eadfef2312bcfcf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_matrix.html#a344b876d45a4cc4e8ecc8af82d06454d">shuffle</a> (<a class="el" href="class_g_classes_1_1_g_rand.html">GRand</a> &amp;rand, <a class="el" href="class_g_classes_1_1_g_matrix.html">GMatrix</a> *pExtension=NULL)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Randomizes the order of the rows. If pExtension is non-NULL, then it will also be shuffled such that corresponding rows are preserved.  <a href="#a344b876d45a4cc4e8ecc8af82d06454d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_matrix.html#adc01b3c5afc537ff34044725660b57b3">shuffle2</a> (<a class="el" href="class_g_classes_1_1_g_rand.html">GRand</a> &amp;rand, <a class="el" href="class_g_classes_1_1_g_matrix.html">GMatrix</a> &amp;other)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Shuffles the order of the rows. Also shuffles the rows in "other" in the same way, such that corresponding rows are preserved.  <a href="#adc01b3c5afc537ff34044725660b57b3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_matrix.html#ab35ea0670e830ee273de92be6848b7f0">shuffleLikeCards</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an inferior way to shuffle the data.  <a href="#ab35ea0670e830ee273de92be6848b7f0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_matrix.html#ab6ec079268e779f326b3cf8004b693a6">sort</a> (size_t nDimension)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts the data from smallest to largest in the specified dimension.  <a href="#ab6ec079268e779f326b3cf8004b693a6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_matrix.html#a58f089b462c00382a88ff7c50da0a84b">sortPartial</a> (size_t row, size_t col)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This partially sorts the specified column, such that the specified row will contain the same row as if it were fully sorted, and previous rows will contain a value &lt;= to it in that column, and later rows will contain a value &gt;= to it in that column. Unlike sort, which has O(m*log(m)) complexity, this method has O(m) complexity. This might be useful, for example, for efficiently finding the row with a median value in some attribute, or for separating data by a threshold in some value.  <a href="#a58f089b462c00382a88ff7c50da0a84b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_matrix.html#a33a18f9bc5b1a0f72143c4dc3707a81a">reverseRows</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverses the row order.  <a href="#a33a18f9bc5b1a0f72143c4dc3707a81a"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename CompareFunc &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_matrix.html#a4e100f07f11233bffdcd8453556e04cd">sort</a> (CompareFunc &amp;pComparator)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts rows according to the specified compare function. (Return true to indicate thate the first row comes before the second row.)  <a href="#a4e100f07f11233bffdcd8453556e04cd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_matrix.html#a5f1f02db566939d9ce1f64b3c12c1d63">splitByPivot</a> (<a class="el" href="class_g_classes_1_1_g_matrix.html">GMatrix</a> *pGreaterOrEqual, size_t nAttribute, double dPivot, <a class="el" href="class_g_classes_1_1_g_matrix.html">GMatrix</a> *pExtensionA=NULL, <a class="el" href="class_g_classes_1_1_g_matrix.html">GMatrix</a> *pExtensionB=NULL)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits this set of data into two sets. Values greater-than-or-equal-to dPivot stay in this data set. Values less than dPivot go into pLessThanPivot If pExtensionA is non-NULL, then it will also split pExtensionA such that corresponding rows are preserved.  <a href="#a5f1f02db566939d9ce1f64b3c12c1d63"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_matrix.html#a0f14efc735dab677949be5c7bcff5131">splitByNominalValue</a> (<a class="el" href="class_g_classes_1_1_g_matrix.html">GMatrix</a> *pSingleClass, size_t nAttr, int nValue, <a class="el" href="class_g_classes_1_1_g_matrix.html">GMatrix</a> *pExtensionA=NULL, <a class="el" href="class_g_classes_1_1_g_matrix.html">GMatrix</a> *pExtensionB=NULL)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves all rows with the specified value in the specified attribute into pSingleClass If pExtensionA is non-NULL, then it will also split pExtensionA such that corresponding rows are preserved.  <a href="#a0f14efc735dab677949be5c7bcff5131"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_matrix.html#a7a6e0b3eb7ef23b102b7222918b2eb63">splitBySize</a> (<a class="el" href="class_g_classes_1_1_g_matrix.html">GMatrix</a> *pOtherData, size_t nOtherRows)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the last nOtherRows rows from this data set and puts them in pOtherData.  <a href="#a7a6e0b3eb7ef23b102b7222918b2eb63"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_matrix.html#a43ac1654ca284f73db7a49ce4abc7bb8">entropy</a> (size_t nColumn)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Measures the entropy of the specified attribute.  <a href="#a43ac1654ca284f73db7a49ce4abc7bb8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_matrix.html#a67e544c95ffd01e308736f789f8c2010">minAndRange</a> (size_t nAttribute, double *pMin, double *pRange)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the min and the range of the values of the specified attribute.  <a href="#a67e544c95ffd01e308736f789f8c2010"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_matrix.html#a4f253d5e2e7eef785a9087bc262f0285">minAndRangeUnbiased</a> (size_t nAttribute, double *pMin, double *pRange)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Estimates the actual min and range based on a random sample.  <a href="#a4f253d5e2e7eef785a9087bc262f0285"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_matrix.html#a5b8b6ba273c42ab0a4cd2f0a2b2b84fa">centerMeanAtOrigin</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Shifts the data such that the mean occurs at the origin. Only continuous values are affected. Nominal values are left unchanged.  <a href="#a5b8b6ba273c42ab0a4cd2f0a2b2b84fa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_matrix.html#ac0e058b693f83e1329ecd1ad0daa15b3">mean</a> (size_t nAttribute)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the arithmetic mean of the values in the specified column.  <a href="#ac0e058b693f83e1329ecd1ad0daa15b3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_matrix.html#afb3ab2e6345a62d29f8c504d907f0517">median</a> (size_t nAttribute)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the median of the values in the specified column.  <a href="#afb3ab2e6345a62d29f8c504d907f0517"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_matrix.html#a4787af3bb76a4ca4cfaca77c4c0cec63">centroid</a> (double *pOutCentroid)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the arithmetic means of all attributes.  <a href="#a4787af3bb76a4ca4cfaca77c4c0cec63"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_matrix.html#a8d2de6c2e0216b35405958e1d57777e9">variance</a> (size_t nAttr, double mean)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the average variance of a single attribute.  <a href="#a8d2de6c2e0216b35405958e1d57777e9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_matrix.html#a40fb549127a96969e2f26301d52a68f3">normalize</a> (size_t nAttribute, double dInputMin, double dInputRange, double dOutputMin, double dOutputRange)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalizes the specified attribute values.  <a href="#a40fb549127a96969e2f26301d52a68f3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_matrix.html#a66169562bbd6de3d8d7fe19f56118dd4">baselineValue</a> (size_t nAttribute)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the mean if the specified attribute is continuous, otherwise returns the most common nominal value in the attribute.  <a href="#a66169562bbd6de3d8d7fe19f56118dd4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_matrix.html#a1b82122448449e486aff4464087d77f5">isAttrHomogenous</a> (size_t col)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true iff the specified attribute contains homogenous values. (Unknowns are counted as homogenous with anything)  <a href="#a1b82122448449e486aff4464087d77f5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_matrix.html#a99ea54efe0219078e1c000c2a354b61c">isHomogenous</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true iff each of the last labelDims columns in the data are homogenous.  <a href="#a99ea54efe0219078e1c000c2a354b61c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_matrix.html#a16abfe7b0f07819772e397dd526015a7">replaceMissingValuesWithBaseline</a> (size_t nAttr)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">If the specified attribute is continuous, replaces all missing values in that attribute with the mean. If the specified attribute is nominal, replaces all missing values in that attribute with the most common value.  <a href="#a16abfe7b0f07819772e397dd526015a7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_matrix.html#a12066bcfb23c258cc88224079706bf32">replaceMissingValuesRandomly</a> (size_t nAttr, <a class="el" href="class_g_classes_1_1_g_rand.html">GRand</a> *pRand)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces all missing values by copying a randomly selected non-missing value in the same attribute.  <a href="#a12066bcfb23c258cc88224079706bf32"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_matrix.html#a44abadfdc20007095a5cc79955af5291">principalComponent</a> (double *pOutVector, size_t dims, const double *pMean, <a class="el" href="class_g_classes_1_1_g_rand.html">GRand</a> *pRand)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an efficient algorithm for iteratively computing the principal component vector (the eigenvector of the covariance matrix) of the data. See "EM Algorithms for PCA and SPCA" by Sam Roweis, 1998 NIPS. nIterations should be a small constant. 20 seems work well for most applications. (To compute the next principal component, call RemoveComponent, then call this again.)  <a href="#a44abadfdc20007095a5cc79955af5291"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_matrix.html#a997fc57c3d38c6de44b04a5e47e8f7fb">principalComponentAboutOrigin</a> (double *pOutVector, size_t dims, <a class="el" href="class_g_classes_1_1_g_rand.html">GRand</a> *pRand)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the first principal component assuming the mean is already subtracted out of the data.  <a href="#a997fc57c3d38c6de44b04a5e47e8f7fb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_matrix.html#ace8040345a7602b694277b0496be53c5">principalComponentIgnoreUnknowns</a> (double *pOutVector, size_t dims, const double *pMean, <a class="el" href="class_g_classes_1_1_g_rand.html">GRand</a> *pRand)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes principal components, while ignoring missing values.  <a href="#ace8040345a7602b694277b0496be53c5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_matrix.html#ade5979bfc6a8fc0a7eb3ea4a6b151443">weightedPrincipalComponent</a> (double *pOutVector, size_t dims, const double *pMean, const double *pWeights, <a class="el" href="class_g_classes_1_1_g_rand.html">GRand</a> *pRand)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the first principal component of the data with each row weighted according to the vector pWeights. (pWeights must have an element for each row.)  <a href="#ade5979bfc6a8fc0a7eb3ea4a6b151443"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_matrix.html#aca9c8c46425382c90437dd8c05286755">eigenValue</a> (const double *pMean, const double *pEigenVector, size_t dims, <a class="el" href="class_g_classes_1_1_g_rand.html">GRand</a> *pRand)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">After you compute the principal component, you can call this to obtain the eigenvalue that corresponds to that principal component vector (eigenvector).  <a href="#aca9c8c46425382c90437dd8c05286755"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_matrix.html#aae7407dddee6588049520326919e41bd">removeComponent</a> (const double *pMean, const double *pComponent, size_t dims)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the component specified by pComponent from the data. (pComponent should already be normalized.) This might be useful, for example, to remove the first principal component from the data so you can then proceed to compute the second principal component, and so forth.  <a href="#aae7407dddee6588049520326919e41bd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_matrix.html#a8a0c880d06946cf322891bf9eb1644c8">removeComponentAboutOrigin</a> (const double *pComponent, size_t dims)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the specified component assuming the mean is zero.  <a href="#a8a0c880d06946cf322891bf9eb1644c8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_matrix.html#a1a862a989426b7ca7c53e92645f04754">countPrincipalComponents</a> (double d, <a class="el" href="class_g_classes_1_1_g_rand.html">GRand</a> *pRand)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the minimum number of principal components necessary so that less than the specified portion of the deviation in the data is unaccounted for. (For example, if the data projected onto the first 3 principal components contains 90 percent of the deviation that the original data contains, then if you pass the value 0.1 to this method, it will return 3.)  <a href="#a1a862a989426b7ca7c53e92645f04754"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_matrix.html#aafd972d670f6bc8b7cbfb347db4b0223">sumSquaredDistance</a> (const double *pPoint)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the sum-squared distance between pPoint and all of the points in the dataset. (If pPoint is NULL, it computes the sum-squared distance with the origin.) (Note that this is equal to the sum of all the eigenvalues times the number of dimensions, so you can efficiently compute eigenvalues as the difference in sumSquaredDistance with the mean after removing the corresponding component, and then dividing by the number of dimensions. This is more efficient than calling eigenValue.)  <a href="#aafd972d670f6bc8b7cbfb347db4b0223"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_matrix.html#a7c29d402101fff0671937fb2f31f69d8">columnSumSquaredDifference</a> (<a class="el" href="class_g_classes_1_1_g_matrix.html">GMatrix</a> &amp;that, size_t col)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the sum-squared distance between the specified column of this and that. If the column is a nominal attribute, then Hamming distance is used.  <a href="#a7c29d402101fff0671937fb2f31f69d8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_matrix.html#a29eb55ee2e82d0797e59c501cf4042dd">sumSquaredDifference</a> (<a class="el" href="class_g_classes_1_1_g_matrix.html">GMatrix</a> &amp;that, bool transpose=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the squared distance between this and that. (If transpose is true, computes the difference between this and the transpose of that.)  <a href="#a29eb55ee2e82d0797e59c501cf4042dd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_matrix.html#a01975a05529c9bab6e6863f1afc96aa7">linearCorrelationCoefficient</a> (size_t attr1, double attr1Origin, size_t attr2, double attr2Origin)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the linear coefficient between the two specified attributes. Usually you will want to pass the mean values for attr1Origin and attr2Origin.  <a href="#a01975a05529c9bab6e6863f1afc96aa7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_matrix.html#af4437c6da0d84bf9b2fc5085bbf41b85">covariance</a> (size_t nAttr1, double dMean1, size_t nAttr2, double dMean2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the covariance between two attributes.  <a href="#af4437c6da0d84bf9b2fc5085bbf41b85"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_g_classes_1_1_g_matrix.html">GMatrix</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_matrix.html#a7c29bec3b0a3cff98b298455fff6158f">covarianceMatrix</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the covariance matrix of the data.  <a href="#a7c29bec3b0a3cff98b298455fff6158f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_matrix.html#a2c0be33814a7c836cc6fca764526b5a7">pairedTTest</a> (size_t *pOutV, double *pOutT, size_t attr1, size_t attr2, bool normalize)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a paired T-Test with data from the two specified attributes. pOutV will hold the degrees of freedom. pOutT will hold the T-value. You can use <a class="el" href="class_g_classes_1_1_g_math.html#aec60dab8f29c6062fe2965481fa3b681" title="Computes the p-value from the degrees of freedom, and the t-value obtained from a T-test...">GMath::tTestAlphaValue</a> to convert these to a P-value.  <a href="#a2c0be33814a7c836cc6fca764526b5a7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_matrix.html#abc4a3adbe1229365b22f578853832475">wilcoxonSignedRanksTest</a> (size_t attr1, size_t attr2, double tolerance, int *pNum, double *pWMinus, double *pWPlus)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the Wilcoxon signed ranks test from the two specified attributes. If two values are closer than tolerance, they are considered to be equal.  <a href="#abc4a3adbe1229365b22f578853832475"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_matrix.html#a84540a96fb0f06f985a4cd1fbda1bac4">print</a> (std::ostream &amp;stream)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints the data to the specified stream.  <a href="#a84540a96fb0f06f985a4cd1fbda1bac4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_matrix.html#a628ed2a08f6e4007413a05e066ccbb27">countValue</a> (size_t attribute, double value)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of ocurrences of the specified value in the specified attribute.  <a href="#a628ed2a08f6e4007413a05e066ccbb27"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_matrix.html#add3e27857ad14b2701a45a5b981f8918">doesHaveAnyMissingValues</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true iff this matrix is missing any values.  <a href="#add3e27857ad14b2701a45a5b981f8918"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_matrix.html#a78c7d1f46af67b0a4e68de461a047fe4">ensureDataHasNoMissingReals</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Throws an exception if this data contains any missing values in a continuous attribute.  <a href="#a78c7d1f46af67b0a4e68de461a047fe4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_matrix.html#abbc2296291825bb6dd8a641e098deee5">ensureDataHasNoMissingNominals</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Throws an exception if this data contains any missing values in a nominal attribute.  <a href="#abbc2296291825bb6dd8a641e098deee5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_matrix.html#a958c591bdbd5f1d567ed59b85b65e09e">measureInfo</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the sum entropy of the data (or the sum variance for continuous attributes)  <a href="#a958c591bdbd5f1d567ed59b85b65e09e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_matrix.html#a4db136daf8ab068bdacaa7691cea583f">leastCorrelatedVector</a> (double *pOut, <a class="el" href="class_g_classes_1_1_g_matrix.html">GMatrix</a> *pThat, <a class="el" href="class_g_classes_1_1_g_rand.html">GRand</a> *pRand)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the vector in this subspace that has the greatest distance from its projection into pThat subspace. Returns true if the results are computed. Returns false if the subspaces are so nearly parallel that pOut cannot be computed with accuracy.  <a href="#a4db136daf8ab068bdacaa7691cea583f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_matrix.html#a1aac64bb9693435a7392186d9df41dd1">dihedralCorrelation</a> (<a class="el" href="class_g_classes_1_1_g_matrix.html">GMatrix</a> *pThat, <a class="el" href="class_g_classes_1_1_g_rand.html">GRand</a> *pRand)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the cosine of the dihedral angle between this subspace and pThat subspace.  <a href="#a1aac64bb9693435a7392186d9df41dd1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_matrix.html#ab3c00937aa1e8bbd1f162a4ef50cacf2">project</a> (double *pDest, const double *pPoint)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Projects pPoint onto this hyperplane (where each row defines one of the orthonormal basis vectors of this hyperplane) This computes (A^T)Ap, where A is this matrix, and p is pPoint.  <a href="#ab3c00937aa1e8bbd1f162a4ef50cacf2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_matrix.html#a6761dcc3e46e9bfc18e1a2efa8378971">project</a> (double *pDest, const double *pPoint, const double *pOrigin)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Projects pPoint onto this hyperplane (where each row defines one of the orthonormal basis vectors of this hyperplane)  <a href="#a6761dcc3e46e9bfc18e1a2efa8378971"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_g_classes_1_1_g_matrix.html">GMatrix</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_matrix.html#a910f021497c3beb4db7bbb351bb67ced">kabsch</a> (<a class="el" href="class_g_classes_1_1_g_matrix.html">GMatrix</a> *pA, <a class="el" href="class_g_classes_1_1_g_matrix.html">GMatrix</a> *pB)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This computes K=kabsch(A,B), such that K is an n-by-n matrix, where n is pA-&gt;<a class="el" href="class_g_classes_1_1_g_matrix.html#af6396fe43ffaddb8de01acb294261040" title="Returns the number of columns in the dataset.">cols()</a>. K is the optimal orthonormal rotation matrix to align A and B, such that A(K^T) minimizes sum-squared error with B, and BK minimizes sum-squared error with A. (This rotates around the origin, so typically you will want to subtract the centroid from both pA and pB before calling this.)  <a href="#a910f021497c3beb4db7bbb351bb67ced"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_g_classes_1_1_g_matrix.html">GMatrix</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_matrix.html#aa6d2457595fa501d2b7c7ae8dd3e4d70">align</a> (<a class="el" href="class_g_classes_1_1_g_matrix.html">GMatrix</a> *pA, <a class="el" href="class_g_classes_1_1_g_matrix.html">GMatrix</a> *pB)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This uses the Kabsch algorithm to rotate and translate pB in order to minimize RMS with pA. (pA and pB must have the same number of rows and columns.)  <a href="#aa6d2457595fa501d2b7c7ae8dd3e4d70"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_g_classes_1_1_g_matrix.html">GMatrix</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_matrix.html#ac22c1d25682bef2d6f07453c21211a44">loadArff</a> (const char *szFilename)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads an ARFF file and returns the data. This will throw an exception if there's an error.  <a href="#ac22c1d25682bef2d6f07453c21211a44"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_g_classes_1_1_g_matrix.html">GMatrix</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_matrix.html#a346b8aef6930fdf3243d5bd720291ce4">loadCsv</a> (const char *szFilename, char separator, bool columnNamesInFirstRow, bool tolerant)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads a file in CSV format.  <a href="#a346b8aef6930fdf3243d5bd720291ce4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_g_classes_1_1_g_matrix.html">GMatrix</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_matrix.html#ab164825999b41aa808a371093031cdfb">mergeHoriz</a> (<a class="el" href="class_g_classes_1_1_g_matrix.html">GMatrix</a> *pSetA, <a class="el" href="class_g_classes_1_1_g_matrix.html">GMatrix</a> *pSetB)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Merges two datasets side-by-side. The resulting dataset will contain the attributes of both datasets. Both pSetA and pSetB (and the resulting dataset) must have the same number of rows.  <a href="#ab164825999b41aa808a371093031cdfb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_g_classes_1_1_g_matrix.html">GMatrix</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_matrix.html#a02a31c4006a12091a327143960b080c4">multiply</a> (<a class="el" href="class_g_classes_1_1_g_matrix.html">GMatrix</a> &amp;a, <a class="el" href="class_g_classes_1_1_g_matrix.html">GMatrix</a> &amp;b, bool transposeA, bool transposeB)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Matrix multiply. For convenience, you can also specify that neither, one, or both of the inputs are virtually transposed prior to the multiplication. (If you want the results to come out transposed, you can use the equality AB=((B^T)(A^T))^T to figure out how to specify the parameters.)  <a href="#a02a31c4006a12091a327143960b080c4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_g_classes_1_1_g_matrix.html">GMatrix</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_matrix.html#ab48e68f88ce77a26913a630e0a7f0ced">parseArff</a> (const char *szFile, size_t nLen)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses an ARFF file and returns the data. This will throw an exception if there's an error.  <a href="#ab48e68f88ce77a26913a630e0a7f0ced"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_g_classes_1_1_g_matrix.html">GMatrix</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_matrix.html#a08432364a17fcd1842b27d803427f789">parseCsv</a> (const char *pFile, size_t len, char separator, bool columnNamesInFirstRow, bool tolerant=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Imports data from a text file. Determines the meta-data automatically. Note: This method does not support Mac line-endings. You should first replace all '' with '<br/>
' if your data comes from a Mac. As a special case, if separator is '\0', then it assumes data elements are separated by any number of whitespace characters, that element values themselves contain no whitespace, and that there are no missing elements. (This is the case when you save a Matlab matrix to an ascii file.)  <a href="#a08432364a17fcd1842b27d803427f789"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_matrix.html#aec001a18e2e8bb14ee5c905e6ead1a34">normalize</a> (double dVal, double dInputMin, double dInputRange, double dOutputMin, double dOutputRange)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalize a value from the input min and range to the output min and range.  <a href="#aec001a18e2e8bb14ee5c905e6ead1a34"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static size_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_matrix.html#a5c1f65da12cc2622ecda6eb4404c7d9e">bipartiteMatching</a> (<a class="el" href="class_g_classes_1_1_g_matrix.html">GMatrix</a> &amp;a, <a class="el" href="class_g_classes_1_1_g_matrix.html">GMatrix</a> &amp;b, <a class="el" href="class_g_classes_1_1_g_distance_metric.html">GDistanceMetric</a> &amp;metric, size_t k=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs bipartite matching of the rows in the specified matrices. 'a' and 'b' must have the same number of columns. 'b' must have at least as many rows as 'a'. Returns an array of indexes, i[], where i[j] is the row in b that corresponds with row j of a. "metric" is the distance metric that will be minimized. For example, if metric computes the squared distance between two vectors, then this method will find the pairings that minimize sum squared distance. k specifies the number of nearest-neighbors of each row to consider as candidates for pairing. If k is equal to the number of rows in a, then optimal pairings are guaranteed. If k is smaller, then results will be obtained faster, but optimal results are not guaranteed. (An efficient neighbor-finder that assumes metric conforms to the triangle inequality is used to find neighbors.) If the number of columns is not too big, then small values for k will usually return optimal or near-optimal results anyway. sqrt(rows) might be a good general value to use for k. As a special value, if k is 0, then all pairs are considered, and optimal results are guaranteed.  <a href="#a5c1f65da12cc2622ecda6eb4404c7d9e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_matrix.html#a0d8cf6317b96b79e093e6a011391fca5">test</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs unit tests for this class. Throws an exception if there is a failure.  <a href="#a0d8cf6317b96b79e093e6a011391fca5"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_matrix.html#a6362aa03508616ca4dcd66c64b61016a">determinantHelper</a> (size_t nEndRow, size_t *pColumnList)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_matrix.html#ab79aec20a82e9589f070485b8a5d5169">inPlaceSquareTranspose</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_matrix.html#afcabc1b1143efd60e3080a6065fe09b8">singularValueDecompositionHelper</a> (<a class="el" href="class_g_classes_1_1_g_matrix.html">GMatrix</a> **ppU, double **ppDiag, <a class="el" href="class_g_classes_1_1_g_matrix.html">GMatrix</a> **ppV, bool throwIfNoConverge, size_t maxIters)</td></tr>
<tr><td colspan="2"><h2><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_g_classes_1_1smart__ptr.html">sp_relation</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_matrix.html#a3961e66a81e83e7b727d9e12f9396fd8">m_pRelation</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_g_classes_1_1_g_heap.html">GHeap</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_matrix.html#ac2837eb4e0de70e6d5c8a0e2022d2fb9">m_pHeap</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::vector&lt; double * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_matrix.html#a966445d1d7e2c55f547641cf5233409d">m_rows</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Represents a matrix or a database table. Elements can be discrete or continuous. References a <a class="el" href="class_g_classes_1_1_g_relation.html" title="Holds the metadata for a dataset, including which attributes are continuous or nominal, and how many values each nominal attribute supports.">GRelation</a> object, which stores the meta-information about each column. </p>
</div><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a9585673b8e4a0020717fbe96a0cf0445"></a><!-- doxytag: member="GClasses::GMatrix::GMatrix" ref="a9585673b8e4a0020717fbe96a0cf0445" args="(size_t rows, size_t cols, GHeap *pHeap=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GClasses::GMatrix::GMatrix </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_g_classes_1_1_g_heap.html">GHeap</a> *&#160;</td>
          <td class="paramname"><em>pHeap</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct a rows x cols matrix. All elements of the matrix are assumed to be continuous. (It is okay to initially set rows to 0 and later call newRow to add each row. Adding columns later, however, is not very computationally efficient.) </p>

</div>
</div>
<a class="anchor" id="aa45db306b5d8ed69ba5a71f2fe498f8d"></a><!-- doxytag: member="GClasses::GMatrix::GMatrix" ref="aa45db306b5d8ed69ba5a71f2fe498f8d" args="(std::vector&lt; size_t &gt; &amp;attrValues, GHeap *pHeap=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GClasses::GMatrix::GMatrix </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>attrValues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_g_classes_1_1_g_heap.html">GHeap</a> *&#160;</td>
          <td class="paramname"><em>pHeap</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct a matrix with a mixed relation. That is, one with some continuous attributes (columns), and some nominal attributes (columns). attrValues specifies the number of nominal values suppored in each attribute (column), or 0 for a continuous attribute. Initially, this matrix will have 0 rows, but you can add more rows by calling newRow or newRows. </p>

</div>
</div>
<a class="anchor" id="af0cd6e78752ad67a5fd47c268a0631d1"></a><!-- doxytag: member="GClasses::GMatrix::GMatrix" ref="af0cd6e78752ad67a5fd47c268a0631d1" args="(sp_relation &amp;pRelation, GHeap *pHeap=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GClasses::GMatrix::GMatrix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_g_classes_1_1smart__ptr.html">sp_relation</a> &amp;&#160;</td>
          <td class="paramname"><em>pRelation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_g_classes_1_1_g_heap.html">GHeap</a> *&#160;</td>
          <td class="paramname"><em>pHeap</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>pRelation is a smart-pointer to a relation, which specifies the type of each attribute (column) in the data set. Initially, this matrix will have 0 rows, but you can add more rows by calling newRow or newRows. </p>

</div>
</div>
<a class="anchor" id="a8349791d011aa902ee706a2492fe5497"></a><!-- doxytag: member="GClasses::GMatrix::GMatrix" ref="a8349791d011aa902ee706a2492fe5497" args="(GDomNode *pNode, GHeap *pHeap=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GClasses::GMatrix::GMatrix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_g_classes_1_1_g_dom_node.html">GDomNode</a> *&#160;</td>
          <td class="paramname"><em>pNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_g_classes_1_1_g_heap.html">GHeap</a> *&#160;</td>
          <td class="paramname"><em>pHeap</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Load from a DOM. </p>

</div>
</div>
<a class="anchor" id="abea47a0f7f54fc21de9e74bb4920b21d"></a><!-- doxytag: member="GClasses::GMatrix::~GMatrix" ref="abea47a0f7f54fc21de9e74bb4920b21d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GClasses::GMatrix::~GMatrix </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a38f337d0a19de0d89e921a305d58b3c4"></a><!-- doxytag: member="GClasses::GMatrix::add" ref="a38f337d0a19de0d89e921a305d58b3c4" args="(GMatrix *pThat, bool transpose)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GClasses::GMatrix::add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_g_classes_1_1_g_matrix.html">GMatrix</a> *&#160;</td>
          <td class="paramname"><em>pThat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>transpose</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Matrix add. Adds the values in pThat to this. (If transpose is true, adds the transpose of pThat to this.) Both datasets must have the same dimensions. Behavior is undefined for nominal columns. </p>

</div>
</div>
<a class="anchor" id="aa6d2457595fa501d2b7c7ae8dd3e4d70"></a><!-- doxytag: member="GClasses::GMatrix::align" ref="aa6d2457595fa501d2b7c7ae8dd3e4d70" args="(GMatrix *pA, GMatrix *pB)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_g_classes_1_1_g_matrix.html">GMatrix</a>* GClasses::GMatrix::align </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_g_classes_1_1_g_matrix.html">GMatrix</a> *&#160;</td>
          <td class="paramname"><em>pA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_g_classes_1_1_g_matrix.html">GMatrix</a> *&#160;</td>
          <td class="paramname"><em>pB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This uses the Kabsch algorithm to rotate and translate pB in order to minimize RMS with pA. (pA and pB must have the same number of rows and columns.) </p>

</div>
</div>
<a class="anchor" id="af61cdc8ee72210fb86fbcc5ce14cd377"></a><!-- doxytag: member="GClasses::GMatrix::attrSubset" ref="af61cdc8ee72210fb86fbcc5ce14cd377" args="(size_t firstAttr, size_t attrCount)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_g_classes_1_1_g_matrix.html">GMatrix</a>* GClasses::GMatrix::attrSubset </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>firstAttr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>attrCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a new dataset that contains a subset of the attributes in this dataset. </p>

</div>
</div>
<a class="anchor" id="a66169562bbd6de3d8d7fe19f56118dd4"></a><!-- doxytag: member="GClasses::GMatrix::baselineValue" ref="a66169562bbd6de3d8d7fe19f56118dd4" args="(size_t nAttribute)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double GClasses::GMatrix::baselineValue </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nAttribute</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the mean if the specified attribute is continuous, otherwise returns the most common nominal value in the attribute. </p>

</div>
</div>
<a class="anchor" id="a5c1f65da12cc2622ecda6eb4404c7d9e"></a><!-- doxytag: member="GClasses::GMatrix::bipartiteMatching" ref="a5c1f65da12cc2622ecda6eb4404c7d9e" args="(GMatrix &amp;a, GMatrix &amp;b, GDistanceMetric &amp;metric, size_t k=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static size_t* GClasses::GMatrix::bipartiteMatching </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_g_classes_1_1_g_matrix.html">GMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_g_classes_1_1_g_matrix.html">GMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_g_classes_1_1_g_distance_metric.html">GDistanceMetric</a> &amp;&#160;</td>
          <td class="paramname"><em>metric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>k</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Performs bipartite matching of the rows in the specified matrices. 'a' and 'b' must have the same number of columns. 'b' must have at least as many rows as 'a'. Returns an array of indexes, i[], where i[j] is the row in b that corresponds with row j of a. "metric" is the distance metric that will be minimized. For example, if metric computes the squared distance between two vectors, then this method will find the pairings that minimize sum squared distance. k specifies the number of nearest-neighbors of each row to consider as candidates for pairing. If k is equal to the number of rows in a, then optimal pairings are guaranteed. If k is smaller, then results will be obtained faster, but optimal results are not guaranteed. (An efficient neighbor-finder that assumes metric conforms to the triangle inequality is used to find neighbors.) If the number of columns is not too big, then small values for k will usually return optimal or near-optimal results anyway. sqrt(rows) might be a good general value to use for k. As a special value, if k is 0, then all pairs are considered, and optimal results are guaranteed. </p>

</div>
</div>
<a class="anchor" id="a5b8b6ba273c42ab0a4cd2f0a2b2b84fa"></a><!-- doxytag: member="GClasses::GMatrix::centerMeanAtOrigin" ref="a5b8b6ba273c42ab0a4cd2f0a2b2b84fa" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GClasses::GMatrix::centerMeanAtOrigin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Shifts the data such that the mean occurs at the origin. Only continuous values are affected. Nominal values are left unchanged. </p>

</div>
</div>
<a class="anchor" id="a4787af3bb76a4ca4cfaca77c4c0cec63"></a><!-- doxytag: member="GClasses::GMatrix::centroid" ref="a4787af3bb76a4ca4cfaca77c4c0cec63" args="(double *pOutCentroid)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GClasses::GMatrix::centroid </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>pOutCentroid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes the arithmetic means of all attributes. </p>

</div>
</div>
<a class="anchor" id="a0f1c8bbc22cc90fda7436c8b59f77286"></a><!-- doxytag: member="GClasses::GMatrix::cholesky" ref="a0f1c8bbc22cc90fda7436c8b59f77286" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_g_classes_1_1_g_matrix.html">GMatrix</a>* GClasses::GMatrix::cholesky </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This computes the square root of this matrix. (If you take the matrix that this returns and multiply it by its transpose, you should get the original dataset again.) Behavior is undefined if there are nominal attributes. If this matrix is not positive definate, it will throw an exception. </p>

</div>
</div>
<a class="anchor" id="a3e1673d444453bccaab50f63dfc9697b"></a><!-- doxytag: member="GClasses::GMatrix::clone" ref="a3e1673d444453bccaab50f63dfc9697b" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_g_classes_1_1_g_matrix.html">GMatrix</a>* GClasses::GMatrix::clone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Makes a deep copy of this dataset. </p>

</div>
</div>
<a class="anchor" id="a50bd1a6f1b8674200e6b0c05b72b82b6"></a><!-- doxytag: member="GClasses::GMatrix::cloneSub" ref="a50bd1a6f1b8674200e6b0c05b72b82b6" args="(size_t rowStart, size_t colStart, size_t rowCount, size_t colCount)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_g_classes_1_1_g_matrix.html">GMatrix</a>* GClasses::GMatrix::cloneSub </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>rowStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>colStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>rowCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>colCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Makes a deep copy of the specified rectangular region of this matrix. </p>

</div>
</div>
<a class="anchor" id="a1e47e3c45852c349e097a97fcbd96a48"></a><!-- doxytag: member="GClasses::GMatrix::col" ref="a1e47e3c45852c349e097a97fcbd96a48" args="(size_t index, double *pOutVector)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GClasses::GMatrix::col </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>pOutVector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copies the specified column into pOutVector. </p>

</div>
</div>
<a class="anchor" id="af6396fe43ffaddb8de01acb294261040"></a><!-- doxytag: member="GClasses::GMatrix::cols" ref="af6396fe43ffaddb8de01acb294261040" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t GClasses::GMatrix::cols </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the number of columns in the dataset. </p>

</div>
</div>
<a class="anchor" id="a7c29d402101fff0671937fb2f31f69d8"></a><!-- doxytag: member="GClasses::GMatrix::columnSumSquaredDifference" ref="a7c29d402101fff0671937fb2f31f69d8" args="(GMatrix &amp;that, size_t col)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double GClasses::GMatrix::columnSumSquaredDifference </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_g_classes_1_1_g_matrix.html">GMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>that</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>col</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes the sum-squared distance between the specified column of this and that. If the column is a nominal attribute, then Hamming distance is used. </p>

</div>
</div>
<a class="anchor" id="a75778fd6da49e21efc4264e08ffaeade"></a><!-- doxytag: member="GClasses::GMatrix::copy" ref="a75778fd6da49e21efc4264e08ffaeade" args="(GMatrix *pThat)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GClasses::GMatrix::copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_g_classes_1_1_g_matrix.html">GMatrix</a> *&#160;</td>
          <td class="paramname"><em>pThat</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copies all the data from pThat. (Just references the same relation) </p>

</div>
</div>
<a class="anchor" id="a2a1595814c3a3ed5c70269c36d3b859c"></a><!-- doxytag: member="GClasses::GMatrix::copyColumns" ref="a2a1595814c3a3ed5c70269c36d3b859c" args="(size_t nDestStartColumn, GMatrix *pSource, size_t nSourceStartColumn, size_t nColumnCount)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GClasses::GMatrix::copyColumns </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nDestStartColumn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_g_classes_1_1_g_matrix.html">GMatrix</a> *&#160;</td>
          <td class="paramname"><em>pSource</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nSourceStartColumn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nColumnCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copies the specified block of columns from pSource to this dataset. pSource must have the same number of rows as this dataset. </p>

</div>
</div>
<a class="anchor" id="ac3253fa91205ff8ea3d2434d6457cb79"></a><!-- doxytag: member="GClasses::GMatrix::copyRow" ref="ac3253fa91205ff8ea3d2434d6457cb79" args="(const double *pRow)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GClasses::GMatrix::copyRow </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>pRow</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds a copy of the row to the data set. </p>

</div>
</div>
<a class="anchor" id="a1a862a989426b7ca7c53e92645f04754"></a><!-- doxytag: member="GClasses::GMatrix::countPrincipalComponents" ref="a1a862a989426b7ca7c53e92645f04754" args="(double d, GRand *pRand)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t GClasses::GMatrix::countPrincipalComponents </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_g_classes_1_1_g_rand.html">GRand</a> *&#160;</td>
          <td class="paramname"><em>pRand</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes the minimum number of principal components necessary so that less than the specified portion of the deviation in the data is unaccounted for. (For example, if the data projected onto the first 3 principal components contains 90 percent of the deviation that the original data contains, then if you pass the value 0.1 to this method, it will return 3.) </p>

</div>
</div>
<a class="anchor" id="a628ed2a08f6e4007413a05e066ccbb27"></a><!-- doxytag: member="GClasses::GMatrix::countValue" ref="a628ed2a08f6e4007413a05e066ccbb27" args="(size_t attribute, double value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t GClasses::GMatrix::countValue </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>attribute</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the number of ocurrences of the specified value in the specified attribute. </p>

</div>
</div>
<a class="anchor" id="af4437c6da0d84bf9b2fc5085bbf41b85"></a><!-- doxytag: member="GClasses::GMatrix::covariance" ref="af4437c6da0d84bf9b2fc5085bbf41b85" args="(size_t nAttr1, double dMean1, size_t nAttr2, double dMean2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double GClasses::GMatrix::covariance </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nAttr1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dMean1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nAttr2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dMean2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes the covariance between two attributes. </p>

</div>
</div>
<a class="anchor" id="a7c29bec3b0a3cff98b298455fff6158f"></a><!-- doxytag: member="GClasses::GMatrix::covarianceMatrix" ref="a7c29bec3b0a3cff98b298455fff6158f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_g_classes_1_1_g_matrix.html">GMatrix</a>* GClasses::GMatrix::covarianceMatrix </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes the covariance matrix of the data. </p>

</div>
</div>
<a class="anchor" id="a06b18fc37ac59c6d8589d81cb5659ea2"></a><!-- doxytag: member="GClasses::GMatrix::deleteColumn" ref="a06b18fc37ac59c6d8589d81cb5659ea2" args="(size_t index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GClasses::GMatrix::deleteColumn </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Deletes a column. </p>

</div>
</div>
<a class="anchor" id="a219ef0044b0bb06820e0cc386fd19cc2"></a><!-- doxytag: member="GClasses::GMatrix::deleteRow" ref="a219ef0044b0bb06820e0cc386fd19cc2" args="(size_t index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GClasses::GMatrix::deleteRow </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Swaps the specified row with the last row, and then deletes it. </p>

</div>
</div>
<a class="anchor" id="afb72c4f2c51f4ca1f5e702521e616f64"></a><!-- doxytag: member="GClasses::GMatrix::deleteRowPreserveOrder" ref="afb72c4f2c51f4ca1f5e702521e616f64" args="(size_t index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GClasses::GMatrix::deleteRowPreserveOrder </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Deletes the specified row and shifts everything after it up one slot. </p>

</div>
</div>
<a class="anchor" id="ac5a93dfebe585d6777779f20308c68b1"></a><!-- doxytag: member="GClasses::GMatrix::determinant" ref="ac5a93dfebe585d6777779f20308c68b1" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double GClasses::GMatrix::determinant </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes the determinant of this matrix. </p>

</div>
</div>
<a class="anchor" id="a6362aa03508616ca4dcd66c64b61016a"></a><!-- doxytag: member="GClasses::GMatrix::determinantHelper" ref="a6362aa03508616ca4dcd66c64b61016a" args="(size_t nEndRow, size_t *pColumnList)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double GClasses::GMatrix::determinantHelper </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nEndRow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>pColumnList</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a1aac64bb9693435a7392186d9df41dd1"></a><!-- doxytag: member="GClasses::GMatrix::dihedralCorrelation" ref="a1aac64bb9693435a7392186d9df41dd1" args="(GMatrix *pThat, GRand *pRand)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double GClasses::GMatrix::dihedralCorrelation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_g_classes_1_1_g_matrix.html">GMatrix</a> *&#160;</td>
          <td class="paramname"><em>pThat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_g_classes_1_1_g_rand.html">GRand</a> *&#160;</td>
          <td class="paramname"><em>pRand</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes the cosine of the dihedral angle between this subspace and pThat subspace. </p>

</div>
</div>
<a class="anchor" id="add3e27857ad14b2701a45a5b981f8918"></a><!-- doxytag: member="GClasses::GMatrix::doesHaveAnyMissingValues" ref="add3e27857ad14b2701a45a5b981f8918" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool GClasses::GMatrix::doesHaveAnyMissingValues </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns true iff this matrix is missing any values. </p>

</div>
</div>
<a class="anchor" id="aca9c8c46425382c90437dd8c05286755"></a><!-- doxytag: member="GClasses::GMatrix::eigenValue" ref="aca9c8c46425382c90437dd8c05286755" args="(const double *pMean, const double *pEigenVector, size_t dims, GRand *pRand)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double GClasses::GMatrix::eigenValue </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>pMean</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>pEigenVector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_g_classes_1_1_g_rand.html">GRand</a> *&#160;</td>
          <td class="paramname"><em>pRand</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>After you compute the principal component, you can call this to obtain the eigenvalue that corresponds to that principal component vector (eigenvector). </p>

</div>
</div>
<a class="anchor" id="a60808f8423858403d3d32a6909586836"></a><!-- doxytag: member="GClasses::GMatrix::eigenValue" ref="a60808f8423858403d3d32a6909586836" args="(const double *pEigenVector)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double GClasses::GMatrix::eigenValue </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>pEigenVector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes the eigenvalue that corresponds to the specified eigenvector of this matrix. </p>

</div>
</div>
<a class="anchor" id="acf6d992960f0a96a1e0e099bb6e483ae"></a><!-- doxytag: member="GClasses::GMatrix::eigenVector" ref="acf6d992960f0a96a1e0e099bb6e483ae" args="(double eigenvalue, double *pOutVector)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GClasses::GMatrix::eigenVector </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>eigenvalue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>pOutVector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes the eigenvector that corresponds to the specified eigenvalue of this matrix. Note that this method trashes this matrix, so make a copy first if you care. </p>

</div>
</div>
<a class="anchor" id="a63be21347369430296300f8b32e01363"></a><!-- doxytag: member="GClasses::GMatrix::eigs" ref="a63be21347369430296300f8b32e01363" args="(size_t nCount, double *pEigenVals, GRand *pRand, bool mostSignificant)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_g_classes_1_1_g_matrix.html">GMatrix</a>* GClasses::GMatrix::eigs </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>pEigenVals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_g_classes_1_1_g_rand.html">GRand</a> *&#160;</td>
          <td class="paramname"><em>pRand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>mostSignificant</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes nCount eigenvectors and the corresponding eigenvalues using the power method. (This method is only accurate if a small number of eigenvalues/vectors are needed.) If mostSignificant is true, the largest eigenvalues are found. If mostSignificant is false, the smallest eigenvalues are found. </p>

</div>
</div>
<a class="anchor" id="abbc2296291825bb6dd8a641e098deee5"></a><!-- doxytag: member="GClasses::GMatrix::ensureDataHasNoMissingNominals" ref="abbc2296291825bb6dd8a641e098deee5" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GClasses::GMatrix::ensureDataHasNoMissingNominals </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Throws an exception if this data contains any missing values in a nominal attribute. </p>

</div>
</div>
<a class="anchor" id="a78c7d1f46af67b0a4e68de461a047fe4"></a><!-- doxytag: member="GClasses::GMatrix::ensureDataHasNoMissingReals" ref="a78c7d1f46af67b0a4e68de461a047fe4" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GClasses::GMatrix::ensureDataHasNoMissingReals </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Throws an exception if this data contains any missing values in a continuous attribute. </p>

</div>
</div>
<a class="anchor" id="a43ac1654ca284f73db7a49ce4abc7bb8"></a><!-- doxytag: member="GClasses::GMatrix::entropy" ref="a43ac1654ca284f73db7a49ce4abc7bb8" args="(size_t nColumn)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double GClasses::GMatrix::entropy </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nColumn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Measures the entropy of the specified attribute. </p>

</div>
</div>
<a class="anchor" id="acbf13e5159e9c537b55b52992ac5d690"></a><!-- doxytag: member="GClasses::GMatrix::fixNans" ref="acbf13e5159e9c537b55b52992ac5d690" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GClasses::GMatrix::fixNans </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Replaces any occurrences of NAN in the matrix with the corresponding values from an identity matrix. </p>

</div>
</div>
<a class="anchor" id="af3c0eb63b018c99353bfa8a571025149"></a><!-- doxytag: member="GClasses::GMatrix::flush" ref="af3c0eb63b018c99353bfa8a571025149" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GClasses::GMatrix::flush </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Deletes all the data. </p>

</div>
</div>
<a class="anchor" id="ab8d323a4b4e09a7556a504cc89f0004e"></a><!-- doxytag: member="GClasses::GMatrix::fromVector" ref="ab8d323a4b4e09a7556a504cc89f0004e" args="(const double *pVector, size_t nRows)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GClasses::GMatrix::fromVector </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>pVector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nRows</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copies the data from pVector over this dataset. nRows specifies the number of rows of data in pVector. </p>

</div>
</div>
<a class="anchor" id="a12ecf5d914ffd54f0dad712a24836fcf"></a><!-- doxytag: member="GClasses::GMatrix::gaussianElimination" ref="a12ecf5d914ffd54f0dad712a24836fcf" args="(double *pVector)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool GClasses::GMatrix::gaussianElimination </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>pVector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes y in the equation M*y=x (or y=M^(-1)x), where M is this dataset, which must be a square matrix, and x is pVector as passed in, and y is pVector after the call. If there are multiple solutions, it finds the one for which all the variables in the null-space have a value of 1. If there are no solutions, it returns false. Note that this method trashes this dataset (so make a copy first if you care). </p>

</div>
</div>
<a class="anchor" id="a49934d4ebef97e061d370f3cc990ec1f"></a><!-- doxytag: member="GClasses::GMatrix::heap" ref="a49934d4ebef97e061d370f3cc990ec1f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_g_classes_1_1_g_heap.html">GHeap</a>* GClasses::GMatrix::heap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the heap used to allocate rows for this dataset. </p>

</div>
</div>
<a class="anchor" id="ab79aec20a82e9589f070485b8a5d5169"></a><!-- doxytag: member="GClasses::GMatrix::inPlaceSquareTranspose" ref="ab79aec20a82e9589f070485b8a5d5169" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GClasses::GMatrix::inPlaceSquareTranspose </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a1b82122448449e486aff4464087d77f5"></a><!-- doxytag: member="GClasses::GMatrix::isAttrHomogenous" ref="a1b82122448449e486aff4464087d77f5" args="(size_t col)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool GClasses::GMatrix::isAttrHomogenous </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>col</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns true iff the specified attribute contains homogenous values. (Unknowns are counted as homogenous with anything) </p>

</div>
</div>
<a class="anchor" id="a99ea54efe0219078e1c000c2a354b61c"></a><!-- doxytag: member="GClasses::GMatrix::isHomogenous" ref="a99ea54efe0219078e1c000c2a354b61c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool GClasses::GMatrix::isHomogenous </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns true iff each of the last labelDims columns in the data are homogenous. </p>

</div>
</div>
<a class="anchor" id="a910f021497c3beb4db7bbb351bb67ced"></a><!-- doxytag: member="GClasses::GMatrix::kabsch" ref="a910f021497c3beb4db7bbb351bb67ced" args="(GMatrix *pA, GMatrix *pB)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_g_classes_1_1_g_matrix.html">GMatrix</a>* GClasses::GMatrix::kabsch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_g_classes_1_1_g_matrix.html">GMatrix</a> *&#160;</td>
          <td class="paramname"><em>pA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_g_classes_1_1_g_matrix.html">GMatrix</a> *&#160;</td>
          <td class="paramname"><em>pB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This computes K=kabsch(A,B), such that K is an n-by-n matrix, where n is pA-&gt;<a class="el" href="class_g_classes_1_1_g_matrix.html#af6396fe43ffaddb8de01acb294261040" title="Returns the number of columns in the dataset.">cols()</a>. K is the optimal orthonormal rotation matrix to align A and B, such that A(K^T) minimizes sum-squared error with B, and BK minimizes sum-squared error with A. (This rotates around the origin, so typically you will want to subtract the centroid from both pA and pB before calling this.) </p>

</div>
</div>
<a class="anchor" id="a4db136daf8ab068bdacaa7691cea583f"></a><!-- doxytag: member="GClasses::GMatrix::leastCorrelatedVector" ref="a4db136daf8ab068bdacaa7691cea583f" args="(double *pOut, GMatrix *pThat, GRand *pRand)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool GClasses::GMatrix::leastCorrelatedVector </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>pOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_g_classes_1_1_g_matrix.html">GMatrix</a> *&#160;</td>
          <td class="paramname"><em>pThat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_g_classes_1_1_g_rand.html">GRand</a> *&#160;</td>
          <td class="paramname"><em>pRand</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes the vector in this subspace that has the greatest distance from its projection into pThat subspace. Returns true if the results are computed. Returns false if the subspaces are so nearly parallel that pOut cannot be computed with accuracy. </p>

</div>
</div>
<a class="anchor" id="a01975a05529c9bab6e6863f1afc96aa7"></a><!-- doxytag: member="GClasses::GMatrix::linearCorrelationCoefficient" ref="a01975a05529c9bab6e6863f1afc96aa7" args="(size_t attr1, double attr1Origin, size_t attr2, double attr2Origin)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double GClasses::GMatrix::linearCorrelationCoefficient </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>attr1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>attr1Origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>attr2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>attr2Origin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes the linear coefficient between the two specified attributes. Usually you will want to pass the mean values for attr1Origin and attr2Origin. </p>

</div>
</div>
<a class="anchor" id="ac22c1d25682bef2d6f07453c21211a44"></a><!-- doxytag: member="GClasses::GMatrix::loadArff" ref="ac22c1d25682bef2d6f07453c21211a44" args="(const char *szFilename)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_g_classes_1_1_g_matrix.html">GMatrix</a>* GClasses::GMatrix::loadArff </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>szFilename</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Loads an ARFF file and returns the data. This will throw an exception if there's an error. </p>

</div>
</div>
<a class="anchor" id="a346b8aef6930fdf3243d5bd720291ce4"></a><!-- doxytag: member="GClasses::GMatrix::loadCsv" ref="a346b8aef6930fdf3243d5bd720291ce4" args="(const char *szFilename, char separator, bool columnNamesInFirstRow, bool tolerant)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_g_classes_1_1_g_matrix.html">GMatrix</a>* GClasses::GMatrix::loadCsv </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>szFilename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>separator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>columnNamesInFirstRow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>tolerant</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Loads a file in CSV format. </p>

</div>
</div>
<a class="anchor" id="a7a7aeb47cb054242d3af098e494a0965"></a><!-- doxytag: member="GClasses::GMatrix::LUDecomposition" ref="a7a7aeb47cb054242d3af098e494a0965" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GClasses::GMatrix::LUDecomposition </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Performs an in-place LU-decomposition, such that the lower triangle of this matrix (including the diagonal) specifies L, and the uppoer triangle of this matrix (not including the diagonal) specifies U, and all values of U along the diagonal are ones. (The upper triangle of L and the lower triangle of U are all zeros.) </p>

</div>
</div>
<a class="anchor" id="ade147cd214e8b3e251fad0bdab8c2982"></a><!-- doxytag: member="GClasses::GMatrix::makeIdentity" ref="ade147cd214e8b3e251fad0bdab8c2982" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GClasses::GMatrix::makeIdentity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets this dataset to an identity matrix. (It doesn't change the number of columns or rows. It just stomps over existing values.) </p>

</div>
</div>
<a class="anchor" id="ac0e058b693f83e1329ecd1ad0daa15b3"></a><!-- doxytag: member="GClasses::GMatrix::mean" ref="ac0e058b693f83e1329ecd1ad0daa15b3" args="(size_t nAttribute)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double GClasses::GMatrix::mean </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nAttribute</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes the arithmetic mean of the values in the specified column. </p>

</div>
</div>
<a class="anchor" id="a958c591bdbd5f1d567ed59b85b65e09e"></a><!-- doxytag: member="GClasses::GMatrix::measureInfo" ref="a958c591bdbd5f1d567ed59b85b65e09e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double GClasses::GMatrix::measureInfo </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes the sum entropy of the data (or the sum variance for continuous attributes) </p>

</div>
</div>
<a class="anchor" id="afb3ab2e6345a62d29f8c504d907f0517"></a><!-- doxytag: member="GClasses::GMatrix::median" ref="afb3ab2e6345a62d29f8c504d907f0517" args="(size_t nAttribute)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double GClasses::GMatrix::median </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nAttribute</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes the median of the values in the specified column. </p>

</div>
</div>
<a class="anchor" id="ab164825999b41aa808a371093031cdfb"></a><!-- doxytag: member="GClasses::GMatrix::mergeHoriz" ref="ab164825999b41aa808a371093031cdfb" args="(GMatrix *pSetA, GMatrix *pSetB)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_g_classes_1_1_g_matrix.html">GMatrix</a>* GClasses::GMatrix::mergeHoriz </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_g_classes_1_1_g_matrix.html">GMatrix</a> *&#160;</td>
          <td class="paramname"><em>pSetA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_g_classes_1_1_g_matrix.html">GMatrix</a> *&#160;</td>
          <td class="paramname"><em>pSetB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Merges two datasets side-by-side. The resulting dataset will contain the attributes of both datasets. Both pSetA and pSetB (and the resulting dataset) must have the same number of rows. </p>

</div>
</div>
<a class="anchor" id="a6e616ccd27cf69ee02cc82a6698d1c57"></a><!-- doxytag: member="GClasses::GMatrix::mergeVert" ref="a6e616ccd27cf69ee02cc82a6698d1c57" args="(GMatrix *pData)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GClasses::GMatrix::mergeVert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_g_classes_1_1_g_matrix.html">GMatrix</a> *&#160;</td>
          <td class="paramname"><em>pData</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Steals all the rows from pData and adds them to this set. (You still have to delete pData.) Both datasets must have the same number of columns. </p>

</div>
</div>
<a class="anchor" id="a67e544c95ffd01e308736f789f8c2010"></a><!-- doxytag: member="GClasses::GMatrix::minAndRange" ref="a67e544c95ffd01e308736f789f8c2010" args="(size_t nAttribute, double *pMin, double *pRange)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GClasses::GMatrix::minAndRange </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nAttribute</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>pMin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>pRange</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Finds the min and the range of the values of the specified attribute. </p>

</div>
</div>
<a class="anchor" id="a4f253d5e2e7eef785a9087bc262f0285"></a><!-- doxytag: member="GClasses::GMatrix::minAndRangeUnbiased" ref="a4f253d5e2e7eef785a9087bc262f0285" args="(size_t nAttribute, double *pMin, double *pRange)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GClasses::GMatrix::minAndRangeUnbiased </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nAttribute</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>pMin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>pRange</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Estimates the actual min and range based on a random sample. </p>

</div>
</div>
<a class="anchor" id="acac2ce92f893fee91980df02622688e6"></a><!-- doxytag: member="GClasses::GMatrix::mirrorTriangle" ref="acac2ce92f893fee91980df02622688e6" args="(bool upperToLower)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GClasses::GMatrix::mirrorTriangle </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>upperToLower</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>If upperToLower is true, copies the upper triangle of this matrix over the lower triangle If upperToLower is false, copies the lower triangle of this matrix over the upper triangle. </p>

</div>
</div>
<a class="anchor" id="a339e1a241c2055e49672eadc7237b8fe"></a><!-- doxytag: member="GClasses::GMatrix::multiply" ref="a339e1a241c2055e49672eadc7237b8fe" args="(const double *pVectorIn, double *pVectorOut, bool transpose=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GClasses::GMatrix::multiply </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>pVectorIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>pVectorOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>transpose</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Multiplies this matrix by the column vector pVectorIn to get pVectorOut. (If transpose is true, then it multiplies the transpose of this matrix by pVectorIn to get pVectorOut.) pVectorIn should have the same number of elements as columns (or rows if transpose is true) and pVectorOut should have the same number of elements as rows (or cols, if transpose is true.) Note that if transpose is true, it is the same as if pVectorIn is a row vector and you multiply it by this matrix to get pVectorOut. </p>

</div>
</div>
<a class="anchor" id="aa6e444b7360b8bdac125be34930940db"></a><!-- doxytag: member="GClasses::GMatrix::multiply" ref="aa6e444b7360b8bdac125be34930940db" args="(double scalar)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GClasses::GMatrix::multiply </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>scalar</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Multiplies every element in the dataset by scalar. Behavior is undefined for nominal columns. </p>

</div>
</div>
<a class="anchor" id="a02a31c4006a12091a327143960b080c4"></a><!-- doxytag: member="GClasses::GMatrix::multiply" ref="a02a31c4006a12091a327143960b080c4" args="(GMatrix &amp;a, GMatrix &amp;b, bool transposeA, bool transposeB)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_g_classes_1_1_g_matrix.html">GMatrix</a>* GClasses::GMatrix::multiply </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_g_classes_1_1_g_matrix.html">GMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_g_classes_1_1_g_matrix.html">GMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>transposeA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>transposeB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Matrix multiply. For convenience, you can also specify that neither, one, or both of the inputs are virtually transposed prior to the multiplication. (If you want the results to come out transposed, you can use the equality AB=((B^T)(A^T))^T to figure out how to specify the parameters.) </p>

</div>
</div>
<a class="anchor" id="aad46e9ec8b3e64d46140a79ddfcd3a18"></a><!-- doxytag: member="GClasses::GMatrix::newRow" ref="aad46e9ec8b3e64d46140a79ddfcd3a18" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double* GClasses::GMatrix::newRow </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds a new row to the dataset. (The values in the row are not initialized) </p>

</div>
</div>
<a class="anchor" id="ab95a2e5f6e0853c8100b723c0b04a0e7"></a><!-- doxytag: member="GClasses::GMatrix::newRows" ref="ab95a2e5f6e0853c8100b723c0b04a0e7" args="(size_t nRows)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GClasses::GMatrix::newRows </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nRows</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds "nRows" uninitialized rows to the data set. </p>

</div>
</div>
<a class="anchor" id="a40fb549127a96969e2f26301d52a68f3"></a><!-- doxytag: member="GClasses::GMatrix::normalize" ref="a40fb549127a96969e2f26301d52a68f3" args="(size_t nAttribute, double dInputMin, double dInputRange, double dOutputMin, double dOutputRange)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GClasses::GMatrix::normalize </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nAttribute</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dInputMin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dInputRange</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dOutputMin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dOutputRange</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Normalizes the specified attribute values. </p>

</div>
</div>
<a class="anchor" id="aec001a18e2e8bb14ee5c905e6ead1a34"></a><!-- doxytag: member="GClasses::GMatrix::normalize" ref="aec001a18e2e8bb14ee5c905e6ead1a34" args="(double dVal, double dInputMin, double dInputRange, double dOutputMin, double dOutputRange)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static double GClasses::GMatrix::normalize </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dVal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dInputMin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dInputRange</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dOutputMin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dOutputRange</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Normalize a value from the input min and range to the output min and range. </p>

</div>
</div>
<a class="anchor" id="a05b809e2e06b7933c26700fdf2f97d59"></a><!-- doxytag: member="GClasses::GMatrix::operator[]" ref="a05b809e2e06b7933c26700fdf2f97d59" args="(size_t index) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const double* GClasses::GMatrix::operator[] </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a const pointer to the specified row. </p>

</div>
</div>
<a class="anchor" id="aceead558e83c92a0b76fc57492e34b54"></a><!-- doxytag: member="GClasses::GMatrix::operator[]" ref="aceead558e83c92a0b76fc57492e34b54" args="(size_t index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double* GClasses::GMatrix::operator[] </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a pointer to the specified row. </p>

</div>
</div>
<a class="anchor" id="a2c0be33814a7c836cc6fca764526b5a7"></a><!-- doxytag: member="GClasses::GMatrix::pairedTTest" ref="a2c0be33814a7c836cc6fca764526b5a7" args="(size_t *pOutV, double *pOutT, size_t attr1, size_t attr2, bool normalize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GClasses::GMatrix::pairedTTest </td>
          <td>(</td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>pOutV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>pOutT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>attr1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>attr2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>normalize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Performs a paired T-Test with data from the two specified attributes. pOutV will hold the degrees of freedom. pOutT will hold the T-value. You can use <a class="el" href="class_g_classes_1_1_g_math.html#aec60dab8f29c6062fe2965481fa3b681" title="Computes the p-value from the degrees of freedom, and the t-value obtained from a T-test...">GMath::tTestAlphaValue</a> to convert these to a P-value. </p>

</div>
</div>
<a class="anchor" id="ab48e68f88ce77a26913a630e0a7f0ced"></a><!-- doxytag: member="GClasses::GMatrix::parseArff" ref="ab48e68f88ce77a26913a630e0a7f0ced" args="(const char *szFile, size_t nLen)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_g_classes_1_1_g_matrix.html">GMatrix</a>* GClasses::GMatrix::parseArff </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>szFile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nLen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Parses an ARFF file and returns the data. This will throw an exception if there's an error. </p>

</div>
</div>
<a class="anchor" id="a08432364a17fcd1842b27d803427f789"></a><!-- doxytag: member="GClasses::GMatrix::parseCsv" ref="a08432364a17fcd1842b27d803427f789" args="(const char *pFile, size_t len, char separator, bool columnNamesInFirstRow, bool tolerant=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_g_classes_1_1_g_matrix.html">GMatrix</a>* GClasses::GMatrix::parseCsv </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pFile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>separator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>columnNamesInFirstRow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>tolerant</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Imports data from a text file. Determines the meta-data automatically. Note: This method does not support Mac line-endings. You should first replace all '' with '<br/>
' if your data comes from a Mac. As a special case, if separator is '\0', then it assumes data elements are separated by any number of whitespace characters, that element values themselves contain no whitespace, and that there are no missing elements. (This is the case when you save a Matlab matrix to an ascii file.) </p>

</div>
</div>
<a class="anchor" id="a44abadfdc20007095a5cc79955af5291"></a><!-- doxytag: member="GClasses::GMatrix::principalComponent" ref="a44abadfdc20007095a5cc79955af5291" args="(double *pOutVector, size_t dims, const double *pMean, GRand *pRand)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GClasses::GMatrix::principalComponent </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>pOutVector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>pMean</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_g_classes_1_1_g_rand.html">GRand</a> *&#160;</td>
          <td class="paramname"><em>pRand</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This is an efficient algorithm for iteratively computing the principal component vector (the eigenvector of the covariance matrix) of the data. See "EM Algorithms for PCA and SPCA" by Sam Roweis, 1998 NIPS. nIterations should be a small constant. 20 seems work well for most applications. (To compute the next principal component, call RemoveComponent, then call this again.) </p>

</div>
</div>
<a class="anchor" id="a997fc57c3d38c6de44b04a5e47e8f7fb"></a><!-- doxytag: member="GClasses::GMatrix::principalComponentAboutOrigin" ref="a997fc57c3d38c6de44b04a5e47e8f7fb" args="(double *pOutVector, size_t dims, GRand *pRand)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GClasses::GMatrix::principalComponentAboutOrigin </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>pOutVector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_g_classes_1_1_g_rand.html">GRand</a> *&#160;</td>
          <td class="paramname"><em>pRand</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes the first principal component assuming the mean is already subtracted out of the data. </p>

</div>
</div>
<a class="anchor" id="ace8040345a7602b694277b0496be53c5"></a><!-- doxytag: member="GClasses::GMatrix::principalComponentIgnoreUnknowns" ref="ace8040345a7602b694277b0496be53c5" args="(double *pOutVector, size_t dims, const double *pMean, GRand *pRand)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GClasses::GMatrix::principalComponentIgnoreUnknowns </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>pOutVector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>pMean</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_g_classes_1_1_g_rand.html">GRand</a> *&#160;</td>
          <td class="paramname"><em>pRand</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes principal components, while ignoring missing values. </p>

</div>
</div>
<a class="anchor" id="a84540a96fb0f06f985a4cd1fbda1bac4"></a><!-- doxytag: member="GClasses::GMatrix::print" ref="a84540a96fb0f06f985a4cd1fbda1bac4" args="(std::ostream &amp;stream)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GClasses::GMatrix::print </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>stream</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Prints the data to the specified stream. </p>

</div>
</div>
<a class="anchor" id="ab3c00937aa1e8bbd1f162a4ef50cacf2"></a><!-- doxytag: member="GClasses::GMatrix::project" ref="ab3c00937aa1e8bbd1f162a4ef50cacf2" args="(double *pDest, const double *pPoint)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GClasses::GMatrix::project </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>pDest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>pPoint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Projects pPoint onto this hyperplane (where each row defines one of the orthonormal basis vectors of this hyperplane) This computes (A^T)Ap, where A is this matrix, and p is pPoint. </p>

</div>
</div>
<a class="anchor" id="a6761dcc3e46e9bfc18e1a2efa8378971"></a><!-- doxytag: member="GClasses::GMatrix::project" ref="a6761dcc3e46e9bfc18e1a2efa8378971" args="(double *pDest, const double *pPoint, const double *pOrigin)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GClasses::GMatrix::project </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>pDest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>pPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>pOrigin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Projects pPoint onto this hyperplane (where each row defines one of the orthonormal basis vectors of this hyperplane) </p>

</div>
</div>
<a class="anchor" id="a473577be149730954c63176a5b6573ea"></a><!-- doxytag: member="GClasses::GMatrix::pseudoInverse" ref="a473577be149730954c63176a5b6573ea" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_g_classes_1_1_g_matrix.html">GMatrix</a>* GClasses::GMatrix::pseudoInverse </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes the Moore-Penrose pseudoinverse of this matrix (using the SVD method). You are responsible to delete the matrix this returns. </p>

</div>
</div>
<a class="anchor" id="a77eaf97d52e453b1b40147bfedc85aa9"></a><!-- doxytag: member="GClasses::GMatrix::relation" ref="a77eaf97d52e453b1b40147bfedc85aa9" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_g_classes_1_1smart__ptr.html">sp_relation</a>&amp; GClasses::GMatrix::relation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a relation object, which holds meta-data about the attributes (columns) </p>

</div>
</div>
<a class="anchor" id="a300e36efd9c810d05eadfef2312bcfcf"></a><!-- doxytag: member="GClasses::GMatrix::releaseAllRows" ref="a300e36efd9c810d05eadfef2312bcfcf" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GClasses::GMatrix::releaseAllRows </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Abandons (leaks) all the rows of data. </p>

</div>
</div>
<a class="anchor" id="a52d75c3f13f55c7dc618f671839eecf5"></a><!-- doxytag: member="GClasses::GMatrix::releaseRow" ref="a52d75c3f13f55c7dc618f671839eecf5" args="(size_t index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double* GClasses::GMatrix::releaseRow </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Swaps the specified row with the last row, and then releases it from the dataset. If this dataset does not have its own heap, then you must delete the row this returns. </p>

</div>
</div>
<a class="anchor" id="a8fc61deb6c65bd43d33f1da0a616d7d9"></a><!-- doxytag: member="GClasses::GMatrix::releaseRowPreserveOrder" ref="a8fc61deb6c65bd43d33f1da0a616d7d9" args="(size_t index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double* GClasses::GMatrix::releaseRowPreserveOrder </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Releases the specified row from the dataset and shifts everything after it up one slot. If this dataset does not have its own heap, then you must delete the row this returns. </p>

</div>
</div>
<a class="anchor" id="aae7407dddee6588049520326919e41bd"></a><!-- doxytag: member="GClasses::GMatrix::removeComponent" ref="aae7407dddee6588049520326919e41bd" args="(const double *pMean, const double *pComponent, size_t dims)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GClasses::GMatrix::removeComponent </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>pMean</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>pComponent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Removes the component specified by pComponent from the data. (pComponent should already be normalized.) This might be useful, for example, to remove the first principal component from the data so you can then proceed to compute the second principal component, and so forth. </p>

</div>
</div>
<a class="anchor" id="a8a0c880d06946cf322891bf9eb1644c8"></a><!-- doxytag: member="GClasses::GMatrix::removeComponentAboutOrigin" ref="a8a0c880d06946cf322891bf9eb1644c8" args="(const double *pComponent, size_t dims)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GClasses::GMatrix::removeComponentAboutOrigin </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>pComponent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Removes the specified component assuming the mean is zero. </p>

</div>
</div>
<a class="anchor" id="a12066bcfb23c258cc88224079706bf32"></a><!-- doxytag: member="GClasses::GMatrix::replaceMissingValuesRandomly" ref="a12066bcfb23c258cc88224079706bf32" args="(size_t nAttr, GRand *pRand)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GClasses::GMatrix::replaceMissingValuesRandomly </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nAttr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_g_classes_1_1_g_rand.html">GRand</a> *&#160;</td>
          <td class="paramname"><em>pRand</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Replaces all missing values by copying a randomly selected non-missing value in the same attribute. </p>

</div>
</div>
<a class="anchor" id="a16abfe7b0f07819772e397dd526015a7"></a><!-- doxytag: member="GClasses::GMatrix::replaceMissingValuesWithBaseline" ref="a16abfe7b0f07819772e397dd526015a7" args="(size_t nAttr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GClasses::GMatrix::replaceMissingValuesWithBaseline </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nAttr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>If the specified attribute is continuous, replaces all missing values in that attribute with the mean. If the specified attribute is nominal, replaces all missing values in that attribute with the most common value. </p>

</div>
</div>
<a class="anchor" id="a8288f6e519b774e96feddb0445414c78"></a><!-- doxytag: member="GClasses::GMatrix::reserve" ref="a8288f6e519b774e96feddb0445414c78" args="(size_t n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GClasses::GMatrix::reserve </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocates space for the specified number of patters (to avoid superfluous resizing) </p>

</div>
</div>
<a class="anchor" id="a33a18f9bc5b1a0f72143c4dc3707a81a"></a><!-- doxytag: member="GClasses::GMatrix::reverseRows" ref="a33a18f9bc5b1a0f72143c4dc3707a81a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GClasses::GMatrix::reverseRows </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reverses the row order. </p>

</div>
</div>
<a class="anchor" id="a87bbe8281adb693abcd92c7dd67e5bf2"></a><!-- doxytag: member="GClasses::GMatrix::row" ref="a87bbe8281adb693abcd92c7dd67e5bf2" args="(size_t index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double* GClasses::GMatrix::row </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a pointer to the specified row. </p>

</div>
</div>
<a class="anchor" id="a81c1652544f45d4f7254e9671b84c956"></a><!-- doxytag: member="GClasses::GMatrix::row" ref="a81c1652544f45d4f7254e9671b84c956" args="(size_t index) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const double* GClasses::GMatrix::row </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a const pointer to the specified row. </p>

</div>
</div>
<a class="anchor" id="a9448d98edf2a217d369ed10033c4eae2"></a><!-- doxytag: member="GClasses::GMatrix::rows" ref="a9448d98edf2a217d369ed10033c4eae2" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t GClasses::GMatrix::rows </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the number of rows in the dataset. </p>

</div>
</div>
<a class="anchor" id="afe61ef0b4468bd437273fbf31099c761"></a><!-- doxytag: member="GClasses::GMatrix::saveArff" ref="afe61ef0b4468bd437273fbf31099c761" args="(const char *szFilename)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GClasses::GMatrix::saveArff </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>szFilename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Saves the dataset to a file in ARFF format. </p>

</div>
</div>
<a class="anchor" id="a90747ea872073c76fb9d8629f8c60845"></a><!-- doxytag: member="GClasses::GMatrix::serialize" ref="a90747ea872073c76fb9d8629f8c60845" args="(GDom *pDoc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_g_classes_1_1_g_dom_node.html">GDomNode</a>* GClasses::GMatrix::serialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_g_classes_1_1_g_dom.html">GDom</a> *&#160;</td>
          <td class="paramname"><em>pDoc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Marshalls this object to a DOM, which may be saved to a variety of serial formats. </p>

</div>
</div>
<a class="anchor" id="a277ad3066b9118d8db3f0c6c0e8c5dd3"></a><!-- doxytag: member="GClasses::GMatrix::setAll" ref="a277ad3066b9118d8db3f0c6c0e8c5dd3" args="(double val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GClasses::GMatrix::setAll </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets all elements in this dataset to the specified value. </p>

</div>
</div>
<a class="anchor" id="ae4e9dd0f7ee61a5205ae34424449eb73"></a><!-- doxytag: member="GClasses::GMatrix::setCol" ref="ae4e9dd0f7ee61a5205ae34424449eb73" args="(size_t index, const double *pVector)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GClasses::GMatrix::setCol </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>pVector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copies pVector over the specified column. </p>

</div>
</div>
<a class="anchor" id="afd58df6b9655a073686e8d6218258d88"></a><!-- doxytag: member="GClasses::GMatrix::setRelation" ref="afd58df6b9655a073686e8d6218258d88" args="(sp_relation &amp;pRelation)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GClasses::GMatrix::setRelation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_g_classes_1_1smart__ptr.html">sp_relation</a> &amp;&#160;</td>
          <td class="paramname"><em>pRelation</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the relation for this dataset. </p>

</div>
</div>
<a class="anchor" id="a344b876d45a4cc4e8ecc8af82d06454d"></a><!-- doxytag: member="GClasses::GMatrix::shuffle" ref="a344b876d45a4cc4e8ecc8af82d06454d" args="(GRand &amp;rand, GMatrix *pExtension=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GClasses::GMatrix::shuffle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_g_classes_1_1_g_rand.html">GRand</a> &amp;&#160;</td>
          <td class="paramname"><em>rand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_g_classes_1_1_g_matrix.html">GMatrix</a> *&#160;</td>
          <td class="paramname"><em>pExtension</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Randomizes the order of the rows. If pExtension is non-NULL, then it will also be shuffled such that corresponding rows are preserved. </p>

</div>
</div>
<a class="anchor" id="adc01b3c5afc537ff34044725660b57b3"></a><!-- doxytag: member="GClasses::GMatrix::shuffle2" ref="adc01b3c5afc537ff34044725660b57b3" args="(GRand &amp;rand, GMatrix &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GClasses::GMatrix::shuffle2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_g_classes_1_1_g_rand.html">GRand</a> &amp;&#160;</td>
          <td class="paramname"><em>rand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_g_classes_1_1_g_matrix.html">GMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Shuffles the order of the rows. Also shuffles the rows in "other" in the same way, such that corresponding rows are preserved. </p>

</div>
</div>
<a class="anchor" id="ab35ea0670e830ee273de92be6848b7f0"></a><!-- doxytag: member="GClasses::GMatrix::shuffleLikeCards" ref="ab35ea0670e830ee273de92be6848b7f0" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GClasses::GMatrix::shuffleLikeCards </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This is an inferior way to shuffle the data. </p>

</div>
</div>
<a class="anchor" id="ae6fe4e212ae91d86fb3ccd6a2a343507"></a><!-- doxytag: member="GClasses::GMatrix::singularValueDecomposition" ref="ae6fe4e212ae91d86fb3ccd6a2a343507" args="(GMatrix **ppU, double **ppDiag, GMatrix **ppV, bool throwIfNoConverge=false, size_t maxIters=80)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GClasses::GMatrix::singularValueDecomposition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_g_classes_1_1_g_matrix.html">GMatrix</a> **&#160;</td>
          <td class="paramname"><em>ppU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double **&#160;</td>
          <td class="paramname"><em>ppDiag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_g_classes_1_1_g_matrix.html">GMatrix</a> **&#160;</td>
          <td class="paramname"><em>ppV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>throwIfNoConverge</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxIters</em> = <code>80</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Performs SVD on A, where A is this m-by-n matrix. *ppU will be set to an m-by-m matrix where the columns are the eigenvectors of A(A^T). *ppDiag will be set to an array of n doubles holding the square roots of the corresponding eigenvalues. *ppV will be set to an n-by-n matrix where the rows are the eigenvectors of (A^T)A. You are responsible to delete(*ppU), delete(*ppV), and delete[] *ppDiag. </p>

</div>
</div>
<a class="anchor" id="afcabc1b1143efd60e3080a6065fe09b8"></a><!-- doxytag: member="GClasses::GMatrix::singularValueDecompositionHelper" ref="afcabc1b1143efd60e3080a6065fe09b8" args="(GMatrix **ppU, double **ppDiag, GMatrix **ppV, bool throwIfNoConverge, size_t maxIters)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GClasses::GMatrix::singularValueDecompositionHelper </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_g_classes_1_1_g_matrix.html">GMatrix</a> **&#160;</td>
          <td class="paramname"><em>ppU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double **&#160;</td>
          <td class="paramname"><em>ppDiag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_g_classes_1_1_g_matrix.html">GMatrix</a> **&#160;</td>
          <td class="paramname"><em>ppV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>throwIfNoConverge</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxIters</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ab6ec079268e779f326b3cf8004b693a6"></a><!-- doxytag: member="GClasses::GMatrix::sort" ref="ab6ec079268e779f326b3cf8004b693a6" args="(size_t nDimension)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GClasses::GMatrix::sort </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nDimension</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sorts the data from smallest to largest in the specified dimension. </p>

</div>
</div>
<a class="anchor" id="a4e100f07f11233bffdcd8453556e04cd"></a><!-- doxytag: member="GClasses::GMatrix::sort" ref="a4e100f07f11233bffdcd8453556e04cd" args="(CompareFunc &amp;pComparator)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CompareFunc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GClasses::GMatrix::sort </td>
          <td>(</td>
          <td class="paramtype">CompareFunc &amp;&#160;</td>
          <td class="paramname"><em>pComparator</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sorts rows according to the specified compare function. (Return true to indicate thate the first row comes before the second row.) </p>

</div>
</div>
<a class="anchor" id="a58f089b462c00382a88ff7c50da0a84b"></a><!-- doxytag: member="GClasses::GMatrix::sortPartial" ref="a58f089b462c00382a88ff7c50da0a84b" args="(size_t row, size_t col)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GClasses::GMatrix::sortPartial </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>col</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This partially sorts the specified column, such that the specified row will contain the same row as if it were fully sorted, and previous rows will contain a value &lt;= to it in that column, and later rows will contain a value &gt;= to it in that column. Unlike sort, which has O(m*log(m)) complexity, this method has O(m) complexity. This might be useful, for example, for efficiently finding the row with a median value in some attribute, or for separating data by a threshold in some value. </p>

</div>
</div>
<a class="anchor" id="a0f14efc735dab677949be5c7bcff5131"></a><!-- doxytag: member="GClasses::GMatrix::splitByNominalValue" ref="a0f14efc735dab677949be5c7bcff5131" args="(GMatrix *pSingleClass, size_t nAttr, int nValue, GMatrix *pExtensionA=NULL, GMatrix *pExtensionB=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GClasses::GMatrix::splitByNominalValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_g_classes_1_1_g_matrix.html">GMatrix</a> *&#160;</td>
          <td class="paramname"><em>pSingleClass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nAttr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_g_classes_1_1_g_matrix.html">GMatrix</a> *&#160;</td>
          <td class="paramname"><em>pExtensionA</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_g_classes_1_1_g_matrix.html">GMatrix</a> *&#160;</td>
          <td class="paramname"><em>pExtensionB</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Moves all rows with the specified value in the specified attribute into pSingleClass If pExtensionA is non-NULL, then it will also split pExtensionA such that corresponding rows are preserved. </p>

</div>
</div>
<a class="anchor" id="a5f1f02db566939d9ce1f64b3c12c1d63"></a><!-- doxytag: member="GClasses::GMatrix::splitByPivot" ref="a5f1f02db566939d9ce1f64b3c12c1d63" args="(GMatrix *pGreaterOrEqual, size_t nAttribute, double dPivot, GMatrix *pExtensionA=NULL, GMatrix *pExtensionB=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GClasses::GMatrix::splitByPivot </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_g_classes_1_1_g_matrix.html">GMatrix</a> *&#160;</td>
          <td class="paramname"><em>pGreaterOrEqual</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nAttribute</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dPivot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_g_classes_1_1_g_matrix.html">GMatrix</a> *&#160;</td>
          <td class="paramname"><em>pExtensionA</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_g_classes_1_1_g_matrix.html">GMatrix</a> *&#160;</td>
          <td class="paramname"><em>pExtensionB</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Splits this set of data into two sets. Values greater-than-or-equal-to dPivot stay in this data set. Values less than dPivot go into pLessThanPivot If pExtensionA is non-NULL, then it will also split pExtensionA such that corresponding rows are preserved. </p>

</div>
</div>
<a class="anchor" id="a7a6e0b3eb7ef23b102b7222918b2eb63"></a><!-- doxytag: member="GClasses::GMatrix::splitBySize" ref="a7a6e0b3eb7ef23b102b7222918b2eb63" args="(GMatrix *pOtherData, size_t nOtherRows)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GClasses::GMatrix::splitBySize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_g_classes_1_1_g_matrix.html">GMatrix</a> *&#160;</td>
          <td class="paramname"><em>pOtherData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nOtherRows</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Removes the last nOtherRows rows from this data set and puts them in pOtherData. </p>

</div>
</div>
<a class="anchor" id="a31e37f844df5bd88948d6816c9ae36a7"></a><!-- doxytag: member="GClasses::GMatrix::subtract" ref="a31e37f844df5bd88948d6816c9ae36a7" args="(GMatrix *pThat, bool transpose)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GClasses::GMatrix::subtract </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_g_classes_1_1_g_matrix.html">GMatrix</a> *&#160;</td>
          <td class="paramname"><em>pThat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>transpose</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Matrix subtract. Subtracts the values in pThat from this. (If transpose is true, subtracts the transpose of pThat from this.) Both datasets must have the same dimensions. Behavior is undefined for nominal columns. </p>

</div>
</div>
<a class="anchor" id="a29eb55ee2e82d0797e59c501cf4042dd"></a><!-- doxytag: member="GClasses::GMatrix::sumSquaredDifference" ref="a29eb55ee2e82d0797e59c501cf4042dd" args="(GMatrix &amp;that, bool transpose=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double GClasses::GMatrix::sumSquaredDifference </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_g_classes_1_1_g_matrix.html">GMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>that</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>transpose</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes the squared distance between this and that. (If transpose is true, computes the difference between this and the transpose of that.) </p>

</div>
</div>
<a class="anchor" id="a16754aef670fb4790971a51b5e698ab5"></a><!-- doxytag: member="GClasses::GMatrix::sumSquaredDiffWithIdentity" ref="a16754aef670fb4790971a51b5e698ab5" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double GClasses::GMatrix::sumSquaredDiffWithIdentity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the sum squared difference between this matrix and an identity matrix. </p>

</div>
</div>
<a class="anchor" id="aafd972d670f6bc8b7cbfb347db4b0223"></a><!-- doxytag: member="GClasses::GMatrix::sumSquaredDistance" ref="aafd972d670f6bc8b7cbfb347db4b0223" args="(const double *pPoint)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double GClasses::GMatrix::sumSquaredDistance </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>pPoint</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes the sum-squared distance between pPoint and all of the points in the dataset. (If pPoint is NULL, it computes the sum-squared distance with the origin.) (Note that this is equal to the sum of all the eigenvalues times the number of dimensions, so you can efficiently compute eigenvalues as the difference in sumSquaredDistance with the mean after removing the corresponding component, and then dividing by the number of dimensions. This is more efficient than calling eigenValue.) </p>

</div>
</div>
<a class="anchor" id="af4160fd7dd9ad1e34e86442229fc6e49"></a><!-- doxytag: member="GClasses::GMatrix::swapColumns" ref="af4160fd7dd9ad1e34e86442229fc6e49" args="(size_t nAttr1, size_t nAttr2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GClasses::GMatrix::swapColumns </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nAttr1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nAttr2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Swaps two columns. </p>

</div>
</div>
<a class="anchor" id="a20fe0b5aa7e6fe100f3594376a38aecf"></a><!-- doxytag: member="GClasses::GMatrix::swapRows" ref="a20fe0b5aa7e6fe100f3594376a38aecf" args="(size_t a, size_t b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GClasses::GMatrix::swapRows </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Swaps the two specified rows. </p>

</div>
</div>
<a class="anchor" id="afdb6652ac98c0349ad28b1de588a9406"></a><!-- doxytag: member="GClasses::GMatrix::takeRow" ref="afdb6652ac98c0349ad28b1de588a9406" args="(double *pRow)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GClasses::GMatrix::takeRow </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>pRow</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds an already-allocated row to this dataset. The row must be allocated in the same heap that this dataset uses. (There is no way for this method to verify that, so be careful.) </p>

</div>
</div>
<a class="anchor" id="a0d8cf6317b96b79e093e6a011391fca5"></a><!-- doxytag: member="GClasses::GMatrix::test" ref="a0d8cf6317b96b79e093e6a011391fca5" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void GClasses::GMatrix::test </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Performs unit tests for this class. Throws an exception if there is a failure. </p>

</div>
</div>
<a class="anchor" id="a4df04b0c88f77cd907c9c4d01107d988"></a><!-- doxytag: member="GClasses::GMatrix::toReducedRowEchelonForm" ref="a4df04b0c88f77cd907c9c4d01107d988" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t GClasses::GMatrix::toReducedRowEchelonForm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Converts the matrix to reduced row echelon form. </p>

</div>
</div>
<a class="anchor" id="a25025c28523e9165808ba8fb97894f1d"></a><!-- doxytag: member="GClasses::GMatrix::toVector" ref="a25025c28523e9165808ba8fb97894f1d" args="(double *pVector)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GClasses::GMatrix::toVector </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>pVector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copies all the data from this dataset into pVector. pVector must be big enough to hold <a class="el" href="class_g_classes_1_1_g_matrix.html#a9448d98edf2a217d369ed10033c4eae2" title="Returns the number of rows in the dataset.">rows()</a> x <a class="el" href="class_g_classes_1_1_g_matrix.html#af6396fe43ffaddb8de01acb294261040" title="Returns the number of columns in the dataset.">cols()</a> doubles. </p>

</div>
</div>
<a class="anchor" id="a337831ebe052692fa5bbc28cf06f405c"></a><!-- doxytag: member="GClasses::GMatrix::trace" ref="a337831ebe052692fa5bbc28cf06f405c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double GClasses::GMatrix::trace </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the sum of the diagonal elements. </p>

</div>
</div>
<a class="anchor" id="aac04deecc7a90e39046ed486d138f94d"></a><!-- doxytag: member="GClasses::GMatrix::transpose" ref="aac04deecc7a90e39046ed486d138f94d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_g_classes_1_1_g_matrix.html">GMatrix</a>* GClasses::GMatrix::transpose </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a dataset that is this dataset transposed. (All columns in the returned dataset will be continuous.) </p>

</div>
</div>
<a class="anchor" id="a8d2de6c2e0216b35405958e1d57777e9"></a><!-- doxytag: member="GClasses::GMatrix::variance" ref="a8d2de6c2e0216b35405958e1d57777e9" args="(size_t nAttr, double mean)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double GClasses::GMatrix::variance </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nAttr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>mean</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes the average variance of a single attribute. </p>

</div>
</div>
<a class="anchor" id="ade5979bfc6a8fc0a7eb3ea4a6b151443"></a><!-- doxytag: member="GClasses::GMatrix::weightedPrincipalComponent" ref="ade5979bfc6a8fc0a7eb3ea4a6b151443" args="(double *pOutVector, size_t dims, const double *pMean, const double *pWeights, GRand *pRand)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GClasses::GMatrix::weightedPrincipalComponent </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>pOutVector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>pMean</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>pWeights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_g_classes_1_1_g_rand.html">GRand</a> *&#160;</td>
          <td class="paramname"><em>pRand</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes the first principal component of the data with each row weighted according to the vector pWeights. (pWeights must have an element for each row.) </p>

</div>
</div>
<a class="anchor" id="abc4a3adbe1229365b22f578853832475"></a><!-- doxytag: member="GClasses::GMatrix::wilcoxonSignedRanksTest" ref="abc4a3adbe1229365b22f578853832475" args="(size_t attr1, size_t attr2, double tolerance, int *pNum, double *pWMinus, double *pWPlus)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GClasses::GMatrix::wilcoxonSignedRanksTest </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>attr1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>attr2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tolerance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>pWMinus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>pWPlus</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Performs the Wilcoxon signed ranks test from the two specified attributes. If two values are closer than tolerance, they are considered to be equal. </p>

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="ac2837eb4e0de70e6d5c8a0e2022d2fb9"></a><!-- doxytag: member="GClasses::GMatrix::m_pHeap" ref="ac2837eb4e0de70e6d5c8a0e2022d2fb9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_g_classes_1_1_g_heap.html">GHeap</a>* <a class="el" href="class_g_classes_1_1_g_matrix.html#ac2837eb4e0de70e6d5c8a0e2022d2fb9">GClasses::GMatrix::m_pHeap</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a3961e66a81e83e7b727d9e12f9396fd8"></a><!-- doxytag: member="GClasses::GMatrix::m_pRelation" ref="a3961e66a81e83e7b727d9e12f9396fd8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_g_classes_1_1smart__ptr.html">sp_relation</a> <a class="el" href="class_g_classes_1_1_g_matrix.html#a3961e66a81e83e7b727d9e12f9396fd8">GClasses::GMatrix::m_pRelation</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a966445d1d7e2c55f547641cf5233409d"></a><!-- doxytag: member="GClasses::GMatrix::m_rows" ref="a966445d1d7e2c55f547641cf5233409d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;double*&gt; <a class="el" href="class_g_classes_1_1_g_matrix.html#a966445d1d7e2c55f547641cf5233409d">GClasses::GMatrix::m_rows</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
</div>
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="namespace_g_classes.html">GClasses</a>      </li>
      <li class="navelem"><a class="el" href="class_g_classes_1_1_g_matrix.html">GMatrix</a>      </li>
      <li class="footer">Generated on Mon Dec 5 2011 14:19:02 for GClasses by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.3 </li>
    </ul>
  </div>

</body>
</html>
