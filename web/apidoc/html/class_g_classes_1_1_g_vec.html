<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>GClasses: GClasses::GVec Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript">
$(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.3 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">GClasses</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('class_g_classes_1_1_g_vec.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-static-methods">Static Public Member Functions</a>  </div>
  <div class="headertitle">
<h1>GClasses::GVec Class Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="GClasses::GVec" -->
<p>Contains some useful functions for operating on vectors.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;GVec.h&gt;</code></p>

<p><a href="class_g_classes_1_1_g_vec-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_vec.html#abc125909fcdf11788338ee7b32098e12">test</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs unit tests for this class. Throws an exception if there is a failure.  <a href="#abc125909fcdf11788338ee7b32098e12"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_vec.html#a2393f822ffca8066dc071650eb16d2b8">doesContainUnknowns</a> (const double *pVector, size_t nSize)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This returns true if the vector contains any unknown values. Most of the methods in this class will give bad results if a vector contains unknown values, but for efficiency reasons, they don't check. So it's your job to check your vectors first.  <a href="#a2393f822ffca8066dc071650eb16d2b8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_vec.html#afd693b7f1356ccdd5994e14a27166c6d">copy</a> (double *pDest, const double *pSource, size_t nDims)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This just wraps memcpy.  <a href="#afd693b7f1356ccdd5994e14a27166c6d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_vec.html#a999a0aec27be025bbdbdd2a84f41b679">dotProduct</a> (const double *pA, const double *pB, size_t nSize)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the dot product of two vectors. Results are undefined if pA or pB contain unknown values.  <a href="#a999a0aec27be025bbdbdd2a84f41b679"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_vec.html#a6aa718706f7dc9c7cef3d5662f780ef8">dotProduct</a> (const double *pOrigin, const double *pTarget, const double *pVector, size_t nSize)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the dot product of (pTarget - pOrigin) with pVector.  <a href="#a6aa718706f7dc9c7cef3d5662f780ef8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_vec.html#aa62bfcd53a73a1e0a0ffde5984f91a12">dotProduct</a> (const double *pOriginA, const double *pTargetA, const double *pOriginB, const double *pTargetB, size_t nSize)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the dot product of (pTargetA - pOriginA) with (pTargetB - pOriginB).  <a href="#aa62bfcd53a73a1e0a0ffde5984f91a12"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_vec.html#a03aeec0023dc0e0710be67b054fd3675">dotProductIgnoringUnknowns</a> (const double *pOrigin, const double *pTarget, const double *pVector, size_t nSize)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the dot product of (pTarget - pOrigin) with pVector. Unknown values in pTarget will simply be ignored. (pOrigin and pVector must not contain any unknown values.)  <a href="#a03aeec0023dc0e0710be67b054fd3675"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_vec.html#afa502d0561a5d93b7ba5d921807d1357">squaredMagnitude</a> (const double *pVector, size_t nSize)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the squared magnitude of the vector.  <a href="#afa502d0561a5d93b7ba5d921807d1357"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_vec.html#a6b055fab2831155f9525286c0e82172a">lNormMagnitude</a> (double norm, const double *pVector, size_t nSize)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the magnitude in L-Norm distance (norm=1 is manhattan distance, norm=2 is Euclidean distance, norm=infinity is Chebychev, etc.)  <a href="#a6b055fab2831155f9525286c0e82172a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_vec.html#aef089f6c7327a29177a6c95ba060d3ca">normalize</a> (double *pVector, size_t nSize)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalizes this vector to a magnitude of 1. Throws an exception if the magnitude is zero.  <a href="#aef089f6c7327a29177a6c95ba060d3ca"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_vec.html#abbcc093fa7864ffb6323aab65fa217bb">safeNormalize</a> (double *pVector, size_t nSize, <a class="el" href="class_g_classes_1_1_g_rand.html">GRand</a> *pRand)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalizes this vector to a magnitude of 1. If the magnitude is zero, it returns a random vector.  <a href="#abbcc093fa7864ffb6323aab65fa217bb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_vec.html#a0e168891d658169a8cf0c749ebb35599">sumToOne</a> (double *pVector, size_t size)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Scale the vector so that the elements sum to 1.  <a href="#a0e168891d658169a8cf0c749ebb35599"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_vec.html#af884553949a2e2620b6aebfa92c066be">lNormNormalize</a> (double norm, double *pVector, size_t nSize)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalizes with L-Norm distance (norm=1 is manhattan distance, norm=2 is Euclidean distance, norm=infinity is Chebychev, etc.)  <a href="#af884553949a2e2620b6aebfa92c066be"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_vec.html#a55fd884f8786c424e1fe7a38693d3f99">squaredDistance</a> (const double *pA, const double *pB, size_t nDims)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the squared distance between two vectors.  <a href="#a55fd884f8786c424e1fe7a38693d3f99"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_vec.html#a0a79c3f4df55c889797593a992d16273">estimateSquaredDistanceWithUnknowns</a> (const double *pA, const double *pB, size_t nDims)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Estimates the squared distance between two points that may have some missing values. It assumes the distance in missing dimensions is approximately the same as the average distance in other dimensions. If there are no known dimensions that overlap between the two points, it returns 1e50.  <a href="#a0a79c3f4df55c889797593a992d16273"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_vec.html#af148b83f6868267931bd57a6bec1eb26">lNormDistance</a> (double norm, const double *pA, const double *pB, size_t dims)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes L-Norm distance (norm=1 is manhattan distance, norm=2 is Euclidean distance, norm=infinity is Chebychev, etc.)  <a href="#af148b83f6868267931bd57a6bec1eb26"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_vec.html#ab5d66db44ddfe72f49cba4abeb059873">correlation</a> (const double *pA, const double *pB, size_t nDims)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the cosine of the angle between two vectors (the origin is the vertex)  <a href="#ab5d66db44ddfe72f49cba4abeb059873"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_vec.html#ad47688ff203fbdbc02e80d2a6077cc0d">correlation</a> (const double *pOriginA, const double *pTargetA, const double *pB, size_t nDims)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the cosine of the angle between two vectors (the origin is the vertex)  <a href="#ad47688ff203fbdbc02e80d2a6077cc0d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_vec.html#ae49fe2c1ee82e72ad0b868d1a997aac9">correlation</a> (const double *pOriginA, const double *pTargetA, const double *pOriginB, const double *pTargetB, size_t nDims)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the cosine of the angle between two vectors (the origin is the vertex)  <a href="#ae49fe2c1ee82e72ad0b868d1a997aac9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_vec.html#a0a6f8ffafa57972a92c1427d73d01491">indexOfMin</a> (const double *pVector, size_t dims, <a class="el" href="class_g_classes_1_1_g_rand.html">GRand</a> *pRand)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of the min value in pVector. If multiple elements have have an equivalent max value, it randomly (uniformly) picks from all the ties.  <a href="#a0a6f8ffafa57972a92c1427d73d01491"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_vec.html#a60cba2eabfcd28c2f2fcea03c7c46a9e">indexOfMax</a> (const double *pVector, size_t dims, <a class="el" href="class_g_classes_1_1_g_rand.html">GRand</a> *pRand)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of the max value in pVector. If multiple elements have have an equivalent max value, it randomly (uniformly) picks from all the ties.  <a href="#a60cba2eabfcd28c2f2fcea03c7c46a9e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_vec.html#a4e336813df01516fa92b9a87d421e44b">indexOfMaxMagnitude</a> (const double *pVector, size_t dims, <a class="el" href="class_g_classes_1_1_g_rand.html">GRand</a> *pRand)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of the value with the largest magnitude in pVector. If multiple elements have have an equivalent magnitude, it randomly (uniformly) picks from all the ties.  <a href="#a4e336813df01516fa92b9a87d421e44b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_vec.html#ae5df927161272e475f91dc76508e53c8">add</a> (double *pDest, const double *pSource, size_t nDims)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds pSource to pDest.  <a href="#ae5df927161272e475f91dc76508e53c8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_vec.html#ae2272abba704018d29827b5c09fd666d">addScaled</a> (double *pDest, double dMag, const double *pSource, size_t nDims)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds dMag * pSource to pDest.  <a href="#ae2272abba704018d29827b5c09fd666d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_vec.html#a293c6ee9f0f0bf630e6904d9c90dfc88">addLog</a> (double *pDest, const double *pSource, size_t nDims)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the log of each element in pSource to pDest.  <a href="#a293c6ee9f0f0bf630e6904d9c90dfc88"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_vec.html#aee09a74814c9bc2282322a6aeda0f517">subtract</a> (double *pDest, const double *pSource, size_t nDims)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtracts pSource from pDest.  <a href="#aee09a74814c9bc2282322a6aeda0f517"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_vec.html#a8c1a41768984eac6bf3e0f6f6beac131">multiply</a> (double *pVector, double dScalar, size_t nDims)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies pVector by dScalar.  <a href="#a8c1a41768984eac6bf3e0f6f6beac131"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_vec.html#af7773eda536fbcb5addfbf9e7445376e">pow</a> (double *pVector, double dScalar, size_t nDims)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Raises each element of pVector to the exponent dScalar.  <a href="#af7773eda536fbcb5addfbf9e7445376e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_vec.html#a1ccc95f6b73416fa5e4cda65fbc27db4">pairwiseMultiply</a> (double *pDest, double *pOther, size_t dims)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies each element in pDest by the corresponding element in pOther.  <a href="#a1ccc95f6b73416fa5e4cda65fbc27db4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_vec.html#a2a4a503803276028e13013bccbd07684">pairwiseDivide</a> (double *pDest, double *pOther, size_t dims)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Divides each element in pDest by the corresponding element in pOther.  <a href="#a2a4a503803276028e13013bccbd07684"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_vec.html#a03fa72ce9efc14dc207f779e275de79d">setAll</a> (double *pVector, double value, size_t dims)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets all the elements to the specified value.  <a href="#a03fa72ce9efc14dc207f779e275de79d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_vec.html#ab3ff64f97dffc6a100c4cc9b546a8a27">interpolateIndexes</a> (size_t nIndexes, double *pInIndexes, double *pOutIndexes, float fRatio, size_t nCorrIndexes, double *pCorrIndexes1, double *pCorrIndexes2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolates (morphs) a set of indexes from one function to another. pInIndexes, pCorrIndexes1, and pCorrIndexes2 are all expected to be in sorted order. All indexes should be &gt;= 0 and &lt; nDims. fRatio is the interpolation ratio such that if fRatio is zero, all indexes left unchanged, and as fRatio approaches one, the indexes are interpolated linearly such that each index in pCorrIndexes1 is interpolated linearly to the corresponding index in pCorrIndexes2. If the two extremes are not in the list of corresponding indexes, the ends may drift.  <a href="#ab3ff64f97dffc6a100c4cc9b546a8a27"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_vec.html#a95eac0ca03ceb0909b78609fed296755">rotate</a> (double *pVector, size_t nDims, double dAngle, const double *pA, const double *pB)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotates pVector by dAngle radians in the plane defined by the orthogonal axes pA and pB.  <a href="#a95eac0ca03ceb0909b78609fed296755"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_vec.html#a2172babc7a90b6783c9c2b5726537980">addInterpolatedFunction</a> (double *pOut, size_t nOutVals, double *pIn, size_t nInVals)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the function pIn to pOut after interpolating pIn to be the same size as pOut.  <a href="#a2172babc7a90b6783c9c2b5726537980"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_g_classes_1_1_g_dom_node.html">GDomNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_vec.html#a413959f3f0edec6dcceb79ee15c73feb">serialize</a> (<a class="el" href="class_g_classes_1_1_g_dom.html">GDom</a> *pDoc, const double *pVec, size_t dims)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the vector to a text format.  <a href="#a413959f3f0edec6dcceb79ee15c73feb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_vec.html#a4e6edfd7a061959a261e5dcb7e9469a1">deserialize</a> (double *pVec, <a class="el" href="class_g_classes_1_1_g_dom_list_iterator.html">GDomListIterator</a> &amp;it)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Load the vector from a text format. pVec must be large enough to contain all of the elements that remain in "it".  <a href="#a4e6edfd7a061959a261e5dcb7e9469a1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_vec.html#a13ed57cf541c82ad6e10f0c62e2401ce">print</a> (std::ostream &amp;stream, int precision, double *pVec, size_t dims)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints the values in the vector separated by ", ". precision specifies the number of digits to print.  <a href="#a13ed57cf541c82ad6e10f0c62e2401ce"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_vec.html#a02386f08ed2e01cc6da440d36e616a0a">project</a> (double *pDest, const double *pPoint, const double *pOrigin, const double *pBasis, size_t basisCount, size_t dims)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Projects pPoint onto the hyperplane defined by pOrigin onto the basisCount basis vectors specified by pBasis. (The basis vectors are assumed to be chained end-to-end in a big vector.)  <a href="#a02386f08ed2e01cc6da440d36e616a0a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_vec.html#a83f333498b96651421d3080f2b331f62">subtractComponent</a> (double *pInOut, const double *pBasis, size_t dims)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtracts the component of pInOut that projects onto pBasis. (Assumes that pBasis is normalized.) This might be used, for example, to implement the modified Gram-Schmidt process.  <a href="#a83f333498b96651421d3080f2b331f62"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_vec.html#ac791ba945c47988ea78097815ba98348">subtractComponent</a> (double *pInOut, const double *pOrigin, const double *pTarget, size_t dims)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtracts the component of pInOut that projects onto (pTarget - pOrigin). This might be used, for example, to implement the modified Gram-Schmidt process.  <a href="#ac791ba945c47988ea78097815ba98348"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_vec.html#a71e30aa8c7faf2180e62423775a931c6">sumElements</a> (const double *pVec, size_t dims)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the sum of all the elements.  <a href="#a71e30aa8c7faf2180e62423775a931c6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_vec.html#aa1b4c95920dd249cac68065b8a5b8d81">smallestToFront</a> (double *pVec, size_t k, size_t size, double *pParallel1=NULL, size_t *pParallel2=NULL, double *pParallel3=NULL)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the smallest k values to the front of the vector, and the biggest (size - k) values to the end of the vector. (For efficiency, no other guarantees about ordering are made.) This has an average-case runtime that is linear with respect to size. pParallel1 and pParallel2 are optional arrays that should be arranged to keep their indices in sync with pVec.  <a href="#aa1b4c95920dd249cac68065b8a5b8d81"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_vec.html#ad41b6b5c4e9d5774d01f9a8ae4dda885">refinePoint</a> (double *pPoint, double *pNeighbor, size_t dims, double distance, double learningRate, <a class="el" href="class_g_classes_1_1_g_rand.html">GRand</a> *pRand)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves "pPoint" so that it is closer to a distance of "distance" from "pNeighbor". "learningRate" specifies how much to move it (0=not at all, 1=all the way). Returns the squared distance between pPoint and pNeighbor.  <a href="#ad41b6b5c4e9d5774d01f9a8ae4dda885"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_vec.html#aca682fa0c2b918c2e96dd6dc643ee8e3">toImage</a> (const double *pVec, <a class="el" href="class_g_classes_1_1_g_image.html">GImage</a> *pImage, int width, int height, int channels, double range)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a vector of rasterized pixel values to an image. channels must be 1 or 3 (for grayscale or rgb) range specifies the range of channel values. Typical values are 1.0 or 255.0. Pixels are visited in reading order (left-to-right, top-to-bottom).  <a href="#aca682fa0c2b918c2e96dd6dc643ee8e3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_vec.html#a9ece0334bb8cc2b3982b3fe76d79ab6c">fromImage</a> (<a class="el" href="class_g_classes_1_1_g_image.html">GImage</a> *pImage, double *pVec, int width, int height, int channels, double range)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an image to a vector of rasterized pixel values. channels must be 1 or 3 (for grayscale or rgb) range specifies the range of channel values. Typical values are 1.0 or 255.0. Pixels are visited in reading order (left-to-right, top-to-bottom). pVec must be big enough to hold width * height * channels values.  <a href="#a9ece0334bb8cc2b3982b3fe76d79ab6c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_vec.html#adf3511830d31f5a3d0873b79f6b1d444">capValues</a> (double *pVec, double cap, size_t dims)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets each value, v, to MIN(cap, v)  <a href="#adf3511830d31f5a3d0873b79f6b1d444"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_classes_1_1_g_vec.html#a87ea5a08a220802821e058442ff1ffd5">floorValues</a> (double *pVec, double floor, size_t dims)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets each value, v, to MAX(floor, v)  <a href="#a87ea5a08a220802821e058442ff1ffd5"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Contains some useful functions for operating on vectors. </p>
</div><hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="ae5df927161272e475f91dc76508e53c8"></a><!-- doxytag: member="GClasses::GVec::add" ref="ae5df927161272e475f91dc76508e53c8" args="(double *pDest, const double *pSource, size_t nDims)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void GClasses::GVec::add </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>pDest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>pSource</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nDims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds pSource to pDest. </p>

</div>
</div>
<a class="anchor" id="a2172babc7a90b6783c9c2b5726537980"></a><!-- doxytag: member="GClasses::GVec::addInterpolatedFunction" ref="a2172babc7a90b6783c9c2b5726537980" args="(double *pOut, size_t nOutVals, double *pIn, size_t nInVals)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void GClasses::GVec::addInterpolatedFunction </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>pOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nOutVals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>pIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nInVals</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds the function pIn to pOut after interpolating pIn to be the same size as pOut. </p>

</div>
</div>
<a class="anchor" id="a293c6ee9f0f0bf630e6904d9c90dfc88"></a><!-- doxytag: member="GClasses::GVec::addLog" ref="a293c6ee9f0f0bf630e6904d9c90dfc88" args="(double *pDest, const double *pSource, size_t nDims)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void GClasses::GVec::addLog </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>pDest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>pSource</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nDims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds the log of each element in pSource to pDest. </p>

</div>
</div>
<a class="anchor" id="ae2272abba704018d29827b5c09fd666d"></a><!-- doxytag: member="GClasses::GVec::addScaled" ref="ae2272abba704018d29827b5c09fd666d" args="(double *pDest, double dMag, const double *pSource, size_t nDims)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void GClasses::GVec::addScaled </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>pDest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dMag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>pSource</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nDims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds dMag * pSource to pDest. </p>

</div>
</div>
<a class="anchor" id="adf3511830d31f5a3d0873b79f6b1d444"></a><!-- doxytag: member="GClasses::GVec::capValues" ref="adf3511830d31f5a3d0873b79f6b1d444" args="(double *pVec, double cap, size_t dims)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void GClasses::GVec::capValues </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>pVec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>cap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets each value, v, to MIN(cap, v) </p>

</div>
</div>
<a class="anchor" id="afd693b7f1356ccdd5994e14a27166c6d"></a><!-- doxytag: member="GClasses::GVec::copy" ref="afd693b7f1356ccdd5994e14a27166c6d" args="(double *pDest, const double *pSource, size_t nDims)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void GClasses::GVec::copy </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>pDest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>pSource</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nDims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This just wraps memcpy. </p>

</div>
</div>
<a class="anchor" id="ad47688ff203fbdbc02e80d2a6077cc0d"></a><!-- doxytag: member="GClasses::GVec::correlation" ref="ad47688ff203fbdbc02e80d2a6077cc0d" args="(const double *pOriginA, const double *pTargetA, const double *pB, size_t nDims)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static double GClasses::GVec::correlation </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>pOriginA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>pTargetA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>pB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nDims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes the cosine of the angle between two vectors (the origin is the vertex) </p>

</div>
</div>
<a class="anchor" id="ae49fe2c1ee82e72ad0b868d1a997aac9"></a><!-- doxytag: member="GClasses::GVec::correlation" ref="ae49fe2c1ee82e72ad0b868d1a997aac9" args="(const double *pOriginA, const double *pTargetA, const double *pOriginB, const double *pTargetB, size_t nDims)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static double GClasses::GVec::correlation </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>pOriginA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>pTargetA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>pOriginB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>pTargetB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nDims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes the cosine of the angle between two vectors (the origin is the vertex) </p>

</div>
</div>
<a class="anchor" id="ab5d66db44ddfe72f49cba4abeb059873"></a><!-- doxytag: member="GClasses::GVec::correlation" ref="ab5d66db44ddfe72f49cba4abeb059873" args="(const double *pA, const double *pB, size_t nDims)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static double GClasses::GVec::correlation </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>pA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>pB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nDims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes the cosine of the angle between two vectors (the origin is the vertex) </p>

</div>
</div>
<a class="anchor" id="a4e6edfd7a061959a261e5dcb7e9469a1"></a><!-- doxytag: member="GClasses::GVec::deserialize" ref="a4e6edfd7a061959a261e5dcb7e9469a1" args="(double *pVec, GDomListIterator &amp;it)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void GClasses::GVec::deserialize </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>pVec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_g_classes_1_1_g_dom_list_iterator.html">GDomListIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>it</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Load the vector from a text format. pVec must be large enough to contain all of the elements that remain in "it". </p>

</div>
</div>
<a class="anchor" id="a2393f822ffca8066dc071650eb16d2b8"></a><!-- doxytag: member="GClasses::GVec::doesContainUnknowns" ref="a2393f822ffca8066dc071650eb16d2b8" args="(const double *pVector, size_t nSize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool GClasses::GVec::doesContainUnknowns </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>pVector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This returns true if the vector contains any unknown values. Most of the methods in this class will give bad results if a vector contains unknown values, but for efficiency reasons, they don't check. So it's your job to check your vectors first. </p>

</div>
</div>
<a class="anchor" id="a999a0aec27be025bbdbdd2a84f41b679"></a><!-- doxytag: member="GClasses::GVec::dotProduct" ref="a999a0aec27be025bbdbdd2a84f41b679" args="(const double *pA, const double *pB, size_t nSize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static double GClasses::GVec::dotProduct </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>pA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>pB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes the dot product of two vectors. Results are undefined if pA or pB contain unknown values. </p>

</div>
</div>
<a class="anchor" id="a6aa718706f7dc9c7cef3d5662f780ef8"></a><!-- doxytag: member="GClasses::GVec::dotProduct" ref="a6aa718706f7dc9c7cef3d5662f780ef8" args="(const double *pOrigin, const double *pTarget, const double *pVector, size_t nSize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static double GClasses::GVec::dotProduct </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>pOrigin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>pTarget</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>pVector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes the dot product of (pTarget - pOrigin) with pVector. </p>

</div>
</div>
<a class="anchor" id="aa62bfcd53a73a1e0a0ffde5984f91a12"></a><!-- doxytag: member="GClasses::GVec::dotProduct" ref="aa62bfcd53a73a1e0a0ffde5984f91a12" args="(const double *pOriginA, const double *pTargetA, const double *pOriginB, const double *pTargetB, size_t nSize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static double GClasses::GVec::dotProduct </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>pOriginA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>pTargetA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>pOriginB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>pTargetB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes the dot product of (pTargetA - pOriginA) with (pTargetB - pOriginB). </p>

</div>
</div>
<a class="anchor" id="a03aeec0023dc0e0710be67b054fd3675"></a><!-- doxytag: member="GClasses::GVec::dotProductIgnoringUnknowns" ref="a03aeec0023dc0e0710be67b054fd3675" args="(const double *pOrigin, const double *pTarget, const double *pVector, size_t nSize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static double GClasses::GVec::dotProductIgnoringUnknowns </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>pOrigin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>pTarget</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>pVector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes the dot product of (pTarget - pOrigin) with pVector. Unknown values in pTarget will simply be ignored. (pOrigin and pVector must not contain any unknown values.) </p>

</div>
</div>
<a class="anchor" id="a0a79c3f4df55c889797593a992d16273"></a><!-- doxytag: member="GClasses::GVec::estimateSquaredDistanceWithUnknowns" ref="a0a79c3f4df55c889797593a992d16273" args="(const double *pA, const double *pB, size_t nDims)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static double GClasses::GVec::estimateSquaredDistanceWithUnknowns </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>pA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>pB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nDims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Estimates the squared distance between two points that may have some missing values. It assumes the distance in missing dimensions is approximately the same as the average distance in other dimensions. If there are no known dimensions that overlap between the two points, it returns 1e50. </p>

</div>
</div>
<a class="anchor" id="a87ea5a08a220802821e058442ff1ffd5"></a><!-- doxytag: member="GClasses::GVec::floorValues" ref="a87ea5a08a220802821e058442ff1ffd5" args="(double *pVec, double floor, size_t dims)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void GClasses::GVec::floorValues </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>pVec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>floor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets each value, v, to MAX(floor, v) </p>

</div>
</div>
<a class="anchor" id="a9ece0334bb8cc2b3982b3fe76d79ab6c"></a><!-- doxytag: member="GClasses::GVec::fromImage" ref="a9ece0334bb8cc2b3982b3fe76d79ab6c" args="(GImage *pImage, double *pVec, int width, int height, int channels, double range)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void GClasses::GVec::fromImage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_g_classes_1_1_g_image.html">GImage</a> *&#160;</td>
          <td class="paramname"><em>pImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>pVec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>channels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>range</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Converts an image to a vector of rasterized pixel values. channels must be 1 or 3 (for grayscale or rgb) range specifies the range of channel values. Typical values are 1.0 or 255.0. Pixels are visited in reading order (left-to-right, top-to-bottom). pVec must be big enough to hold width * height * channels values. </p>

</div>
</div>
<a class="anchor" id="a60cba2eabfcd28c2f2fcea03c7c46a9e"></a><!-- doxytag: member="GClasses::GVec::indexOfMax" ref="a60cba2eabfcd28c2f2fcea03c7c46a9e" args="(const double *pVector, size_t dims, GRand *pRand)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static size_t GClasses::GVec::indexOfMax </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>pVector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_g_classes_1_1_g_rand.html">GRand</a> *&#160;</td>
          <td class="paramname"><em>pRand</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the index of the max value in pVector. If multiple elements have have an equivalent max value, it randomly (uniformly) picks from all the ties. </p>

</div>
</div>
<a class="anchor" id="a4e336813df01516fa92b9a87d421e44b"></a><!-- doxytag: member="GClasses::GVec::indexOfMaxMagnitude" ref="a4e336813df01516fa92b9a87d421e44b" args="(const double *pVector, size_t dims, GRand *pRand)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static size_t GClasses::GVec::indexOfMaxMagnitude </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>pVector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_g_classes_1_1_g_rand.html">GRand</a> *&#160;</td>
          <td class="paramname"><em>pRand</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the index of the value with the largest magnitude in pVector. If multiple elements have have an equivalent magnitude, it randomly (uniformly) picks from all the ties. </p>

</div>
</div>
<a class="anchor" id="a0a6f8ffafa57972a92c1427d73d01491"></a><!-- doxytag: member="GClasses::GVec::indexOfMin" ref="a0a6f8ffafa57972a92c1427d73d01491" args="(const double *pVector, size_t dims, GRand *pRand)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static size_t GClasses::GVec::indexOfMin </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>pVector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_g_classes_1_1_g_rand.html">GRand</a> *&#160;</td>
          <td class="paramname"><em>pRand</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the index of the min value in pVector. If multiple elements have have an equivalent max value, it randomly (uniformly) picks from all the ties. </p>

</div>
</div>
<a class="anchor" id="ab3ff64f97dffc6a100c4cc9b546a8a27"></a><!-- doxytag: member="GClasses::GVec::interpolateIndexes" ref="ab3ff64f97dffc6a100c4cc9b546a8a27" args="(size_t nIndexes, double *pInIndexes, double *pOutIndexes, float fRatio, size_t nCorrIndexes, double *pCorrIndexes1, double *pCorrIndexes2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void GClasses::GVec::interpolateIndexes </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nIndexes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>pInIndexes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>pOutIndexes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>fRatio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nCorrIndexes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>pCorrIndexes1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>pCorrIndexes2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Interpolates (morphs) a set of indexes from one function to another. pInIndexes, pCorrIndexes1, and pCorrIndexes2 are all expected to be in sorted order. All indexes should be &gt;= 0 and &lt; nDims. fRatio is the interpolation ratio such that if fRatio is zero, all indexes left unchanged, and as fRatio approaches one, the indexes are interpolated linearly such that each index in pCorrIndexes1 is interpolated linearly to the corresponding index in pCorrIndexes2. If the two extremes are not in the list of corresponding indexes, the ends may drift. </p>

</div>
</div>
<a class="anchor" id="af148b83f6868267931bd57a6bec1eb26"></a><!-- doxytag: member="GClasses::GVec::lNormDistance" ref="af148b83f6868267931bd57a6bec1eb26" args="(double norm, const double *pA, const double *pB, size_t dims)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static double GClasses::GVec::lNormDistance </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>norm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>pA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>pB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes L-Norm distance (norm=1 is manhattan distance, norm=2 is Euclidean distance, norm=infinity is Chebychev, etc.) </p>

</div>
</div>
<a class="anchor" id="a6b055fab2831155f9525286c0e82172a"></a><!-- doxytag: member="GClasses::GVec::lNormMagnitude" ref="a6b055fab2831155f9525286c0e82172a" args="(double norm, const double *pVector, size_t nSize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static double GClasses::GVec::lNormMagnitude </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>norm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>pVector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes the magnitude in L-Norm distance (norm=1 is manhattan distance, norm=2 is Euclidean distance, norm=infinity is Chebychev, etc.) </p>

</div>
</div>
<a class="anchor" id="af884553949a2e2620b6aebfa92c066be"></a><!-- doxytag: member="GClasses::GVec::lNormNormalize" ref="af884553949a2e2620b6aebfa92c066be" args="(double norm, double *pVector, size_t nSize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void GClasses::GVec::lNormNormalize </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>norm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>pVector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Normalizes with L-Norm distance (norm=1 is manhattan distance, norm=2 is Euclidean distance, norm=infinity is Chebychev, etc.) </p>

</div>
</div>
<a class="anchor" id="a8c1a41768984eac6bf3e0f6f6beac131"></a><!-- doxytag: member="GClasses::GVec::multiply" ref="a8c1a41768984eac6bf3e0f6f6beac131" args="(double *pVector, double dScalar, size_t nDims)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void GClasses::GVec::multiply </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>pVector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dScalar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nDims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Multiplies pVector by dScalar. </p>

</div>
</div>
<a class="anchor" id="aef089f6c7327a29177a6c95ba060d3ca"></a><!-- doxytag: member="GClasses::GVec::normalize" ref="aef089f6c7327a29177a6c95ba060d3ca" args="(double *pVector, size_t nSize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void GClasses::GVec::normalize </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>pVector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Normalizes this vector to a magnitude of 1. Throws an exception if the magnitude is zero. </p>

</div>
</div>
<a class="anchor" id="a2a4a503803276028e13013bccbd07684"></a><!-- doxytag: member="GClasses::GVec::pairwiseDivide" ref="a2a4a503803276028e13013bccbd07684" args="(double *pDest, double *pOther, size_t dims)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void GClasses::GVec::pairwiseDivide </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>pDest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>pOther</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Divides each element in pDest by the corresponding element in pOther. </p>

</div>
</div>
<a class="anchor" id="a1ccc95f6b73416fa5e4cda65fbc27db4"></a><!-- doxytag: member="GClasses::GVec::pairwiseMultiply" ref="a1ccc95f6b73416fa5e4cda65fbc27db4" args="(double *pDest, double *pOther, size_t dims)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void GClasses::GVec::pairwiseMultiply </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>pDest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>pOther</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Multiplies each element in pDest by the corresponding element in pOther. </p>

</div>
</div>
<a class="anchor" id="af7773eda536fbcb5addfbf9e7445376e"></a><!-- doxytag: member="GClasses::GVec::pow" ref="af7773eda536fbcb5addfbf9e7445376e" args="(double *pVector, double dScalar, size_t nDims)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void GClasses::GVec::pow </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>pVector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dScalar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nDims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Raises each element of pVector to the exponent dScalar. </p>

</div>
</div>
<a class="anchor" id="a13ed57cf541c82ad6e10f0c62e2401ce"></a><!-- doxytag: member="GClasses::GVec::print" ref="a13ed57cf541c82ad6e10f0c62e2401ce" args="(std::ostream &amp;stream, int precision, double *pVec, size_t dims)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void GClasses::GVec::print </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>precision</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>pVec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Prints the values in the vector separated by ", ". precision specifies the number of digits to print. </p>

</div>
</div>
<a class="anchor" id="a02386f08ed2e01cc6da440d36e616a0a"></a><!-- doxytag: member="GClasses::GVec::project" ref="a02386f08ed2e01cc6da440d36e616a0a" args="(double *pDest, const double *pPoint, const double *pOrigin, const double *pBasis, size_t basisCount, size_t dims)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void GClasses::GVec::project </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>pDest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>pPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>pOrigin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>pBasis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>basisCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Projects pPoint onto the hyperplane defined by pOrigin onto the basisCount basis vectors specified by pBasis. (The basis vectors are assumed to be chained end-to-end in a big vector.) </p>

</div>
</div>
<a class="anchor" id="ad41b6b5c4e9d5774d01f9a8ae4dda885"></a><!-- doxytag: member="GClasses::GVec::refinePoint" ref="ad41b6b5c4e9d5774d01f9a8ae4dda885" args="(double *pPoint, double *pNeighbor, size_t dims, double distance, double learningRate, GRand *pRand)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static double GClasses::GVec::refinePoint </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>pPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>pNeighbor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>distance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>learningRate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_g_classes_1_1_g_rand.html">GRand</a> *&#160;</td>
          <td class="paramname"><em>pRand</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Moves "pPoint" so that it is closer to a distance of "distance" from "pNeighbor". "learningRate" specifies how much to move it (0=not at all, 1=all the way). Returns the squared distance between pPoint and pNeighbor. </p>

</div>
</div>
<a class="anchor" id="a95eac0ca03ceb0909b78609fed296755"></a><!-- doxytag: member="GClasses::GVec::rotate" ref="a95eac0ca03ceb0909b78609fed296755" args="(double *pVector, size_t nDims, double dAngle, const double *pA, const double *pB)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void GClasses::GVec::rotate </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>pVector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nDims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dAngle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>pA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>pB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Rotates pVector by dAngle radians in the plane defined by the orthogonal axes pA and pB. </p>

</div>
</div>
<a class="anchor" id="abbcc093fa7864ffb6323aab65fa217bb"></a><!-- doxytag: member="GClasses::GVec::safeNormalize" ref="abbcc093fa7864ffb6323aab65fa217bb" args="(double *pVector, size_t nSize, GRand *pRand)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void GClasses::GVec::safeNormalize </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>pVector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_g_classes_1_1_g_rand.html">GRand</a> *&#160;</td>
          <td class="paramname"><em>pRand</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Normalizes this vector to a magnitude of 1. If the magnitude is zero, it returns a random vector. </p>

</div>
</div>
<a class="anchor" id="a413959f3f0edec6dcceb79ee15c73feb"></a><!-- doxytag: member="GClasses::GVec::serialize" ref="a413959f3f0edec6dcceb79ee15c73feb" args="(GDom *pDoc, const double *pVec, size_t dims)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_g_classes_1_1_g_dom_node.html">GDomNode</a>* GClasses::GVec::serialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_g_classes_1_1_g_dom.html">GDom</a> *&#160;</td>
          <td class="paramname"><em>pDoc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>pVec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Write the vector to a text format. </p>

</div>
</div>
<a class="anchor" id="a03fa72ce9efc14dc207f779e275de79d"></a><!-- doxytag: member="GClasses::GVec::setAll" ref="a03fa72ce9efc14dc207f779e275de79d" args="(double *pVector, double value, size_t dims)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void GClasses::GVec::setAll </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>pVector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets all the elements to the specified value. </p>

</div>
</div>
<a class="anchor" id="aa1b4c95920dd249cac68065b8a5b8d81"></a><!-- doxytag: member="GClasses::GVec::smallestToFront" ref="aa1b4c95920dd249cac68065b8a5b8d81" args="(double *pVec, size_t k, size_t size, double *pParallel1=NULL, size_t *pParallel2=NULL, double *pParallel3=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void GClasses::GVec::smallestToFront </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>pVec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>pParallel1</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>pParallel2</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>pParallel3</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Moves the smallest k values to the front of the vector, and the biggest (size - k) values to the end of the vector. (For efficiency, no other guarantees about ordering are made.) This has an average-case runtime that is linear with respect to size. pParallel1 and pParallel2 are optional arrays that should be arranged to keep their indices in sync with pVec. </p>

</div>
</div>
<a class="anchor" id="a55fd884f8786c424e1fe7a38693d3f99"></a><!-- doxytag: member="GClasses::GVec::squaredDistance" ref="a55fd884f8786c424e1fe7a38693d3f99" args="(const double *pA, const double *pB, size_t nDims)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static double GClasses::GVec::squaredDistance </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>pA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>pB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nDims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes the squared distance between two vectors. </p>

</div>
</div>
<a class="anchor" id="afa502d0561a5d93b7ba5d921807d1357"></a><!-- doxytag: member="GClasses::GVec::squaredMagnitude" ref="afa502d0561a5d93b7ba5d921807d1357" args="(const double *pVector, size_t nSize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static double GClasses::GVec::squaredMagnitude </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>pVector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes the squared magnitude of the vector. </p>

</div>
</div>
<a class="anchor" id="aee09a74814c9bc2282322a6aeda0f517"></a><!-- doxytag: member="GClasses::GVec::subtract" ref="aee09a74814c9bc2282322a6aeda0f517" args="(double *pDest, const double *pSource, size_t nDims)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void GClasses::GVec::subtract </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>pDest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>pSource</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nDims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Subtracts pSource from pDest. </p>

</div>
</div>
<a class="anchor" id="ac791ba945c47988ea78097815ba98348"></a><!-- doxytag: member="GClasses::GVec::subtractComponent" ref="ac791ba945c47988ea78097815ba98348" args="(double *pInOut, const double *pOrigin, const double *pTarget, size_t dims)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void GClasses::GVec::subtractComponent </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>pInOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>pOrigin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>pTarget</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Subtracts the component of pInOut that projects onto (pTarget - pOrigin). This might be used, for example, to implement the modified Gram-Schmidt process. </p>

</div>
</div>
<a class="anchor" id="a83f333498b96651421d3080f2b331f62"></a><!-- doxytag: member="GClasses::GVec::subtractComponent" ref="a83f333498b96651421d3080f2b331f62" args="(double *pInOut, const double *pBasis, size_t dims)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void GClasses::GVec::subtractComponent </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>pInOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>pBasis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Subtracts the component of pInOut that projects onto pBasis. (Assumes that pBasis is normalized.) This might be used, for example, to implement the modified Gram-Schmidt process. </p>

</div>
</div>
<a class="anchor" id="a71e30aa8c7faf2180e62423775a931c6"></a><!-- doxytag: member="GClasses::GVec::sumElements" ref="a71e30aa8c7faf2180e62423775a931c6" args="(const double *pVec, size_t dims)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static double GClasses::GVec::sumElements </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>pVec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the sum of all the elements. </p>

</div>
</div>
<a class="anchor" id="a0e168891d658169a8cf0c749ebb35599"></a><!-- doxytag: member="GClasses::GVec::sumToOne" ref="a0e168891d658169a8cf0c749ebb35599" args="(double *pVector, size_t size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void GClasses::GVec::sumToOne </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>pVector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Scale the vector so that the elements sum to 1. </p>

</div>
</div>
<a class="anchor" id="abc125909fcdf11788338ee7b32098e12"></a><!-- doxytag: member="GClasses::GVec::test" ref="abc125909fcdf11788338ee7b32098e12" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void GClasses::GVec::test </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Performs unit tests for this class. Throws an exception if there is a failure. </p>

</div>
</div>
<a class="anchor" id="aca682fa0c2b918c2e96dd6dc643ee8e3"></a><!-- doxytag: member="GClasses::GVec::toImage" ref="aca682fa0c2b918c2e96dd6dc643ee8e3" args="(const double *pVec, GImage *pImage, int width, int height, int channels, double range)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void GClasses::GVec::toImage </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>pVec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_g_classes_1_1_g_image.html">GImage</a> *&#160;</td>
          <td class="paramname"><em>pImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>channels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>range</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Converts a vector of rasterized pixel values to an image. channels must be 1 or 3 (for grayscale or rgb) range specifies the range of channel values. Typical values are 1.0 or 255.0. Pixels are visited in reading order (left-to-right, top-to-bottom). </p>

</div>
</div>
</div>
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="namespace_g_classes.html">GClasses</a>      </li>
      <li class="navelem"><a class="el" href="class_g_classes_1_1_g_vec.html">GVec</a>      </li>
      <li class="footer">Generated on Mon Dec 5 2011 14:19:04 for GClasses by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.3 </li>
    </ul>
  </div>

</body>
</html>
